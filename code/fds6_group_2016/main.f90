PROGRAM FDS

! Fire Dynamics Simulator, Main Program, Multiple CPU version.

USE PRECISION_PARAMETERS
USE MESH_VARIABLES
USE GLOBAL_CONSTANTS
USE TRAN
USE DUMP
USE READ_INPUT
USE INIT
!USE DIVG
!USE PRES
USE MASS
!USE PART
!USE VEGE
!USE VELO
!USE RAD
USE RADCONS, ONLY : DLN
USE OUTPUT_DATA
USE MEMORY_FUNCTIONS
!USE HVAC_ROUTINES
USE COMP_FUNCTIONS, ONLY : SECOND, WALL_CLOCK_TIME
USE DEVICE_VARIABLES
!USE WALL_ROUTINES
!USE FIRE
USE CONTROL_FUNCTIONS
USE EVAC
!USE TURBULENCE, ONLY: NS_ANALYTICAL_SOLUTION,INIT_TURB_ARRAYS,COMPRESSION_WAVE,TWOD_VORTEX_CERFACS,TWOD_VORTEX_UMD, &
!                      SYNTHETIC_TURBULENCE,SYNTHETIC_EDDY_SETUP,SANDIA_DAT
!USE MANUFACTURED_SOLUTIONS, ONLY: SHUNN_MMS_3,SAAD_MMS_1
!USE COMPLEX_GEOMETRY, ONLY: INIT_IBM, SET_CUTCELLS_3D
USE OPENMP
USE MPI
!USE SCRC, ONLY: SCARC_SETUP, SCARC_SOLVER, SCARC_TIMINGS
!USE SOOT_ROUTINES, ONLY: CALC_AGGLOMERATION

IMPLICIT NONE

! Miscellaneous declarations

LOGICAL  :: EX=.FALSE.,DIAGNOSTICS,EXCHANGE_EVACUATION=.FALSE.,CALL_UPDATE_CONTROLS,CTRL_STOP_STATUS
INTEGER  :: LO10,NM,IZERO,CNT,ANG_INC_COUNTER
REAL(EB) :: T,DT,DT_EVAC,TNOW
REAL(EB), ALLOCATABLE, DIMENSION(:) ::  TC_GLB,TC_LOC,DT_NEW,TI_LOC,TI_GLB, &
                                        DSUM_ALL,PSUM_ALL,USUM_ALL,DSUM_ALL_LOCAL,PSUM_ALL_LOCAL,USUM_ALL_LOCAL
LOGICAL, ALLOCATABLE, DIMENSION(:,:) :: CONNECTED_ZONES_GLOBAL,CONNECTED_ZONES_LOCAL
LOGICAL, ALLOCATABLE, DIMENSION(:) ::  STATE_GLB,STATE_LOC
INTEGER :: NOM,IWW,IW
TYPE (MESH_TYPE), POINTER :: M,M4
TYPE (OMESH_TYPE), POINTER :: M2,M3,M5

! MPI stuff

INTEGER :: N,I,IERR=0,STATUS(MPI_STATUS_SIZE)
INTEGER :: PNAMELEN=0,TAG_EVAC
INTEGER :: PROVIDED
INTEGER, PARAMETER :: REQUIRED=MPI_THREAD_SINGLE
INTEGER, ALLOCATABLE, DIMENSION(:) :: REQ,REQ1,REQ2,REQ3,REQ4,REQ5,REQ6,REQ7,REQ8,REQ9,COUNTS,DISPLS,&
                                      COUNTS2D,DISPLS2D, &
                                      COUNTS_MASS,DISPLS_MASS,COUNTS_HVAC,DISPLS_HVAC,COUNTS_Q_DOT,DISPLS_Q_DOT, &
                                      COUNTS_M_DOT,DISPLS_M_DOT,COUNTS_HVAC_SPECIES,DISPLS_HVAC_SPECIES,COUNTS_ERROR,DISPLS_ERROR
INTEGER :: N_REQ,N_REQ1,N_REQ2,N_REQ3,N_REQ4,N_REQ5,N_REQ6,N_REQ7,N_REQ8,N_REQ9,N_COMMUNICATIONS
CHARACTER(MPI_MAX_PROCESSOR_NAME) :: PNAME
INTEGER, ALLOCATABLE, DIMENSION(:)        :: INTEGER_BUFFER_1
INTEGER, ALLOCATABLE, DIMENSION(:,:)      :: INTEGER_BUFFER_2,INTEGER_BUFFER_3
REAL(EB), ALLOCATABLE, DIMENSION(:)       :: REAL_BUFFER_1
REAL(EB), ALLOCATABLE, DIMENSION(:,:)     :: REAL_BUFFER_5,REAL_BUFFER_6,REAL_BUFFER_10,REAL_BUFFER_11,REAL_BUFFER_12
REAL(EB), ALLOCATABLE, DIMENSION(:,:,:)   :: REAL_BUFFER_7,REAL_BUFFER_8
REAL(EB), ALLOCATABLE, DIMENSION(:,:,:,:) :: REAL_BUFFER_9
LOGICAL, ALLOCATABLE, DIMENSION(:)        :: LOGICAL_BUFFER_1

! Initialize MPI (First executable lines of code)

CALL MPI_INIT_THREAD(REQUIRED,PROVIDED,IERR)
CALL MPI_COMM_RANK(MPI_COMM_WORLD, MYID, IERR)
CALL MPI_COMM_SIZE(MPI_COMM_WORLD, N_MPI_PROCESSES, IERR)
CALL MPI_GET_PROCESSOR_NAME(PNAME, PNAMELEN, IERR)

IF (PNAME/='null') USE_MPI = .TRUE.

! Initialize OpenMP

CALL OPENMP_INIT

! Check that MPI processes and OpenMP threads are working properly

CALL CHECK_MPI

! Start wall clock timing

INITIALIZATION_PHASE = .TRUE.
WALL_CLOCK_START = WALL_CLOCK_TIME()
ALLOCATE(T_USED(N_TIMERS)) ; T_USED = 0._EB ; T_USED(1) = SECOND()

! Assign a compilation date (All Nodes)

WRITE(VERSION_STRING,'(A)') 'FDS 6.5.3'

CALL GET_INFO (REVISION,REVISION_DATE,COMPILE_DATE)

! Read input from CHID.fds file and stop the code if any errors are found

CALL READ_DATA(DT)

! Initial complex geometry CC setup

!IF (CC_IBM) CALL SET_CUTCELLS_3D

CALL STOP_CHECK(1)

! Setup number of OPENMP threads

CALL OPENMP_SET_THREADS

! Print OPENMP thread status

CALL OPENMP_PRINT_STATUS

! Set up send and receive buffer counts and displacements

CALL MPI_INITIALIZATION_CHORES(1)

! Open and write to Smokeview and status file (Master Node Only)

CALL ASSIGN_FILE_NAMES

DO N=0,N_MPI_PROCESSES-1
   IF (MYID==N) CALL WRITE_SMOKEVIEW_FILE
   IF (N==N_MPI_PROCESSES-1) EXIT
   IF (SHARED_FILE_SYSTEM) CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
ENDDO
CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
IF (MYID==0) THEN
   OPEN(LU_SMV,FILE=FN_SMV,FORM='FORMATTED', STATUS='OLD',POSITION='APPEND')
   CALL WRITE_STATUS_FILES
ENDIF

! Start the clock

T = T_BEGIN

! Stop all the processes if this is just a set-up run

IF (SET_UP_ONLY) THEN
   !IF (MYID==0) CALL INITIALIZE_DIAGNOSTIC_FILE(DT)
   STOP_STATUS = SETUP_ONLY_STOP
   CALL STOP_CHECK(1)
ENDIF

! Allocate various utility arrays

CALL MPI_INITIALIZATION_CHORES(2)

! Initialize global parameters

CALL INITIALIZE_GLOBAL_VARIABLES
CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)

! Initialize radiation

!IF (RADIATION) CALL INIT_RADIATION

! Allocate and initialize mesh-specific variables, and check to see if the code should stop

DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   CALL INITIALIZE_MESH_VARIABLES_1(DT,NM)
ENDDO
CALL STOP_CHECK(1)

! Allocate and initialize OMESH arrays to hold "other mesh" data for a given mesh

N_COMMUNICATIONS = 0

DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   CALL INITIALIZE_MESH_EXCHANGE_1(NM)
ENDDO
CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)

! Allocate "request" arrays to keep track of MPI communications

CALL MPI_INITIALIZATION_CHORES(3)

! Exchange information related to size of OMESH arrays

CALL MPI_INITIALIZATION_CHORES(4)

! Allocate and initialize OMESH arrays to hold "other mesh" data for a given mesh

DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   CALL INITIALIZE_MESH_EXCHANGE_2(NM)
ENDDO
CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)

! Exchange CELL_COUNT, the dimension of various arrays related to obstructions

IF (N_MPI_PROCESSES>1) THEN
   CALL MPI_ALLGATHERV(MPI_IN_PLACE,COUNTS(MYID),MPI_INTEGER,CELL_COUNT,COUNTS,DISPLS,MPI_INTEGER,MPI_COMM_WORLD,IERR)
ENDIF

! Initialize persistent MPI sends and receives and allocate buffer arrays.

N_REQ1 = 0
N_REQ2 = 0
N_REQ3 = 0
N_REQ4 = 0
N_REQ5 = 0
N_REQ6 = 0
N_REQ7 = 0
N_REQ8 = 0
N_REQ9 = 0

CALL POST_RECEIVES(0)
CALL MESH_EXCHANGE(0)

! Finish initializing mesh variables

DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   CALL INITIALIZE_MESH_VARIABLES_2(NM)
ENDDO

! Create arrays and communicators to exchange back wall information across mesh boundaries

!CALL INITIALIZE_BACK_WALL_EXCHANGE

CALL STOP_CHECK(1)

! Initialize ScaRC solver

!IF (PRES_METHOD == 'SCARC') CALL SCARC_SETUP

! Initialize turb arrays

!DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
!   IF (TGA_SURF_INDEX>0) CYCLE
!   CALL INIT_TURB_ARRAYS(NM)
!ENDDO

! Initialize unstructured geometry

!IF (N_FACE>0) THEN
!   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      !CALL INIT_IBM(0._EB,NM)
!   ENDDO
!ENDIF

! Initialize the flow field with random noise to eliminate false symmetries

!DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
!   IF (TGA_SURF_INDEX>0 .OR. EVACUATION_ONLY(NM)) CYCLE
!   IF (NOISE) CALL INITIAL_NOISE(NM)
!   IF (PERIODIC_TEST==1) CALL NS_ANALYTICAL_SOLUTION(NM,T_BEGIN,RK_STAGE=2)
!   IF (PERIODIC_TEST==2) CALL UVW_INIT(NM,UVW_FILE)
!   IF (PERIODIC_TEST==3) CALL COMPRESSION_WAVE(NM,0._EB,3)
!   IF (PERIODIC_TEST==4) CALL COMPRESSION_WAVE(NM,0._EB,4)
!   IF (PERIODIC_TEST==6) CALL TWOD_VORTEX_CERFACS(NM)
!   IF (PERIODIC_TEST==7) CALL SHUNN_MMS_3(DT,NM)
!   IF (PERIODIC_TEST==8) CALL NS_ANALYTICAL_SOLUTION(NM,T_BEGIN,RK_STAGE=2)
!   IF (PERIODIC_TEST==9) CALL SANDIA_DAT(NM,UVW_FILE)
!   IF (PERIODIC_TEST==10) CALL TWOD_VORTEX_UMD(NM)
!   IF (PERIODIC_TEST==11) CALL SAAD_MMS_1(NM)
!   IF (UVW_RESTART)      CALL UVW_INIT(NM,CSVFINFO(NM)%UVWFILE)
!   CALL COMPUTE_VISCOSITY(T_BEGIN,NM) ! needed here for KRES prior to mesh exchange
!ENDDO

! Exchange information at mesh boundaries related to the various initialization routines just completed

CALL MESH_EXCHANGE(1)
CALL MESH_EXCHANGE(4)
CALL POST_RECEIVES(6)
CALL MESH_EXCHANGE(6)

! Ensure normal components of velocity match at mesh boundaries and do velocity BCs just in case the flow is not initialized to zero

PREDICTOR = .FALSE.
CORRECTOR = .TRUE.

!DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
!   IF (TGA_SURF_INDEX>0 .OR. EVACUATION_ONLY(NM)) CYCLE
!   CALL MATCH_VELOCITY(NM)
!   CALL COMPUTE_VISCOSITY(T_BEGIN,NM) ! call again after mesh exchange
!   IF (SYNTHETIC_EDDY_METHOD) CALL SYNTHETIC_EDDY_SETUP(NM)
!   CALL VELOCITY_BC(T_BEGIN,NM)
!   CALL VISCOSITY_BC(NM)
!ENDDO

! Iterate surface BCs and radiation in case temperatures are not initialized to ambient

!DO I=1,INITIAL_RADIATION_ITERATIONS
!   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
!      IF (EVACUATION_ONLY(NM)) CYCLE
!      CALL WALL_BC(T_BEGIN,DT,NM)
!      IF (RADIATION) CALL COMPUTE_RADIATION(T_BEGIN,NM,1)
!   ENDDO
!   DO ANG_INC_COUNTER=1,ANGLE_INCREMENT
!      CALL MESH_EXCHANGE(2) ! Exchange radiation intensity at interpolated boundaries
!   ENDDO
!ENDDO

! Compute divergence just in case the flow field is not initialized to ambient

!DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
!   IF (EVACUATION_ONLY(NM)) CYCLE
!   CALL DIVERGENCE_PART_1(T_BEGIN,DT,NM)
!ENDDO

! Potentially read data from a previous calculation

DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   !IF (RESTART) CALL READ_RESTART(T,DT,NM)
ENDDO
CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)

! Initialize output files that are mesh-specific

DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   IF (TGA_SURF_INDEX<1) CALL INITIALIZE_MESH_DUMPS(NM)
   !CALL INITIALIZE_PARTICLES(NM)
   !CALL INSERT_PARTICLES(T,NM)
   IF (TGA_SURF_INDEX<1) CALL INITIALIZE_DEVICES(NM)
   IF (TGA_SURF_INDEX<1) CALL INITIALIZE_PROFILES(NM)
ENDDO
CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)

! Check for any stop flags at this point in the set up.

CALL STOP_CHECK(1)

! Check to see if only a TGA analysis is to be performed

!IF (TGA_SURF_INDEX>0) THEN
!   IF (MYID==0) CALL TGA_ANALYSIS
!   STOP_STATUS = TGA_ANALYSIS_STOP
!   CALL STOP_CHECK(1)
!ENDIF

! Initialize output files containing global data (Master Node Only)

IF (MYID==0) CALL INITIALIZE_GLOBAL_DUMPS(T,DT)
CALL INIT_EVAC_DUMPS
CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)

! Initialize EVACuation routines

IF (ANY(EVACUATION_ONLY)) THEN
   CALL INITIALIZE_EVAC
   IF ((.NOT.USE_MPI .OR. N_MPI_PROCESSES==1) .OR. (N_MPI_PROCESSES>1 .AND. MYID==EVAC_PROCESS)) CALL INIT_EVAC_GROUPS
   IF(ALL(EVACUATION_ONLY)) HVAC_SOLVE=.FALSE.
ENDIF

! Initialize HVAC variables
!IF (HVAC_SOLVE) THEN
!   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
!      IF (EVACUATION_ONLY(NM)) CYCLE
!      CALL HVAC_BC_IN(NM)
!   ENDDO
!   IF (N_MPI_PROCESSES>1) CALL EXCHANGE_HVAC_BC
!   IF (PROCESS(1)==MYID) THEN
!      CALL COLLAPSE_HVAC_BC
!      CALL SET_INIT_HVAC
!   ENDIF
!ENDIF

! Make an initial dump of ambient values

IF (.NOT.RESTART) THEN
   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      !CALL UPDATE_GLOBAL_OUTPUTS(T,DT,NM)
      CALL DUMP_MESH_OUTPUTS(T,DT,NM)
   ENDDO
ENDIF

! If there are zones and HVAC pass PSUM

!IF (HVAC_SOLVE .AND. N_ZONE>0) CALL EXCHANGE_DIVERGENCE_INFO

! Make an initial dump of global output quantities

IF (.NOT.RESTART) THEN
   CALL UPDATE_CONTROLS(T,0._EB,CTRL_STOP_STATUS,.TRUE.)
   CALL DUMP_GLOBAL_OUTPUTS
ENDIF

! Check for changes in VENT or OBSTruction control and device status at t=T_BEGIN

IF (.NOT.RESTART) THEN
   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      CALL OPEN_AND_CLOSE(T,NM)
   ENDDO
ENDIF

! Write out character strings to .smv file

CALL WRITE_STRINGS

! Check for evacuation initialization stop

IF (ANY(EVACUATION_ONLY)) THEN
   CALL STOP_CHECK(1)
   IF (.NOT.RESTART) ICYC = -EVAC_TIME_ITERATIONS
END IF

! Sprinkler piping calculation

!DO CNT=1,N_DEVC
!   IF (DEVICE(CNT)%PROP_INDEX > 0 .AND.  DEVICE(CNT)%CURRENT_STATE) THEN
!      IF (PROPERTY(DEVICE(CNT)%PROP_INDEX)%PART_INDEX > 0) !DEVC_PIPE_OPERATING(DEVICE(CNT)%PIPE_INDEX) = &
!         DEVC_PIPE_OPERATING(DEVICE(CNT)%PIPE_INDEX) + 1
!   ENDIF
!ENDDO

! Start the clock for time stepping

WALL_CLOCK_START_ITERATIONS = WALL_CLOCK_TIME()
T_USED = 0._EB
T_USED(1) = SECOND()

! Level Set model for firespread in vegetation (currently uses constant wind: does not need CFD computations).

!IF (VEG_LEVEL_SET_UNCOUPLED .OR. VEG_LEVEL_SET_COUPLED) CALL INITIALIZE_LEVEL_SET_FIRESPREAD(1)
!IF (VEG_LEVEL_SET_UNCOUPLED) THEN
!   CALL LEVEL_SET_FIRESPREAD(T,DT,1)
!   STOP_STATUS = LEVELSET_STOP
!   CALL STOP_CHECK(1)
!ENDIF

! This ends the initialization part of the program

INITIALIZATION_PHASE = .FALSE.

!***********************************************************************************************************************************
!                                                   MAIN TIMESTEPPING LOOP
!***********************************************************************************************************************************

MAIN_LOOP: DO

   ICYC  = ICYC + 1   ! Time step iterations

   ! Do not print out general diagnostics into .out file every time step

   DIAGNOSTICS = .FALSE.
   EXCHANGE_EVACUATION = .FALSE.

   ! Check for program stops

   INQUIRE(FILE=FN_STOP,EXIST=EX)
   IF (EX .AND. ICYC>=STOP_AT_ITER) THEN
      STOP_STATUS = USER_STOP
      DIAGNOSTICS = .TRUE.
   ENDIF

   ! Check to see if the time step can be increased

   IF (ALL(CHANGE_TIME_STEP_INDEX==1)) DT = MINVAL(DT_NEW,MASK=.NOT.EVACUATION_ONLY)

   ! Clip final time step

   IF ((T+DT)>T_END) DT = MAX(T_END-T,TWO_EPSILON_EB)

   ! Determine when to dump out diagnostics to the .out file

   LO10 = LOG10(REAL(MAX(1,ABS(ICYC)),EB))
   IF (MOD(ICYC,10**LO10)==0 .OR. MOD(ICYC,100)==0 .OR. (T+DT)>=T_END) DIAGNOSTICS = .TRUE.

   ! If evacuation, set up special time iteration parameters

   IF (ANY(EVACUATION_ONLY)) CALL EVAC_MAIN_LOOP

   !================================================================================================================================
   !                                           Start of Predictor part of time step
   !================================================================================================================================

   PREDICTOR = .TRUE.
   CORRECTOR = .FALSE.

   ! Diagnostic timing calls and initialize energy budget array, Q_DOT

   !DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   !   Q_DOT(:,NM) = 0._EB
   !ENDDO

   ! Begin the finite differencing of the PREDICTOR step

   !COMPUTE_FINITE_DIFFERENCES_1: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   !   IF (EVACUATION_SKIP(NM)) CYCLE COMPUTE_FINITE_DIFFERENCES_1
   !   CALL INSERT_PARTICLES(T,NM)
   !   CALL COMPUTE_VELOCITY_FLUX(T,DT,NM,1)
   !   CALL MASS_FINITE_DIFFERENCES(NM)
   !ENDDO COMPUTE_FINITE_DIFFERENCES_1

   ! Estimate quantities at next time step, and decrease/increase time step if necessary based on CFL condition

   FIRST_PASS = .TRUE.

   CHANGE_TIME_STEP_LOOP: DO

      ! Predict species mass fractions at the next time step.

      !COMPUTE_DENSITY_LOOP: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      !   IF (EVACUATION_SKIP(NM)) CYCLE COMPUTE_DENSITY_LOOP
      !   CALL DENSITY(T,DT,NM)
      !ENDDO COMPUTE_DENSITY_LOOP

      ! Exchange species mass fractions at interpolated boundaries.

      CALL MESH_EXCHANGE(1)

      ! Calculate convective and diffusive terms of the velocity equation.

      !COMPUTE_DIVERGENCE_LOOP: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      !   IF (EVACUATION_SKIP(NM)) CYCLE COMPUTE_DIVERGENCE_LOOP
      !   !IF (N_FACE>0 .AND. FIRST_PASS) CALL INIT_IBM(T,NM)
      !   CALL COMPUTE_VELOCITY_FLUX(T,DT,NM,2)
      !   IF (FIRST_PASS .AND. HVAC_SOLVE) CALL HVAC_BC_IN(NM)
      !ENDDO COMPUTE_DIVERGENCE_LOOP

      ! HVAC solver

      !IF (HVAC_SOLVE) THEN
      !   IF (FIRST_PASS .AND. N_MPI_PROCESSES>1) CALL EXCHANGE_HVAC_BC
      !   IF (PROCESS(1)==MYID) CALL HVAC_CALC(T,DT,FIRST_PASS)
      !   IF (N_MPI_PROCESSES>1) CALL EXCHANGE_HVAC_SOLUTION
      !ENDIF

      ! Boundary conditions for temperature, species, and density. Start divergence calculation.

      !COMPUTE_WALL_BC_LOOP_A: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      !   IF (EVACUATION_SKIP(NM)) CYCLE COMPUTE_WALL_BC_LOOP_A
      !   CALL UPDATE_PARTICLES(T,DT,NM)
      !   CALL WALL_BC(T,DT,NM)
      !   CALL PARTICLE_MOMENTUM_TRANSFER(NM)
      !   CALL DIVERGENCE_PART_1(T,DT,NM)
      !ENDDO COMPUTE_WALL_BC_LOOP_A

      ! If there are pressure ZONEs, exchange integrated quantities mesh to mesh for use in the divergence calculation

      !IF (N_ZONE>0) CALL EXCHANGE_DIVERGENCE_INFO

      ! Finish the divergence calculation

      !FINISH_DIVERGENCE_LOOP: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      !   IF (EVACUATION_SKIP(NM)) CYCLE FINISH_DIVERGENCE_LOOP
      !   CALL DIVERGENCE_PART_2(DT,NM)
      !ENDDO FINISH_DIVERGENCE_LOOP

      ! Solve for the pressure at the current time step

      !CALL PRESSURE_ITERATION_SCHEME
      !CALL EVAC_PRESSURE_ITERATION_SCHEME

      ! Predict the velocity components at the next time step

      CHANGE_TIME_STEP_INDEX = 0
      DT_NEW = DT

      PREDICT_VELOCITY_LOOP: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
         IF (.NOT.ALL(EVACUATION_ONLY).AND.EVACUATION_ONLY(NM).AND.ICYC>0) CHANGE_TIME_STEP_INDEX(NM)=1
         IF (EVACUATION_SKIP(NM)) CYCLE PREDICT_VELOCITY_LOOP
         !CALL VELOCITY_PREDICTOR(T+DT,DT,DT_NEW,NM)
      ENDDO PREDICT_VELOCITY_LOOP

      ! Check if there is a numerical instability after updating the velocity field. If there is, exit this loop, finish the time
      ! step, and stop the code.

      CALL STOP_CHECK(0)

      IF (STOP_STATUS==INSTABILITY_STOP) THEN
         DIAGNOSTICS = .TRUE.
         EXIT CHANGE_TIME_STEP_LOOP
      ENDIF

      ! Exchange CHANGE_TIME_STEP_INDEX to determine if the time step needs to be decreased (-1) or increased (1). If any mesh
      ! needs to decrease, or all need to increase, exchange the array of new time step values, DT_NEW.

      IF (N_MPI_PROCESSES>1) THEN
         TNOW = SECOND()
         CALL MPI_ALLGATHERV(MPI_IN_PLACE,COUNTS(MYID),MPI_INTEGER,CHANGE_TIME_STEP_INDEX,COUNTS,DISPLS,&
                             MPI_INTEGER,MPI_COMM_WORLD,IERR)
         IF (ANY(CHANGE_TIME_STEP_INDEX==-1) .OR. ALL(CHANGE_TIME_STEP_INDEX==1)) &
            CALL MPI_ALLGATHERV(MPI_IN_PLACE,COUNTS(MYID),MPI_DOUBLE_PRECISION,DT_NEW,COUNTS,DISPLS, &
                                MPI_DOUBLE_PRECISION,MPI_COMM_WORLD,IERR)
         T_USED(11) = T_USED(11) + SECOND() - TNOW
      ENDIF

      IF (ANY(CHANGE_TIME_STEP_INDEX==-1)) THEN  ! If the time step was reduced, CYCLE CHANGE_TIME_STEP_LOOP
         DT = MINVAL(DT_NEW,MASK=.NOT.EVACUATION_ONLY)
         FIRST_PASS = .FALSE.
      ELSE  ! exit the loop and if the time step is to be increased, this will occur at the next time step.
         EXIT CHANGE_TIME_STEP_LOOP
      ENDIF

   ENDDO CHANGE_TIME_STEP_LOOP

   ! Exchange velocity and pressures at interpolated boundaries

   CALL MESH_EXCHANGE(3)

   ! Force normal components of velocity to match at interpolated boundaries

   !DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   !   IF (EVACUATION_SKIP(NM)) CYCLE
   !   CALL MATCH_VELOCITY(NM)
   !ENDDO

   ! Apply tangential velocity boundary conditions

   !VELOCITY_BC_LOOP: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   !   IF (EVACUATION_SKIP(NM)) CYCLE VELOCITY_BC_LOOP
   !   IF (SYNTHETIC_EDDY_METHOD) CALL SYNTHETIC_TURBULENCE(DT,T,NM)
   !   CALL VELOCITY_BC(T,NM)
   !ENDDO VELOCITY_BC_LOOP

   ! Advance the time to start the CORRECTOR step

   T = T + DT

   !================================================================================================================================
   !                                           Start of Corrector part of time step
   !================================================================================================================================

   CORRECTOR = .TRUE.
   PREDICTOR = .FALSE.

   ! Finite differences for mass and momentum equations for the second half of the time step

   !COMPUTE_FINITE_DIFFERENCES_2: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   !   CALL OPEN_AND_CLOSE(T,NM)
   !   IF (EVACUATION_SKIP(NM)) CYCLE COMPUTE_FINITE_DIFFERENCES_2
   !   CALL COMPUTE_VELOCITY_FLUX(T,DT,NM,1)
   !   CALL MASS_FINITE_DIFFERENCES(NM)
   !   CALL DENSITY(T,DT,NM)
   !ENDDO COMPUTE_FINITE_DIFFERENCES_2

   ! Exchange species mass fractions.

   CALL MESH_EXCHANGE(4)

   ! Apply mass and species boundary conditions, update radiation, particles, and re-compute divergence

   !COMPUTE_DIVERGENCE_2: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   !   IF (EVACUATION_SKIP(NM)) CYCLE COMPUTE_DIVERGENCE_2
   !   CALL COMPUTE_VELOCITY_FLUX(T,DT,NM,2)
   !   IF (AGGLOMERATION .AND. AGGLOMERATION_INDEX>0) CALL CALC_AGGLOMERATION(DT,NM)
   !   IF (N_REACTIONS > 0) CALL COMBUSTION(T,DT,NM)
   !ENDDO COMPUTE_DIVERGENCE_2

   !IF (HVAC_SOLVE) CALL HVAC_CALC(T,DT,.TRUE.)

   !COMPUTE_WALL_BC_2A: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   !   IF (EVACUATION_SKIP(NM)) CYCLE COMPUTE_WALL_BC_2A
   !   CALL UPDATE_PARTICLES(T,DT,NM)
   !   CALL WALL_BC(T,DT,NM)
   !   CALL PARTICLE_MOMENTUM_TRANSFER(NM)
   !   IF (WFDS_BNDRYFUEL) THEN
   !      CALL BNDRY_VEG_MASS_ENERGY_TRANSFER(T,DT,NM)
   !      IF (VEG_LEVEL_SET_COUPLED) CALL LEVEL_SET_FIRESPREAD(T,DT,1)
   !   ENDIF
   !ENDDO COMPUTE_WALL_BC_2A

   !DO ITER=1,RADIATION_ITERATIONS
   !   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   !      IF (EVACUATION_SKIP(NM)) CYCLE
   !      CALL COMPUTE_RADIATION(T,NM,ITER)
   !   ENDDO
   !   IF (RADIATION_ITERATIONS>1) THEN  ! Only do an MPI exchange of radiation intensity if multiple iterations are requested.
   !      DO ANG_INC_COUNTER=1,ANGLE_INCREMENT
   !         CALL MESH_EXCHANGE(2)
   !         IF (ICYC>1) EXIT
   !      ENDDO
   !   ENDIF
   !ENDDO

   ! Start the computation of the divergence term.

   !DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   !   IF (EVACUATION_SKIP(NM)) CYCLE
   !   CALL DIVERGENCE_PART_1(T,DT,NM)
   !ENDDO

   ! In most LES fire cases, a correction to the source term in the radiative transport equation is needed.

   !IF (RTE_SOURCE_CORRECTION) CALL CALCULATE_RTE_SOURCE_CORRECTION_FACTOR

   ! Exchange global pressure zone information

   !IF (N_ZONE>0) CALL EXCHANGE_DIVERGENCE_INFO

   ! Finish computing the divergence

   !FINISH_DIVERGENCE_LOOP_2: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   !   IF (EVACUATION_SKIP(NM)) CYCLE FINISH_DIVERGENCE_LOOP_2
   !   CALL DIVERGENCE_PART_2(DT,NM)
   !ENDDO FINISH_DIVERGENCE_LOOP_2

   ! Solve the pressure equation.

   !CALL PRESSURE_ITERATION_SCHEME
   !CALL EVAC_PRESSURE_ITERATION_SCHEME

   ! Set up the last big exchange of info.

   CALL EVAC_MESH_EXCHANGE(T_EVAC,T_EVAC_SAVE,I_EVAC,ICYC,EXCHANGE_EVACUATION,0)

   ! Update the  velocity.

   !CORRECT_VELOCITY_LOOP: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   !   IF (EVACUATION_SKIP(NM)) CYCLE CORRECT_VELOCITY_LOOP
   !   CALL VELOCITY_CORRECTOR(T,DT,NM)
   !   IF (DIAGNOSTICS .AND. .NOT.EVACUATION_ONLY(NM)) CALL CHECK_DIVERGENCE(NM)
   !ENDDO CORRECT_VELOCITY_LOOP

   ! Exchange the number of particles sent from mesh to mesh

   CALL MESH_EXCHANGE(7)

   ! Exchange velocity, pressure, particles at interpolated boundaries

   CALL POST_RECEIVES(6)
   CALL MESH_EXCHANGE(6)

   ! Exchange radiation intensity at interpolated boundaries if only one iteration of the solver is requested.

   !IF (RADIATION_ITERATIONS==1) THEN
   !   DO ANG_INC_COUNTER=1,ANGLE_INCREMENT
   !      CALL MESH_EXCHANGE(2)
   !      IF (ICYC>1) EXIT
   !   ENDDO
   !ENDIF

   ! Force normal components of velocity to match at interpolated boundaries

   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (EVACUATION_SKIP(NM)) CYCLE
      !CALL MATCH_VELOCITY(NM)
   ENDDO

   ! Apply velocity boundary conditions, and update values of HRR, DEVC, etc.

   VELOCITY_BC_LOOP_2: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (EVACUATION_SKIP(NM)) CYCLE VELOCITY_BC_LOOP_2
      !CALL VELOCITY_BC(T,NM)
      !CALL UPDATE_GLOBAL_OUTPUTS(T,DT,NM)
   ENDDO VELOCITY_BC_LOOP_2

   ! Check for dumping end of timestep outputs

   CALL_UPDATE_CONTROLS = .FALSE.

   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (EVACUATION_SKIP(NM)) CYCLE
      IF (.NOT. CALL_UPDATE_CONTROLS) THEN
         CALL UPDATE_CONTROLS(T,DT,CTRL_STOP_STATUS,.FALSE.)
         IF (CTRL_STOP_STATUS) STOP_STATUS = CTRL_STOP
      ENDIF
      CALL_UPDATE_CONTROLS = .TRUE.
      CALL DUMP_MESH_OUTPUTS(T,DT,NM)
   ENDDO

   ! Dump outputs such as HRR, DEVC, etc.

   CALL DUMP_GLOBAL_OUTPUTS

   ! Exchange EVAC information among meshes

   CALL EVAC_EXCHANGE

   ! Dump out diagnostics

   !IF (DIAGNOSTICS) THEN
   !   CALL WRITE_STRINGS
   !   IF (.NOT.SUPPRESS_DIAGNOSTICS) CALL EXCHANGE_DIAGNOSTICS
   !   IF (MYID==0) CALL WRITE_DIAGNOSTICS(T,DT)
   !ENDIF

   ! Flush output file buffers

   IF (T>=FLUSH_CLOCK .AND. FLUSH_FILE_BUFFERS) THEN
      IF (MYID==0) CALL FLUSH_GLOBAL_BUFFERS
      IF (MYID==MAX(0,EVAC_PROCESS)) CALL FLUSH_EVACUATION_BUFFERS
      DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
         IF (EVACUATION_ONLY(NM)) CYCLE
         CALL FLUSH_LOCAL_BUFFERS(NM)
      ENDDO
      FLUSH_CLOCK = FLUSH_CLOCK + DT_FLUSH
   ENDIF

   ! Dump a restart file if necessary

   IF ( (T>=RESTART_CLOCK .OR. STOP_STATUS==USER_STOP) .AND. (T>=T_END .OR. RADIATION_COMPLETED) ) THEN
      DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
         IF (EVACUATION_SKIP(NM)) CYCLE
         !CALL DUMP_RESTART(T,DT,NM)
      ENDDO
      RESTART_CLOCK = RESTART_CLOCK + DT_RESTART
   ENDIF

   ! Check for abnormal run stop

   CALL STOP_CHECK(1)  ! The argument 1 means that FDS will end unless there is logic associated with the STOP_STATUS

   ! Stop the run normally

   IF (T>=T_END .AND. ICYC>0) EXIT MAIN_LOOP

ENDDO MAIN_LOOP

!***********************************************************************************************************************************
!                                                     END OF TIME STEPPING LOOP
!***********************************************************************************************************************************

! Finish unstructured geometry

IF (N_FACE>0) THEN
   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      !CALL INIT_IBM(T,NM)
   ENDDO
ENDIF

! Stop the calculation

CALL END_FDS

! This is the end of program. Supporting routines are listed below.

CONTAINS


SUBROUTINE CHECK_MPI

IF (.NOT.USE_MPI) RETURN

! Check the threading support level

IF (USE_MPI .AND. PROVIDED<REQUIRED) THEN
   IF (MYID==0) WRITE(LU_ERR,*) "WARNING:  This MPI implementation provides insufficient threading support."
   !$ CALL OMP_SET_NUM_THREADS(1)
ENDIF

END SUBROUTINE CHECK_MPI


SUBROUTINE MPI_INITIALIZATION_CHORES(TASK_NUMBER)

INTEGER, INTENT(IN) :: TASK_NUMBER
INTEGER, ALLOCATABLE, DIMENSION(:) :: REQ0
INTEGER :: N_REQ0

SELECT CASE(TASK_NUMBER)

   CASE(1)

      ! Set up send and receive buffer counts and displacements

      ALLOCATE(REAL_BUFFER_1(NMESHES))
      ALLOCATE(REAL_BUFFER_5(0:MINT_SPECIES,NMESHES))
      ALLOCATE(REAL_BUFFER_6(N_DUCTNODES,NMESHES))
      ALLOCATE(REAL_BUFFER_7(N_DUCTNODES,N_TOTAL_SCALARS,NMESHES))
      ALLOCATE(REAL_BUFFER_8(0:N_ZONE,0:N_ZONE,NMESHES))
      ALLOCATE(REAL_BUFFER_9(0:N_ZONE,0:N_ZONE,N_TOTAL_SCALARS,NMESHES))
      ALLOCATE(REAL_BUFFER_10(N_DUCTS,NMESHES))
      ALLOCATE(REAL_BUFFER_11(N_Q_DOT,NMESHES))
      ALLOCATE(REAL_BUFFER_12(N_M_DOT,NMESHES))
      ALLOCATE(INTEGER_BUFFER_1(NMESHES))
      ALLOCATE(INTEGER_BUFFER_2(N_DUCTNODES,NMESHES))
      ALLOCATE(INTEGER_BUFFER_3(3,NMESHES))
      ALLOCATE(LOGICAL_BUFFER_1(NMESHES))

      ALLOCATE(COUNTS(0:N_MPI_PROCESSES-1))
      ALLOCATE(COUNTS2D(0:N_MPI_PROCESSES-1))
      ALLOCATE(COUNTS_HVAC(0:N_MPI_PROCESSES-1))
      ALLOCATE(COUNTS_HVAC_SPECIES(0:N_MPI_PROCESSES-1))
      ALLOCATE(COUNTS_MASS(0:N_MPI_PROCESSES-1))
      ALLOCATE(COUNTS_Q_DOT(0:N_MPI_PROCESSES-1))
      ALLOCATE(COUNTS_M_DOT(0:N_MPI_PROCESSES-1))
      ALLOCATE(COUNTS_ERROR(0:N_MPI_PROCESSES-1))

      ALLOCATE(DISPLS(0:N_MPI_PROCESSES-1))
      ALLOCATE(DISPLS2D(0:N_MPI_PROCESSES-1))
      ALLOCATE(DISPLS_MASS(0:N_MPI_PROCESSES-1))
      ALLOCATE(DISPLS_HVAC(0:N_MPI_PROCESSES-1))
      ALLOCATE(DISPLS_HVAC_SPECIES(0:N_MPI_PROCESSES-1))
      ALLOCATE(DISPLS_Q_DOT(0:N_MPI_PROCESSES-1))
      ALLOCATE(DISPLS_M_DOT(0:N_MPI_PROCESSES-1))
      ALLOCATE(DISPLS_ERROR(0:N_MPI_PROCESSES-1))

      COUNTS    = 0
      DO N=0,N_MPI_PROCESSES-1
         DO NM=1,NMESHES
            IF (PROCESS(NM)==N) COUNTS(N)    = COUNTS(N)    + 1
         ENDDO
      ENDDO
      DISPLS(0)    = 0
      DO N=1,N_MPI_PROCESSES-1
         DISPLS(N)    = COUNTS(N-1)    + DISPLS(N-1)
      ENDDO
      COUNTS2D      = COUNTS*NMESHES
      DISPLS2D      = DISPLS*NMESHES
      COUNTS_HVAC   = COUNTS*N_DUCTNODES
      COUNTS_HVAC_SPECIES   = COUNTS*N_DUCTNODES*N_TOTAL_SCALARS
      DISPLS_HVAC   = DISPLS*N_DUCTNODES
      DISPLS_HVAC_SPECIES   = DISPLS*N_DUCTNODES*N_TOTAL_SCALARS
      COUNTS_MASS   = COUNTS*(MINT_SPECIES+1)
      DISPLS_MASS   = DISPLS*(MINT_SPECIES+1)
      COUNTS_Q_DOT  = COUNTS*N_Q_DOT
      DISPLS_Q_DOT  = DISPLS*N_Q_DOT
      COUNTS_M_DOT  = COUNTS*N_M_DOT
      DISPLS_M_DOT  = DISPLS*N_M_DOT
      COUNTS_ERROR  = COUNTS*3
      DISPLS_ERROR  = DISPLS*3

   CASE(2)

      ! Allocate TIME arrays

      ALLOCATE(DT_NEW(NMESHES),STAT=IZERO) ;  CALL ChkMemErr('MAIN','DT_NEW',IZERO) ; DT_NEW = DT

      ! Set up dummy arrays to hold various arrays that must be exchanged among meshes

      ALLOCATE(TI_LOC(N_DEVC),STAT=IZERO)
      CALL ChkMemErr('MAIN','TI_LOC',IZERO)
      ALLOCATE(TI_GLB(N_DEVC),STAT=IZERO)
      CALL ChkMemErr('MAIN','TI_GLB',IZERO)
      ALLOCATE(STATE_GLB(2*N_DEVC),STAT=IZERO)
      CALL ChkMemErr('MAIN','STATE_GLB',IZERO)
      ALLOCATE(STATE_LOC(2*N_DEVC),STAT=IZERO)
      CALL ChkMemErr('MAIN','STATE_LOC',IZERO)
      ALLOCATE(TC_GLB(3*N_DEVC),STAT=IZERO)
      CALL ChkMemErr('MAIN','TC_GLB',IZERO)
      ALLOCATE(TC_LOC(3*N_DEVC),STAT=IZERO)
      CALL ChkMemErr('MAIN','TC_LOC',IZERO)

      ! Allocate a few arrays needed to exchange divergence and pressure info among meshes

      IF (N_ZONE > 0) THEN
         ALLOCATE(DSUM_ALL(N_ZONE),STAT=IZERO)
         ALLOCATE(PSUM_ALL(N_ZONE),STAT=IZERO)
         ALLOCATE(USUM_ALL(N_ZONE),STAT=IZERO)
         ALLOCATE(CONNECTED_ZONES_GLOBAL(0:N_ZONE,0:N_ZONE),STAT=IZERO)
         ALLOCATE(DSUM_ALL_LOCAL(N_ZONE),STAT=IZERO)
         ALLOCATE(PSUM_ALL_LOCAL(N_ZONE),STAT=IZERO)
         ALLOCATE(USUM_ALL_LOCAL(N_ZONE),STAT=IZERO)
         ALLOCATE(CONNECTED_ZONES_LOCAL(0:N_ZONE,0:N_ZONE),STAT=IZERO)
      ENDIF

   CASE(3)

      ! Allocate "request" arrays to keep track of MPI communications

      ALLOCATE(REQ(N_COMMUNICATIONS*40))
      ALLOCATE(REQ1(N_COMMUNICATIONS*4))
      ALLOCATE(REQ2(N_COMMUNICATIONS*4))
      ALLOCATE(REQ3(N_COMMUNICATIONS*4))
      ALLOCATE(REQ4(N_COMMUNICATIONS*4))
      ALLOCATE(REQ5(N_COMMUNICATIONS*4))
      ALLOCATE(REQ6(N_COMMUNICATIONS*4))
      ALLOCATE(REQ7(N_COMMUNICATIONS*4))
      ALLOCATE(REQ8(N_COMMUNICATIONS*4))
      ALLOCATE(REQ9(N_COMMUNICATIONS*4))

      REQ = MPI_REQUEST_NULL
      REQ1 = MPI_REQUEST_NULL
      REQ2 = MPI_REQUEST_NULL
      REQ3 = MPI_REQUEST_NULL
      REQ4 = MPI_REQUEST_NULL
      REQ5 = MPI_REQUEST_NULL
      REQ6 = MPI_REQUEST_NULL
      REQ7 = MPI_REQUEST_NULL
      REQ8 = MPI_REQUEST_NULL
      REQ9 = MPI_REQUEST_NULL

   CASE(4)

      ! Allow all processes to start at the same time

      CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)

      IF (N_MPI_PROCESSES>1) ALLOCATE(REQ0(NMESHES**2))

      N_REQ0 = 0

      DO NM=1,NMESHES
         IF (EVACUATION_ONLY(NM)) CYCLE
         DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
            IF (EVACUATION_ONLY(NOM)) CYCLE
            IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MYID .AND. MESHES(NOM)%CONNECTED_MESH(NM)) THEN
               M2 => MESHES(NOM)%OMESH(NM)
               N_REQ0 = N_REQ0 + 1
               CALL MPI_IRECV(M2%INTEGER_RECV_BUFFER(1),7,MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
            ENDIF
         ENDDO
      ENDDO

      CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)

      ! DEFINITION NIC_S:   MESHES(NOM)%OMESH(NM)%NIC_S   = MESHES(NM)%OMESH(NOM)%NIC_R
      ! DEFINITION I_MIN_S: MESHES(NOM)%OMESH(NM)%I_MIN_S = MESHES(NM)%OMESH(NOM)%I_MIN_R
      ! DEFINITION I_MAX_S: MESHES(NOM)%OMESH(NM)%I_MAX_S = MESHES(NM)%OMESH(NOM)%I_MAX_R
      ! DEFINITION J_MIN_S: MESHES(NOM)%OMESH(NM)%J_MIN_S = MESHES(NM)%OMESH(NOM)%J_MIN_R
      ! DEFINITION J_MAX_S: MESHES(NOM)%OMESH(NM)%J_MAX_S = MESHES(NM)%OMESH(NOM)%J_MAX_R
      ! DEFINITION K_MIN_S: MESHES(NOM)%OMESH(NM)%K_MIN_S = MESHES(NM)%OMESH(NOM)%K_MIN_R
      ! DEFINITION K_MAX_S: MESHES(NOM)%OMESH(NM)%K_MAX_S = MESHES(NM)%OMESH(NOM)%K_MAX_R

      DO NM=1,NMESHES
         CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)  ! This call orders the sending mesh by mesh.
         IF (PROCESS(NM)/=MYID) CYCLE
         IF (EVACUATION_ONLY(NM)) CYCLE
         DO NOM=1,NMESHES
            IF (EVACUATION_ONLY(NOM)) CYCLE
            IF (.NOT.MESHES(NM)%CONNECTED_MESH(NOM)) CYCLE
            M3 => MESHES(NM)%OMESH(NOM)
            IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NOM)/=MYID .AND. MESHES(NM)%CONNECTED_MESH(NOM)) THEN
               M3%INTEGER_SEND_BUFFER(1) = M3%I_MIN_R
               M3%INTEGER_SEND_BUFFER(2) = M3%I_MAX_R
               M3%INTEGER_SEND_BUFFER(3) = M3%J_MIN_R
               M3%INTEGER_SEND_BUFFER(4) = M3%J_MAX_R
               M3%INTEGER_SEND_BUFFER(5) = M3%K_MIN_R
               M3%INTEGER_SEND_BUFFER(6) = M3%K_MAX_R
               M3%INTEGER_SEND_BUFFER(7) = M3%NIC_R
               N_REQ0 = N_REQ0 + 1
               CALL MPI_ISEND(M3%INTEGER_SEND_BUFFER(1),7,MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
            ELSE
               M2 => MESHES(NOM)%OMESH(NM)
               M2%I_MIN_S = M3%I_MIN_R
               M2%I_MAX_S = M3%I_MAX_R
               M2%J_MIN_S = M3%J_MIN_R
               M2%J_MAX_S = M3%J_MAX_R
               M2%K_MIN_S = M3%K_MIN_R
               M2%K_MAX_S = M3%K_MAX_R
               M2%NIC_S   = M3%NIC_R
            ENDIF
         ENDDO
      ENDDO

      IF (N_MPI_PROCESSES>1) THEN
         CALL MPI_WAITALL(N_REQ0,REQ0(1:N_REQ0),MPI_STATUSES_IGNORE,IERR)
         CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
      ENDIF

      DO NM=1,NMESHES
         IF (EVACUATION_ONLY(NM)) CYCLE
         DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
            IF (EVACUATION_ONLY(NOM)) CYCLE
            IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MYID .AND. MESHES(NOM)%CONNECTED_MESH(NM)) THEN
               M2 => MESHES(NOM)%OMESH(NM)
               M2%I_MIN_S = M2%INTEGER_RECV_BUFFER(1)
               M2%I_MAX_S = M2%INTEGER_RECV_BUFFER(2)
               M2%J_MIN_S = M2%INTEGER_RECV_BUFFER(3)
               M2%J_MAX_S = M2%INTEGER_RECV_BUFFER(4)
               M2%K_MIN_S = M2%INTEGER_RECV_BUFFER(5)
               M2%K_MAX_S = M2%INTEGER_RECV_BUFFER(6)
               M2%NIC_S   = M2%INTEGER_RECV_BUFFER(7)
            ENDIF
         ENDDO
      ENDDO

      IF (N_MPI_PROCESSES>1) THEN
         DEALLOCATE(REQ0)
         CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
      ENDIF

      ! Exchange IIO_S, etc., the indices of interpolated cells
      ! DEFINITION IIO_S: MESHES(NOM)%OMESH(NM)%IIO_S = MESHES(NM)%OMESH(NOM)%IIO_R
      ! DEFINITION JJO_S: MESHES(NOM)%OMESH(NM)%JJO_S = MESHES(NM)%OMESH(NOM)%JJO_R
      ! DEFINITION KKO_S: MESHES(NOM)%OMESH(NM)%KKO_S = MESHES(NM)%OMESH(NOM)%KKO_R
      ! DEFINITION IOR_S: MESHES(NOM)%OMESH(NM)%IOR_S = MESHES(NM)%OMESH(NOM)%IOR_R

      DO NM=1,NMESHES
         IF (EVACUATION_ONLY(NM)) CYCLE
         DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
            IF (EVACUATION_ONLY(NOM)) CYCLE
            IF (MESHES(NOM)%OMESH(NM)%NIC_S>0) THEN
               M2 => MESHES(NOM)%OMESH(NM)
               ALLOCATE(M2%IIO_S(M2%NIC_S))
               ALLOCATE(M2%JJO_S(M2%NIC_S))
               ALLOCATE(M2%KKO_S(M2%NIC_S))
               ALLOCATE(M2%IOR_S(M2%NIC_S))
            ENDIF
         ENDDO
      ENDDO

      N_REQ = 0

      DO NM=1,NMESHES
         IF (EVACUATION_ONLY(NM)) CYCLE
         DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
            IF (EVACUATION_ONLY(NOM)) CYCLE
            M2 => MESHES(NOM)%OMESH(NM)
            IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MYID .AND. M2%NIC_S>0) THEN
               CALL MPI_IRECV(M2%IIO_S(1),M2%NIC_S,MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ(N_REQ+1),IERR)
               CALL MPI_IRECV(M2%JJO_S(1),M2%NIC_S,MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ(N_REQ+2),IERR)
               CALL MPI_IRECV(M2%KKO_S(1),M2%NIC_S,MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ(N_REQ+3),IERR)
               CALL MPI_IRECV(M2%IOR_S(1),M2%NIC_S,MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ(N_REQ+4),IERR)
               N_REQ = N_REQ + 4
            ENDIF
         ENDDO
      ENDDO

      DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
         IF (EVACUATION_ONLY(NM)) CYCLE
         DO NOM=1,NMESHES
            IF (EVACUATION_ONLY(NOM)) CYCLE
            M3 => MESHES(NM)%OMESH(NOM)
            IF (M3%NIC_R<1) CYCLE
            IF (PROCESS(NOM)/=MYID) THEN
               CALL MPI_ISEND(M3%IIO_R(1),M3%NIC_R,MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ(N_REQ+1),IERR)
               CALL MPI_ISEND(M3%JJO_R(1),M3%NIC_R,MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ(N_REQ+2),IERR)
               CALL MPI_ISEND(M3%KKO_R(1),M3%NIC_R,MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ(N_REQ+3),IERR)
               CALL MPI_ISEND(M3%IOR_R(1),M3%NIC_R,MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ(N_REQ+4),IERR)
               N_REQ = N_REQ + 4
            ELSE
               M2 => MESHES(NOM)%OMESH(NM)
               M2%IIO_S = M3%IIO_R
               M2%JJO_S = M3%JJO_R
               M2%KKO_S = M3%KKO_R
               M2%IOR_S = M3%IOR_R
            ENDIF
         ENDDO
      ENDDO

      IF (N_REQ>0 .AND. N_MPI_PROCESSES>1) CALL MPI_WAITALL(N_REQ,REQ(1:N_REQ),MPI_STATUSES_IGNORE,IERR)

END SELECT

CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)

IF (MYID==0 .AND. VERBOSE) WRITE(LU_ERR,'(A,I2)') ' Completed Initialization Step ',TASK_NUMBER

END SUBROUTINE MPI_INITIALIZATION_CHORES


SUBROUTINE STOP_CHECK(END_CODE)

INTEGER, INTENT(IN) :: END_CODE
REAL(EB) :: TNOW

! Make sure that all MPI processes have the same STOP_STATUS

IF (N_MPI_PROCESSES>1) THEN
   TNOW = SECOND()
   CALL MPI_ALLREDUCE(MPI_IN_PLACE,STOP_STATUS,1,MPI_INTEGER,MPI_MAX,MPI_COMM_WORLD,IERR)
   T_USED(11)=T_USED(11) + SECOND() - TNOW
ENDIF

SELECT CASE(STOP_STATUS)
   CASE(NO_STOP)
      RETURN
   CASE(USER_STOP)
      IF (STOP_AT_ITER==0.AND..NOT.RADIATION_COMPLETED) RETURN
END SELECT

IF (END_CODE==1) CALL END_FDS

END SUBROUTINE STOP_CHECK


SUBROUTINE END_FDS

! End the calculation gracefully, even if there is an error

CHARACTER(255) :: MESSAGE
LOGICAL :: OPN

CALL DUMP_CPU_TIME

IF (USE_MPI) THEN
   IF (VERBOSE) WRITE(LU_ERR,'(A,I6,A)') 'MPI process ',MYID,' has completed'
   CALL MPI_FINALIZE(IERR)
ENDIF

IF (MYID==0) THEN

   ! Print out device activation times to the .out file

   CALL TIMINGS
   !IF (PRES_METHOD == 'SCARC') CALL SCARC_TIMINGS

   ! Print out stop status to .err and .out files

   SELECT CASE(STOP_STATUS)
      CASE(NO_STOP)
         WRITE(MESSAGE,'(A)') 'STOP: FDS completed successfully'
         IF (STATUS_FILES) CLOSE(LU_NOTREADY,STATUS='DELETE')
      CASE(INSTABILITY_STOP)
         WRITE(MESSAGE,'(A)') 'STOP: Numerical Instability'
      CASE(USER_STOP)
         WRITE(MESSAGE,'(A)') 'STOP: FDS stopped by user'
      CASE(SETUP_STOP)
         WRITE(MESSAGE,'(A)') 'STOP: FDS was improperly set-up'
      CASE(SETUP_ONLY_STOP)
         WRITE(MESSAGE,'(A)') 'STOP: Set-up only'
      CASE(CTRL_STOP)
         WRITE(MESSAGE,'(A)') 'STOP: FDS was stopped by KILL control function'
      CASE(TGA_ANALYSIS_STOP)
         WRITE(MESSAGE,'(A)') 'STOP: TGA analysis only'
      CASE(LEVELSET_STOP)
         WRITE(MESSAGE,'(A)') 'STOP: Level set analysis only'
      CASE(REALIZABILITY_STOP)
         WRITE(MESSAGE,'(A)') 'STOP: Unrealizable mass density'
   END SELECT

   WRITE(LU_ERR,'(/A,A,A,A)') TRIM(MESSAGE),' (CHID: ',TRIM(CHID),')'
   INQUIRE(LU_OUTPUT,OPENED=OPN)
   IF (OPN) WRITE(LU_OUTPUT,'(/A,A,A,A)') TRIM(MESSAGE),' (CHID: ',TRIM(CHID),')'

ENDIF

STOP

END SUBROUTINE END_FDS



SUBROUTINE INITIALIZE_MESH_EXCHANGE_1(NM)

! Create arrays by which info is to exchanged across meshes

INTEGER :: IMIN,IMAX,JMIN,JMAX,KMIN,KMAX,NOM,IOR,IW,N,N_STORAGE_SLOTS,IIO,JJO,KKO,NIC_R,II,JJ,KK
INTEGER, INTENT(IN) :: NM
TYPE (MESH_TYPE), POINTER :: M2,M
TYPE (OMESH_TYPE), POINTER :: OM
TYPE (EXTERNAL_WALL_TYPE), POINTER :: EWC
TYPE (WALL_TYPE), POINTER :: WC
TYPE (LAGRANGIAN_PARTICLE_CLASS_TYPE), POINTER :: LPC
LOGICAL :: FOUND

M=>MESHES(NM)

NOT_EVACUATION_MESH_IF: IF (.NOT.EVACUATION_ONLY(NM)) THEN

ALLOCATE(MESHES(NM)%OMESH(NMESHES))

ALLOCATE(M%CONNECTED_MESH(NMESHES)) ; M%CONNECTED_MESH = .FALSE.
ALLOCATE(M%OMESH(NM)%BOUNDARY_TYPE(0:M%N_EXTERNAL_WALL_CELLS))
M%OMESH(NM)%BOUNDARY_TYPE(0) = 0
DO IW=1,M%N_EXTERNAL_WALL_CELLS
   M%OMESH(NM)%BOUNDARY_TYPE(IW) = M%WALL(IW)%BOUNDARY_TYPE
ENDDO

END IF NOT_EVACUATION_MESH_IF

OTHER_MESH_LOOP: DO NOM=1,NMESHES

   IF (EVACUATION_ONLY(NM)) THEN
      IF (EMESH_INDEX(NM)>0 .AND. .NOT.EVACUATION_ONLY(NOM)) N_COMMUNICATIONS = N_COMMUNICATIONS + 1
      CYCLE OTHER_MESH_LOOP
   ENDIF
   IF (EVACUATION_ONLY(NOM)) THEN
      IF (EMESH_INDEX(NOM)>0 .AND. .NOT.EVACUATION_ONLY(NM)) N_COMMUNICATIONS = N_COMMUNICATIONS + 1
      CYCLE OTHER_MESH_LOOP
   ENDIF

   OM => M%OMESH(NOM)
   M2 => MESHES(NOM)

   IMIN=0
   IMAX=M2%IBP1
   JMIN=0
   JMAX=M2%JBP1
   KMIN=0
   KMAX=M2%KBP1

   ! DEFINITION NIC_R: (Number of Interpolated Cells -- Receiving) Number of cells in mesh NOM that abut mesh NM.
   ! DEFINITION IIO_R: Array of length NIC_R of I indices of the abutting (outside) cells
   ! DEFINITION JJO_R: Array of length NIC_R of J indices of the abutting (outside) cells
   ! DEFINITION KKO_R: Array of length NIC_R of K indices of the abutting (outside) cells
   ! DEFINITION IOR_R: Array of length NIC_R of orientation of the external boundary cell
   ! DEFINITION NIC_MIN: For external wall cell IW of mesh NM, the indices of abutting cells start with NIC_MIN and end with NIC_MAX
   ! DEFINITION NIC_MAX: For external wall cell IW of mesh NM, the indices of abutting cells start with NIC_MIN and end with NIC_MAX

   OM%NIC_R = 0
   FOUND = .FALSE.

   SEARCH_LOOP: DO IW=1,M%N_EXTERNAL_WALL_CELLS

      EWC => M%EXTERNAL_WALL(IW)
      IF (EWC%NOM/=NOM) CYCLE SEARCH_LOOP
      WC => M%WALL(IW)
      II = WC%ONE_D%II
      JJ = WC%ONE_D%JJ
      KK = WC%ONE_D%KK
      EWC%NIC_MIN = OM%NIC_R + 1
      OM%NIC_R = OM%NIC_R + (EWC%IIO_MAX-EWC%IIO_MIN+1)*(EWC%JJO_MAX-EWC%JJO_MIN+1)*(EWC%KKO_MAX-EWC%KKO_MIN+1)
      EWC%NIC_MAX = OM%NIC_R
      FOUND = .TRUE.
      M%CONNECTED_MESH(NOM) = .TRUE.
      IOR = M%WALL(IW)%ONE_D%IOR
      SELECT CASE(IOR)
         CASE( 1)
            IMIN=MAX(IMIN,EWC%IIO_MIN-1)
         CASE(-1)
            IMAX=MIN(IMAX,EWC%IIO_MAX+1)
         CASE( 2)
            JMIN=MAX(JMIN,EWC%JJO_MIN-1)
         CASE(-2)
            JMAX=MIN(JMAX,EWC%JJO_MAX+1)
         CASE( 3)
            KMIN=MAX(KMIN,EWC%KKO_MIN-1)
         CASE(-3)
            KMAX=MIN(KMAX,EWC%KKO_MAX+1)
      END SELECT

      SELECT CASE(ABS(IOR))
         CASE(1)
            EWC%AREA_RATIO = M%DY(JJ)*M%DZ(KK)/((M2%Y(EWC%JJO_MAX)-M2%Y(EWC%JJO_MIN-1))*(M2%Z(EWC%KKO_MAX)-M2%Z(EWC%KKO_MIN-1)))
         CASE(2)
            EWC%AREA_RATIO = M%DX(II)*M%DZ(KK)/((M2%X(EWC%IIO_MAX)-M2%X(EWC%IIO_MIN-1))*(M2%Z(EWC%KKO_MAX)-M2%Z(EWC%KKO_MIN-1)))
         CASE(3)
            EWC%AREA_RATIO = M%DX(II)*M%DY(JJ)/((M2%X(EWC%IIO_MAX)-M2%X(EWC%IIO_MIN-1))*(M2%Y(EWC%JJO_MAX)-M2%Y(EWC%JJO_MIN-1)))
      END SELECT
   ENDDO SEARCH_LOOP

   ! Allocate arrays to hold indices of arrays for MPI exchanges

   IF (OM%NIC_R>0) THEN
      ALLOCATE(OM%IIO_R(OM%NIC_R))
      ALLOCATE(OM%JJO_R(OM%NIC_R))
      ALLOCATE(OM%KKO_R(OM%NIC_R))
      ALLOCATE(OM%IOR_R(OM%NIC_R))
      NIC_R = 0
      INDEX_LOOP: DO IW=1,M%N_EXTERNAL_WALL_CELLS
         EWC => M%EXTERNAL_WALL(IW)
         IF (EWC%NOM/=NOM) CYCLE INDEX_LOOP
         DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
            DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
               DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                  NIC_R = NIC_R + 1
                  IOR = M%WALL(IW)%ONE_D%IOR
                  OM%IIO_R(NIC_R) = IIO
                  OM%JJO_R(NIC_R) = JJO
                  OM%KKO_R(NIC_R) = KKO
                  OM%IOR_R(NIC_R) = IOR
               ENDDO
            ENDDO
         ENDDO
      ENDDO INDEX_LOOP
   ENDIF

   ! For PERIODIC boundaries with 1 or 2 meshes, we must revert to allocating whole copies of OMESH

   IF (IMIN>IMAX) THEN; IMIN=0; IMAX=M2%IBP1; ENDIF
   IF (JMIN>JMAX) THEN; JMIN=0; JMAX=M2%JBP1; ENDIF
   IF (KMIN>KMAX) THEN; KMIN=0; KMAX=M2%KBP1; ENDIF

   ! Embedded meshes. This is the case where mesh NOM is completely inside mesh NM. Mesh NM cannot "see" mesh NOM because mesh NOM
   ! is not connected at the external boundary of mesh NM. The variable CONNECTED_MESH is needed to save this information.

   IF ( NM/=NOM .AND. M2%XS>=M%XS .AND. M2%XF<=M%XF .AND. M2%YS>=M%YS .AND. M2%YF<=M%YF .AND. M2%ZS>=M%ZS .AND. M2%ZF<=M%ZF ) THEN
      FOUND = .TRUE.
      M%CONNECTED_MESH(NOM) = .TRUE.
   ENDIF

   ! Exit the other mesh loop if no neighboring meshes found

   IF (.NOT.FOUND) CYCLE OTHER_MESH_LOOP

   ! Tally the number of communications for this process

   N_COMMUNICATIONS = N_COMMUNICATIONS + 1

   ! Save the dimensions of the volume of cells from mesh NOM whose data is received by mesh NM
   ! DEFINITION I_MIN_R: Starting I index of cell block of mesh NOM whose info is to be received by mesh NM in MPI exchanges.
   ! DEFINITION I_MAX_R: Ending   I index of cell block of mesh NOM whose info is to be received by mesh NM in MPI exchanges.
   ! DEFINITION J_MIN_R: Starting J index of cell block of mesh NOM whose info is to be received by mesh NM in MPI exchanges.
   ! DEFINITION J_MAX_R: Ending   J index of cell block of mesh NOM whose info is to be received by mesh NM in MPI exchanges.
   ! DEFINITION K_MIN_R: Starting K index of cell block of mesh NOM whose info is to be received by mesh NM in MPI exchanges.
   ! DEFINITION K_MAX_R: Ending   K index of cell block of mesh NOM whose info is to be received by mesh NM in MPI exchanges.

   OM%I_MIN_R = IMIN
   OM%I_MAX_R = IMAX
   OM%J_MIN_R = JMIN
   OM%J_MAX_R = JMAX
   OM%K_MIN_R = KMIN
   OM%K_MAX_R = KMAX

   ! Allocate the arrays that hold information about the other meshes (OMESH)

   ALLOCATE(OM% RHO(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   ALLOCATE(OM%RHOS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   OM%RHO  = RHOA
   OM%RHOS = RHOA
   ALLOCATE(OM% D(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   ALLOCATE(OM%DS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   OM%D  = 0._EB
   OM%DS = 0._EB
   ALLOCATE(OM%  MU(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   OM%MU = 0._EB
   ALLOCATE(OM%    H(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   ALLOCATE(OM%   HS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   OM%H  = 0._EB
   OM%HS = 0._EB
   ALLOCATE(OM%   U(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   ALLOCATE(OM%  US(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   OM%U  = U0
   OM%US = U0
   ALLOCATE(OM%   V(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   ALLOCATE(OM%  VS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   OM%V  = V0
   OM%VS = V0
   ALLOCATE(OM%   W(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   ALLOCATE(OM%  WS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   OM%W  = W0
   OM%WS = W0
   ALLOCATE(OM% FVX(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   ALLOCATE(OM% FVY(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   ALLOCATE(OM% FVZ(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   OM%FVX = 0._EB
   OM%FVY = 0._EB
   OM%FVZ = 0._EB
   ALLOCATE(OM%KRES(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   OM%KRES = 0._EB

   ALLOCATE(OM%  ZZ(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX,N_TOTAL_SCALARS))
   ALLOCATE(OM% ZZS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX,N_TOTAL_SCALARS))
   DO N=1,N_TRACKED_SPECIES
      OM%ZZ(:,:,:,N)  = SPECIES_MIXTURE(N)%ZZ0
      OM%ZZS(:,:,:,N) = SPECIES_MIXTURE(N)%ZZ0
   ENDDO
   DO N=N_TRACKED_SPECIES+1,N_TOTAL_SCALARS
      OM%ZZ(:,:,:,N)  = INITIAL_UNMIXED_FRACTION
      OM%ZZS(:,:,:,N) = INITIAL_UNMIXED_FRACTION
   ENDDO

   ! Wall arrays

   IF (.NOT.ALLOCATED(OM%BOUNDARY_TYPE)) ALLOCATE(OM%BOUNDARY_TYPE(0:M2%N_EXTERNAL_WALL_CELLS))
   OM%BOUNDARY_TYPE(0)=0

   ! Particle and PARTICLE Orphan Arrays

   IF (OMESH_PARTICLES) THEN
      ALLOCATE(OM%N_PART_ORPHANS(N_LAGRANGIAN_CLASSES))
      ALLOCATE(OM%N_PART_ADOPT(N_LAGRANGIAN_CLASSES))
      OM%N_PART_ORPHANS = 0
      OM%N_PART_ADOPT   = 0
      ALLOCATE(OM%ORPHAN_PARTICLE_STORAGE(N_LAGRANGIAN_CLASSES))
      ALLOCATE(OM%ADOPT_PARTICLE_STORAGE(N_LAGRANGIAN_CLASSES))
      DO N=1,N_LAGRANGIAN_CLASSES
         LPC => LAGRANGIAN_PARTICLE_CLASS(N)
         N_STORAGE_SLOTS = 1000
         OM%ORPHAN_PARTICLE_STORAGE(N)%N_STORAGE_SLOTS = N_STORAGE_SLOTS
         OM%ADOPT_PARTICLE_STORAGE(N)%N_STORAGE_SLOTS = N_STORAGE_SLOTS
         ALLOCATE(OM%ORPHAN_PARTICLE_STORAGE(N)%REALS(LPC%N_STORAGE_REALS,N_STORAGE_SLOTS))
         ALLOCATE(OM%ORPHAN_PARTICLE_STORAGE(N)%INTEGERS(LPC%N_STORAGE_INTEGERS,N_STORAGE_SLOTS))
         ALLOCATE(OM%ORPHAN_PARTICLE_STORAGE(N)%LOGICALS(LPC%N_STORAGE_LOGICALS,N_STORAGE_SLOTS))
         ALLOCATE(OM%ADOPT_PARTICLE_STORAGE(N)%REALS(LPC%N_STORAGE_REALS,N_STORAGE_SLOTS))
         ALLOCATE(OM%ADOPT_PARTICLE_STORAGE(N)%INTEGERS(LPC%N_STORAGE_INTEGERS,N_STORAGE_SLOTS))
         ALLOCATE(OM%ADOPT_PARTICLE_STORAGE(N)%LOGICALS(LPC%N_STORAGE_LOGICALS,N_STORAGE_SLOTS))
      ENDDO
   ENDIF

ENDDO OTHER_MESH_LOOP

END SUBROUTINE INITIALIZE_MESH_EXCHANGE_1


SUBROUTINE INITIALIZE_MESH_EXCHANGE_2(NM)

! Create arrays by which info is to exchanged across meshes. In this routine, allocate arrays that involve NIC_R and NIC_S arrays.

INTEGER :: NOM
INTEGER, INTENT(IN) :: NM
TYPE (MESH_TYPE), POINTER :: M

IF (EVACUATION_ONLY(NM)) RETURN

M=>MESHES(NM)

! Allocate arrays to send (IL_S) and receive (IL_R) the radiation intensity (IL) at interpolated boundaries.
! MESHES(NM)%OMESH(NOM)%IL_S are the intensities in mesh NM that are just outside the boundary of mesh NOM. IL_S is populated
! in radi.f90 and then sent to MESHES(NOM)%OMESH(NM)%IL_R in MESH_EXCHANGE. IL_R holds the intensities until they are
! transferred to the ghost cells of MESHES(NOM)%IL in radi.f90. The IL_S and IL_R arrays are indexed by NIC_S and NIC_R.

DO NOM=1,NMESHES
   IF (M%OMESH(NOM)%NIC_S>0) THEN
      ALLOCATE(M%OMESH(NOM)%IL_S(M%OMESH(NOM)%NIC_S,NUMBER_RADIATION_ANGLES,NUMBER_SPECTRAL_BANDS))
      M%OMESH(NOM)%IL_S = RPI*SIGMA*TMPA4
    ENDIF
   IF (M%OMESH(NOM)%NIC_R>0) THEN
      ALLOCATE(M%OMESH(NOM)%IL_R(M%OMESH(NOM)%NIC_R,NUMBER_RADIATION_ANGLES,NUMBER_SPECTRAL_BANDS))
      M%OMESH(NOM)%IL_R = RPI*SIGMA*TMPA4
   ENDIF
ENDDO

END SUBROUTINE INITIALIZE_MESH_EXCHANGE_2


SUBROUTINE INITIALIZE_BACK_WALL_EXCHANGE

! Bordering meshes tell their neighbors how many exposed back wall cells they expect information for.

CALL POST_RECEIVES(8)
CALL MESH_EXCHANGE(8)

! DEFINITION MESHES(NM)%OMESH(NOM)%N_WALL_CELLS_SEND
! Number of wall cells in Mesh NM for which information must be sent to Mesh NOM.
! DEFINITION MESHES(NM)%OMESH(NOM)%WALL_CELL_INDICES_SEND
! Indices of the wall cells in Mesh NM for which information needs to be sent to Mesh NOM.

DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=1,NMESHES
      M3 => MESHES(NM)%OMESH(NOM)
      IF (M3%N_WALL_CELLS_SEND>0) ALLOCATE(M3%WALL_CELL_INDICES_SEND(M3%N_WALL_CELLS_SEND))
   ENDDO
ENDDO

! Mesh NM sends MESHES(NM)%OMESH(NOM)%EXPOSED_WALL_CELL_BACK_INDICES to Mesh NOM where it is received into
! MESHES(NOM)%OMESH(NM)%WALL_CELL_INDICES_SEND

CALL POST_RECEIVES(9)
CALL MESH_EXCHANGE(9)

! Set up arrays to send and receive exposed back wall cell information.

MESH_LOOP_1: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   IF (EVACUATION_ONLY(NM)) CYCLE MESH_LOOP_1
   M => MESHES(NM)
   MESH_LOOP_2: DO NOM=1,NMESHES
      IF (NM==NOM .OR. EVACUATION_ONLY(NOM)) CYCLE MESH_LOOP_2
      M3 => M%OMESH(NOM)
      IF (M3%N_WALL_CELLS_SEND>0) ALLOCATE(M3%REAL_SEND_PKG6(M3%N_WALL_CELLS_SEND*2))
      IF (M3%N_EXPOSED_WALL_CELLS>0) THEN
         ALLOCATE(M3%REAL_RECV_PKG6(M3%N_EXPOSED_WALL_CELLS*2))
         ALLOCATE(M3%EXPOSED_WALL(M3%N_EXPOSED_WALL_CELLS))
      ENDIF
   ENDDO MESH_LOOP_2
ENDDO MESH_LOOP_1

! Check to see if any process has an error. If so, stop the run.

CALL STOP_CHECK(1)

! Set up persistent SEND and RECV calls for BACK_WALL info

CALL POST_RECEIVES(10)
CALL MESH_EXCHANGE(10)

END SUBROUTINE INITIALIZE_BACK_WALL_EXCHANGE


SUBROUTINE POST_RECEIVES(CODE)

! Set up receive buffers for MPI calls.

INTEGER, INTENT(IN) :: CODE
INTEGER :: RNODE,SNODE,IJK_SIZE,N,N_STORAGE_SLOTS,NRA,NRA_MAX,LL,AIC
REAL(EB) :: TNOW
TYPE (LAGRANGIAN_PARTICLE_CLASS_TYPE), POINTER :: LPC

TNOW = SECOND()

! Initialize the number of non-persistent send/receive requests.

N_REQ = 0

! Loop over all receive meshes (NM) and look for the send meshes (NOM).

MESH_LOOP: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   IF (EVACUATION_ONLY(NM)) CYCLE MESH_LOOP

   RNODE = PROCESS(NM)
   M => MESHES(NM)

   OTHER_MESH_LOOP: DO NOM=1,NMESHES

      M3=>MESHES(NM)%OMESH(NOM)
      IF (M3%NIC_S==0 .AND. M3%NIC_R==0) CYCLE OTHER_MESH_LOOP
      IF (EVACUATION_ONLY(NOM)) CYCLE OTHER_MESH_LOOP
      IF (CODE>0 .AND. (EVACUATION_SKIP(NOM).OR.EVACUATION_SKIP(NM))) CYCLE OTHER_MESH_LOOP

      SNODE = PROCESS(NOM)
      IF (RNODE==SNODE) CYCLE OTHER_MESH_LOOP

      M4=>MESHES(NOM)

      ! Set up receives for one-time exchanges or persistent send/receives.

      INITIALIZATION_IF: IF (CODE==0) THEN

         IF (.NOT.ALLOCATED(M4%CELL_INDEX)) ALLOCATE(M4%CELL_INDEX(0:M4%IBP1,0:M4%JBP1,0:M4%KBP1))
         IF (.NOT.ALLOCATED(M4%SOLID))      ALLOCATE(M4%SOLID(0:CELL_COUNT(NOM)))
         IF (.NOT.ALLOCATED(M4%WALL_INDEX)) ALLOCATE(M4%WALL_INDEX(0:CELL_COUNT(NOM),-3:3))

         N_REQ = MIN(N_REQ+1,SIZE(REQ))
         CALL MPI_IRECV(M4%CELL_INDEX(0,0,0),SIZE(M4%CELL_INDEX),MPI_INTEGER,SNODE,NOM,MPI_COMM_WORLD,REQ(N_REQ),IERR)
         N_REQ = MIN(N_REQ+1,SIZE(REQ))
         CALL MPI_IRECV(M4%SOLID(0),SIZE(M4%SOLID),MPI_INTEGER,SNODE,NOM,MPI_COMM_WORLD,REQ(N_REQ),IERR)
         N_REQ = MIN(N_REQ+1,SIZE(REQ))
         CALL MPI_IRECV(M4%WALL_INDEX(0,-3),SIZE(M4%WALL_INDEX),MPI_INTEGER,SNODE,NOM,MPI_COMM_WORLD,REQ(N_REQ),IERR)

         IJK_SIZE = (M3%I_MAX_R-M3%I_MIN_R+1)*(M3%J_MAX_R-M3%J_MIN_R+1)*(M3%K_MAX_R-M3%K_MIN_R+1)

         IF (M3%NIC_R>0) THEN

            ! Determine the maximum number of radiation angles that are to be received

            NRA_MAX = 0
            IF (RADIATION) THEN
               DO AIC=1,ANGLE_INCREMENT
                  DO LL=1,M3%NIC_R
                     NRA = 0
                     DO N=NUMBER_RADIATION_ANGLES-AIC+1,1,-ANGLE_INCREMENT
                        IF (DLN(M3%IOR_R(LL),N)>0._EB) NRA = NRA + 1
                     ENDDO
                     NRA_MAX = MAX(NRA_MAX,NRA)
                  ENDDO
               ENDDO
            ENDIF

            ! Allocate the 1-D arrays that hold the big mesh variables that are to be received

            ALLOCATE(M3%REAL_RECV_PKG1(M3%NIC_R*2*(4+N_TOTAL_SCALARS)))
            ALLOCATE(M3%REAL_RECV_PKG2(IJK_SIZE*4))
            ALLOCATE(M3%REAL_RECV_PKG3(M3%NIC_R*2*(4+N_TOTAL_SCALARS)))
            ALLOCATE(M3%REAL_RECV_PKG4(IJK_SIZE*4))
            ALLOCATE(M3%REAL_RECV_PKG5(NRA_MAX*NUMBER_SPECTRAL_BANDS*M3%NIC_R))
            ALLOCATE(M3%REAL_RECV_PKG7(M3%NIC_R*3))
         ENDIF

         ! Set up persistent receive requests

         IF (M3%NIC_R>0) THEN

            N_REQ1 = N_REQ1 + 1
            CALL MPI_RECV_INIT(M3%REAL_RECV_PKG1(1),SIZE(M3%REAL_RECV_PKG1),MPI_DOUBLE_PRECISION,SNODE,NOM,MPI_COMM_WORLD,&
                               REQ1(N_REQ1),IERR)

            IF (OMESH_PARTICLES) THEN
               N_REQ2 = N_REQ2 + 1
               CALL MPI_RECV_INIT(M3%N_PART_ADOPT,SIZE(M3%N_PART_ADOPT),MPI_INTEGER,SNODE,NOM,MPI_COMM_WORLD,&
                                  REQ2(N_REQ2),IERR)
            ENDIF

            N_REQ3 = N_REQ3 + 1
            CALL MPI_RECV_INIT(M3%REAL_RECV_PKG2(1),SIZE(M3%REAL_RECV_PKG2),MPI_DOUBLE_PRECISION,SNODE,NOM,MPI_COMM_WORLD,&
                               REQ3(N_REQ3),IERR)

            N_REQ4 = N_REQ4 + 1
            CALL MPI_RECV_INIT(M3%REAL_RECV_PKG3(1),SIZE(M3%REAL_RECV_PKG3),MPI_DOUBLE_PRECISION,SNODE,NOM,MPI_COMM_WORLD,&
                               REQ4(N_REQ4),IERR)

            N_REQ5 = N_REQ5 + 1
            CALL MPI_RECV_INIT(M3%REAL_RECV_PKG7(1),SIZE(M3%REAL_RECV_PKG7),MPI_DOUBLE_PRECISION,SNODE,NOM,MPI_COMM_WORLD,&
                               REQ5(N_REQ5),IERR)

            N_REQ7 = N_REQ7 + 1
            CALL MPI_RECV_INIT(M3%REAL_RECV_PKG4(1),SIZE(M3%REAL_RECV_PKG4),MPI_DOUBLE_PRECISION,SNODE,NOM,MPI_COMM_WORLD,&
                               REQ7(N_REQ7),IERR)

            N_REQ8 = N_REQ8 + 1
            CALL MPI_RECV_INIT(M3%BOUNDARY_TYPE(0),SIZE(M3%BOUNDARY_TYPE),MPI_INTEGER,SNODE,NOM,MPI_COMM_WORLD,&
                               REQ8(N_REQ8),IERR)

            IF (RADIATION) THEN
               N_REQ9 = N_REQ9 + 1
               CALL MPI_RECV_INIT(M3%REAL_RECV_PKG5(1),SIZE(M3%REAL_RECV_PKG5),MPI_DOUBLE_PRECISION,SNODE,NOM,MPI_COMM_WORLD,&
                                  REQ9(N_REQ9),IERR)
            ENDIF

         ENDIF

      ENDIF INITIALIZATION_IF

      ! Exchange BACK_WALL information

      IF (CODE==8) THEN
         N_REQ=MIN(N_REQ+1,SIZE(REQ))
         CALL MPI_IRECV(M3%N_WALL_CELLS_SEND,1,MPI_INTEGER,SNODE,NOM,MPI_COMM_WORLD,REQ(N_REQ),IERR)
      ENDIF

      IF (CODE==9 .AND. M3%N_WALL_CELLS_SEND>0) THEN
            N_REQ=MIN(N_REQ+1,SIZE(REQ))
            CALL MPI_IRECV(M3%WALL_CELL_INDICES_SEND,SIZE(M3%WALL_CELL_INDICES_SEND),MPI_INTEGER,SNODE,NOM,MPI_COMM_WORLD,&
                           REQ(N_REQ),IERR)
      ENDIF

      IF (CODE==10 .AND. M3%N_EXPOSED_WALL_CELLS>0) THEN
         N_REQ6 = N_REQ6 + 1
         CALL MPI_RECV_INIT(M3%REAL_RECV_PKG6(1),SIZE(M3%REAL_RECV_PKG6),MPI_DOUBLE_PRECISION,SNODE,NOM,MPI_COMM_WORLD,&
                            REQ6(N_REQ6),IERR)
      ENDIF

      ! PARTICLEs

      IF (CODE==6 .AND. OMESH_PARTICLES) THEN
         DO N=1,N_LAGRANGIAN_CLASSES
            IF (M3%N_PART_ADOPT(N)==0) CYCLE
            LPC => LAGRANGIAN_PARTICLE_CLASS(N)
            N_REQ=MIN(N_REQ+1,SIZE(REQ))
            N_STORAGE_SLOTS = M3%ADOPT_PARTICLE_STORAGE(N)%N_STORAGE_SLOTS
            CALL MPI_IRECV(M3%ADOPT_PARTICLE_STORAGE(N)%REALS(1,1),LPC%N_STORAGE_REALS*N_STORAGE_SLOTS, &
                           MPI_DOUBLE_PRECISION,SNODE,NOM,MPI_COMM_WORLD,REQ(N_REQ),IERR)
            N_REQ=MIN(N_REQ+1,SIZE(REQ))
            CALL MPI_IRECV(M3%ADOPT_PARTICLE_STORAGE(N)%INTEGERS(1,1),LPC%N_STORAGE_INTEGERS*N_STORAGE_SLOTS, &
                           MPI_INTEGER,SNODE,NOM,MPI_COMM_WORLD,REQ(N_REQ),IERR)
            N_REQ=MIN(N_REQ+1,SIZE(REQ))
            CALL MPI_IRECV(M3%ADOPT_PARTICLE_STORAGE(N)%LOGICALS(1,1),LPC%N_STORAGE_LOGICALS*N_STORAGE_SLOTS, &
                           MPI_LOGICAL,SNODE,NOM,MPI_COMM_WORLD,REQ(N_REQ),IERR)
         ENDDO
      ENDIF

   ENDDO OTHER_MESH_LOOP

ENDDO MESH_LOOP

! Receive EVACuation information

DO NOM=1,NMESHES
   SNODE = PROCESS(NOM)
   IF (CODE==6 .AND. EXCHANGE_EVACUATION .AND. MYID==MAX(0,EVAC_PROCESS) .AND. .NOT.EVACUATION_ONLY(NOM)) THEN
      M4=>MESHES(NOM)
      TAG_EVAC = NOM*(MAX(0,EVAC_PROCESS)+1)*CODE*10
      IWW = (M4%IBAR+2)*(M4%JBAR+2)*(M4%KBAR+2)
      N_REQ=MIN(N_REQ+1,SIZE(REQ))
      CALL MPI_IRECV(M4%ZZ(0,0,0,1),IWW*N_TRACKED_SPECIES,MPI_DOUBLE_PRECISION,SNODE,TAG_EVAC,MPI_COMM_WORLD,REQ(N_REQ),IERR)
      N_REQ=MIN(N_REQ+1,SIZE(REQ))
      CALL MPI_IRECV(M4%RHO(0,0,0),IWW,MPI_DOUBLE_PRECISION,SNODE,TAG_EVAC,MPI_COMM_WORLD,REQ(N_REQ),IERR)
      N_REQ=MIN(N_REQ+1,SIZE(REQ))
      CALL MPI_IRECV(M4%RSUM(0,0,0),IWW,MPI_DOUBLE_PRECISION,SNODE,TAG_EVAC,MPI_COMM_WORLD,REQ(N_REQ),IERR)
      N_REQ=MIN(N_REQ+1,SIZE(REQ))
      CALL MPI_IRECV(M4%TMP(0,0,0),IWW,MPI_DOUBLE_PRECISION,SNODE,TAG_EVAC,MPI_COMM_WORLD,REQ(N_REQ),IERR)
      N_REQ=MIN(N_REQ+1,SIZE(REQ))
      CALL MPI_IRECV(M4%UII(0,0,0),IWW,MPI_DOUBLE_PRECISION,SNODE,TAG_EVAC,MPI_COMM_WORLD,REQ(N_REQ),IERR)
      N_REQ=MIN(N_REQ+1,SIZE(REQ))
      CALL MPI_IRECV(M4%CELL_INDEX(0,0,0),IWW,MPI_INTEGER,SNODE,TAG_EVAC,MPI_COMM_WORLD,REQ(N_REQ),IERR)
      IWW = MAXVAL(M4%CELL_INDEX)
      N_REQ=MIN(N_REQ+1,SIZE(REQ))
      CALL MPI_IRECV(M4%SOLID(0),IWW,MPI_LOGICAL,SNODE,TAG_EVAC,MPI_COMM_WORLD,REQ(N_REQ),IERR)
   ENDIF
ENDDO

T_USED(11)=T_USED(11) + SECOND() - TNOW
END SUBROUTINE POST_RECEIVES


SUBROUTINE MESH_EXCHANGE(CODE)

! Exchange Information between Meshes

REAL(EB) :: TNOW
INTEGER, INTENT(IN) :: CODE
INTEGER :: NM,II,JJ,KK,LL,LLL,N,RNODE,SNODE,IMIN,IMAX,JMIN,JMAX,KMIN,KMAX,IJK_SIZE,N_STORAGE_SLOTS,N_NEW_STORAGE_SLOTS
INTEGER :: NN1,NN2,IPC,CNT,IBC,STORAGE_INDEX_SAVE,II1,II2,JJ1,JJ2,KK1,KK2,NQT2,NN,IOR,NRA,NRA_MAX,AIC
REAL(EB), POINTER, DIMENSION(:,:,:) :: HP,HP2
TYPE (LAGRANGIAN_PARTICLE_TYPE), POINTER :: LP
TYPE (LAGRANGIAN_PARTICLE_CLASS_TYPE), POINTER :: LPC

TNOW = SECOND()

! Special circumstances when doing the radiation exchange (CODE=2)

IF (CODE==2) THEN
   IF (.NOT.EXCHANGE_RADIATION .OR. .NOT.RADIATION) RETURN
ENDIF

SENDING_MESH_LOOP: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   IF (EVACUATION_ONLY(NM)) CYCLE SENDING_MESH_LOOP

   M =>MESHES(NM)
   M5=>MESHES(NM)%OMESH(NM)

   ! Information about Mesh NM is packed into SEND packages and shipped out to the other meshes (machines) via MPI

   RECEIVING_MESH_LOOP: DO NOM=1,NMESHES

      M3=>MESHES(NM)%OMESH(NOM)
      IF (M3%NIC_S==0 .AND. M3%NIC_R==0)  CYCLE RECEIVING_MESH_LOOP
      IF (EVACUATION_ONLY(NOM)) CYCLE RECEIVING_MESH_LOOP

      SNODE = PROCESS(NOM)
      RNODE = PROCESS(NM)

      M4=>MESHES(NOM)

      IF (CODE>0) THEN
         IF (EVACUATION_SKIP(NM) .OR. EVACUATION_SKIP(NOM))  CYCLE RECEIVING_MESH_LOOP
      ENDIF

      IMIN = M3%I_MIN_S
      IMAX = M3%I_MAX_S
      JMIN = M3%J_MIN_S
      JMAX = M3%J_MAX_S
      KMIN = M3%K_MIN_S
      KMAX = M3%K_MAX_S

      IJK_SIZE = (IMAX-IMIN+1)*(JMAX-JMIN+1)*(KMAX-KMIN+1)

      ! Set up sends for one-time exchanges or persistent send/receives.

      INITIALIZE_SEND_IF: IF (CODE==0) THEN

         IF (RNODE/=SNODE) THEN
            N_REQ=MIN(N_REQ+1,SIZE(REQ))
            CALL MPI_ISEND(M%CELL_INDEX(0,0,0),SIZE(M%CELL_INDEX),MPI_INTEGER,SNODE,NM,MPI_COMM_WORLD,REQ(N_REQ),IERR)
            N_REQ=MIN(N_REQ+1,SIZE(REQ))
            CALL MPI_ISEND(M%SOLID(0),SIZE(M%SOLID),MPI_INTEGER,SNODE,NM,MPI_COMM_WORLD,REQ(N_REQ),IERR)
            N_REQ=MIN(N_REQ+1,SIZE(REQ))
            CALL MPI_ISEND(M%WALL_INDEX(0,-3),SIZE(M%WALL_INDEX),MPI_INTEGER,SNODE,NM,MPI_COMM_WORLD,REQ(N_REQ),IERR)
         ENDIF

         IF (M3%NIC_S>0 .AND. RNODE/=SNODE) THEN

            ! Determine the maximum number of radiation angles that are to be sent

            NRA_MAX = 0
            IF (RADIATION) THEN
               DO AIC=1,ANGLE_INCREMENT
                  DO LL=1,M3%NIC_S
                     NRA = 0
                     DO N=NUMBER_RADIATION_ANGLES-AIC+1,1,-ANGLE_INCREMENT
                        IF (DLN(M3%IOR_S(LL),N)>0._EB) NRA = NRA + 1
                     ENDDO
                     NRA_MAX = MAX(NRA_MAX,NRA)
                  ENDDO
               ENDDO
            ENDIF

            ! Allocate 1-D arrays to hold major mesh variables that are to be sent to neighboring meshes

            ALLOCATE(M3%REAL_SEND_PKG1(M3%NIC_S*2*(4+N_TOTAL_SCALARS)))
            ALLOCATE(M3%REAL_SEND_PKG2(IJK_SIZE*4))
            ALLOCATE(M3%REAL_SEND_PKG3(M3%NIC_S*2*(4+N_TOTAL_SCALARS)))
            ALLOCATE(M3%REAL_SEND_PKG4(IJK_SIZE*4))
            ALLOCATE(M3%REAL_SEND_PKG5(NRA_MAX*NUMBER_SPECTRAL_BANDS*M3%NIC_S))
            ALLOCATE(M3%REAL_SEND_PKG7(M3%NIC_S*3))

         ENDIF

         ! Initialize persistent send requests

         IF (M3%NIC_S>0 .AND. RNODE/=SNODE) THEN

            N_REQ1 = N_REQ1 + 1
            CALL MPI_SEND_INIT(M3%REAL_SEND_PKG1(1),SIZE(M3%REAL_SEND_PKG1),MPI_DOUBLE_PRECISION,SNODE,NM,MPI_COMM_WORLD,&
                               REQ1(N_REQ1),IERR)

            IF (OMESH_PARTICLES) THEN
               N_REQ2 = N_REQ2 + 1
               CALL MPI_SEND_INIT(M3%N_PART_ORPHANS,SIZE(M3%N_PART_ORPHANS),MPI_INTEGER,SNODE,NM,MPI_COMM_WORLD,&
                                  REQ2(N_REQ2),IERR)
            ENDIF

            N_REQ3 = N_REQ3 + 1
            CALL MPI_SEND_INIT(M3%REAL_SEND_PKG2(1),SIZE(M3%REAL_SEND_PKG2),MPI_DOUBLE_PRECISION,SNODE,NM,MPI_COMM_WORLD,&
                               REQ3(N_REQ3),IERR)

            N_REQ4 = N_REQ4 + 1
            CALL MPI_SEND_INIT(M3%REAL_SEND_PKG3(1),SIZE(M3%REAL_SEND_PKG3),MPI_DOUBLE_PRECISION,SNODE,NM,MPI_COMM_WORLD,&
                               REQ4(N_REQ4),IERR)

            N_REQ5 = N_REQ5 + 1
            CALL MPI_SEND_INIT(M3%REAL_SEND_PKG7(1),SIZE(M3%REAL_SEND_PKG7),MPI_DOUBLE_PRECISION,SNODE,NM,MPI_COMM_WORLD,&
                               REQ5(N_REQ5),IERR)

            N_REQ7 = N_REQ7 + 1
            CALL MPI_SEND_INIT(M3%REAL_SEND_PKG4(1),SIZE(M3%REAL_SEND_PKG4),MPI_DOUBLE_PRECISION,SNODE,NM,MPI_COMM_WORLD, &
                               REQ7(N_REQ7),IERR)

            N_REQ8 = N_REQ8 + 1
            CALL MPI_SEND_INIT(M5%BOUNDARY_TYPE(0),SIZE(M5%BOUNDARY_TYPE),MPI_INTEGER,SNODE,NM,MPI_COMM_WORLD,&
                               REQ8(N_REQ8),IERR)

            IF (RADIATION) THEN
               N_REQ9 = N_REQ9 + 1
               CALL MPI_SEND_INIT(M3%REAL_SEND_PKG5(1),SIZE(M3%REAL_SEND_PKG5),MPI_DOUBLE_PRECISION,SNODE,NM,MPI_COMM_WORLD,&
                                  REQ9(N_REQ9),IERR)
            ENDIF

         ENDIF

      ENDIF INITIALIZE_SEND_IF

      ! Exchange the number of solid surface cells whose back side is in another mesh

      IF (CODE==8) THEN
         IF (RNODE/=SNODE) THEN
            N_REQ=MIN(N_REQ+1,SIZE(REQ))
            CALL MPI_ISEND(M3%N_EXPOSED_WALL_CELLS,1,MPI_INTEGER,SNODE,NM,MPI_COMM_WORLD,REQ(N_REQ),IERR)
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            M2%N_WALL_CELLS_SEND = M3%N_EXPOSED_WALL_CELLS
         ENDIF
      ENDIF

      IF (CODE==9 .AND. M3%N_EXPOSED_WALL_CELLS>0) THEN
         IF (RNODE/=SNODE) THEN
            N_REQ=MIN(N_REQ+1,SIZE(REQ))
            CALL MPI_ISEND(M3%EXPOSED_WALL_CELL_BACK_INDICES,SIZE(M3%EXPOSED_WALL_CELL_BACK_INDICES),MPI_INTEGER,SNODE,NM,&
                           MPI_COMM_WORLD,REQ(N_REQ),IERR)
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            M2%WALL_CELL_INDICES_SEND = M3%EXPOSED_WALL_CELL_BACK_INDICES
         ENDIF
      ENDIF

      IF (CODE==10 .AND. M3%N_WALL_CELLS_SEND>0) THEN
         IF (RNODE/=SNODE) THEN
            N_REQ6 = N_REQ6 + 1
            CALL MPI_SEND_INIT(M3%REAL_SEND_PKG6(1),SIZE(M3%REAL_SEND_PKG6),MPI_DOUBLE_PRECISION,SNODE,NM,MPI_COMM_WORLD,&
                                REQ6(N_REQ6),IERR)
         ENDIF
      ENDIF

      ! Exchange of density and species mass fractions following the PREDICTOR update

      IF (CODE==1 .AND. M3%NIC_S>0) THEN
         IF (RNODE/=SNODE) THEN
            NQT2 = 2*(4+N_TOTAL_SCALARS)
            PACK_REAL_SEND_PKG1: DO LL=1,M3%NIC_S
               II1 = M3%IIO_S(LL) ; II2 = II1
               JJ1 = M3%JJO_S(LL) ; JJ2 = JJ1
               KK1 = M3%KKO_S(LL) ; KK2 = KK1
               SELECT CASE(M3%IOR_S(LL))
                  CASE(-1) ; II1=M3%IIO_S(LL)   ; II2=II1+1
                  CASE( 1) ; II1=M3%IIO_S(LL)-1 ; II2=II1+1
                  CASE(-2) ; JJ1=M3%JJO_S(LL)   ; JJ2=JJ1+1
                  CASE( 2) ; JJ1=M3%JJO_S(LL)-1 ; JJ2=JJ1+1
                  CASE(-3) ; KK1=M3%KKO_S(LL)   ; KK2=KK1+1
                  CASE( 3) ; KK1=M3%KKO_S(LL)-1 ; KK2=KK1+1
               END SELECT
               M3%REAL_SEND_PKG1(NQT2*(LL-1)+1) = M%RHOS(II1,JJ1,KK1)
               M3%REAL_SEND_PKG1(NQT2*(LL-1)+2) = M%RHOS(II2,JJ2,KK2)
               M3%REAL_SEND_PKG1(NQT2*(LL-1)+3) =   M%MU(II1,JJ1,KK1)
               M3%REAL_SEND_PKG1(NQT2*(LL-1)+4) =   M%MU(II2,JJ2,KK2)
               M3%REAL_SEND_PKG1(NQT2*(LL-1)+5) = M%KRES(II1,JJ1,KK1)
               M3%REAL_SEND_PKG1(NQT2*(LL-1)+6) = M%KRES(II2,JJ2,KK2)
               M3%REAL_SEND_PKG1(NQT2*(LL-1)+7) =    M%D(II1,JJ1,KK1)
               M3%REAL_SEND_PKG1(NQT2*(LL-1)+8) =    M%D(II2,JJ2,KK2)
               DO NN=1,N_TOTAL_SCALARS
                  M3%REAL_SEND_PKG1(NQT2*(LL-1)+8+2*NN-1) = M%ZZS(II1,JJ1,KK1,NN)
                  M3%REAL_SEND_PKG1(NQT2*(LL-1)+8+2*NN  ) = M%ZZS(II2,JJ2,KK2,NN)
               ENDDO
            ENDDO PACK_REAL_SEND_PKG1
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            M2%RHOS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)= M%RHOS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            M2%MU(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)  = M%MU(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            M2%KRES(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)= M%KRES(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            M2%D(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)   = M%D(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            M2%ZZS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX,1:N_TOTAL_SCALARS)= &
                                  M%ZZS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX,1:N_TOTAL_SCALARS)
         ENDIF
      ENDIF

      ! Exchange velocity/pressure info for ITERATE_PRESSURE

      IF (CODE==5 .AND. M3%NIC_S>0) THEN
         IF (PREDICTOR) HP => M%H
         IF (CORRECTOR) HP => M%HS
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG7: DO LL=1,M3%NIC_S
               SELECT CASE(M3%IOR_S(LL))
                  CASE(-1) ; M3%REAL_SEND_PKG7(3*LL-2) = M%FVX(M3%IIO_S(LL)-1,M3%JJO_S(LL)  ,M3%KKO_S(LL)  )
                             M3%REAL_SEND_PKG7(3*LL-1) =    HP(M3%IIO_S(LL)-1,M3%JJO_S(LL)  ,M3%KKO_S(LL)  )
                             M3%REAL_SEND_PKG7(3*LL  ) =    HP(M3%IIO_S(LL)  ,M3%JJO_S(LL)  ,M3%KKO_S(LL)  )
                  CASE( 1) ; M3%REAL_SEND_PKG7(3*LL-2) = M%FVX(M3%IIO_S(LL)  ,M3%JJO_S(LL)  ,M3%KKO_S(LL)  )
                             M3%REAL_SEND_PKG7(3*LL-1) =    HP(M3%IIO_S(LL)  ,M3%JJO_S(LL)  ,M3%KKO_S(LL)  )
                             M3%REAL_SEND_PKG7(3*LL  ) =    HP(M3%IIO_S(LL)+1,M3%JJO_S(LL)  ,M3%KKO_S(LL)  )
                  CASE(-2) ; M3%REAL_SEND_PKG7(3*LL-2) = M%FVY(M3%IIO_S(LL)  ,M3%JJO_S(LL)-1,M3%KKO_S(LL)  )
                             M3%REAL_SEND_PKG7(3*LL-1) =    HP(M3%IIO_S(LL)  ,M3%JJO_S(LL)-1,M3%KKO_S(LL)  )
                             M3%REAL_SEND_PKG7(3*LL  ) =    HP(M3%IIO_S(LL)  ,M3%JJO_S(LL)  ,M3%KKO_S(LL)  )
                  CASE( 2) ; M3%REAL_SEND_PKG7(3*LL-2) = M%FVY(M3%IIO_S(LL)  ,M3%JJO_S(LL)  ,M3%KKO_S(LL)  )
                             M3%REAL_SEND_PKG7(3*LL-1) =    HP(M3%IIO_S(LL)  ,M3%JJO_S(LL)  ,M3%KKO_S(LL)  )
                             M3%REAL_SEND_PKG7(3*LL  ) =    HP(M3%IIO_S(LL)  ,M3%JJO_S(LL)+1,M3%KKO_S(LL)  )
                  CASE(-3) ; M3%REAL_SEND_PKG7(3*LL-2) = M%FVZ(M3%IIO_S(LL)  ,M3%JJO_S(LL)  ,M3%KKO_S(LL)-1)
                             M3%REAL_SEND_PKG7(3*LL-1) =    HP(M3%IIO_S(LL)  ,M3%JJO_S(LL)  ,M3%KKO_S(LL)-1)
                             M3%REAL_SEND_PKG7(3*LL  ) =    HP(M3%IIO_S(LL)  ,M3%JJO_S(LL)  ,M3%KKO_S(LL)  )
                  CASE( 3) ; M3%REAL_SEND_PKG7(3*LL-2) = M%FVZ(M3%IIO_S(LL)  ,M3%JJO_S(LL)  ,M3%KKO_S(LL)  )
                             M3%REAL_SEND_PKG7(3*LL-1) =    HP(M3%IIO_S(LL)  ,M3%JJO_S(LL)  ,M3%KKO_S(LL)  )
                             M3%REAL_SEND_PKG7(3*LL  ) =    HP(M3%IIO_S(LL)  ,M3%JJO_S(LL)  ,M3%KKO_S(LL)+1)
               END SELECT
            ENDDO PACK_REAL_SEND_PKG7
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            IF (PREDICTOR) HP2 => M2%H
            IF (CORRECTOR) HP2 => M2%HS
            M2%FVX(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX) = M%FVX(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            M2%FVY(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX) = M%FVY(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            M2%FVZ(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX) = M%FVZ(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            HP2(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)    = HP(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
         ENDIF
      ENDIF

      ! Send pressure information at the end of the PREDICTOR stage of the time step

      IF (CODE==3 .AND. M3%NIC_S>0) THEN
         IF (RNODE/=SNODE) THEN
            LL = 0
            DO KK=KMIN,KMAX
               DO JJ=JMIN,JMAX
                  DO II=IMIN,IMAX
                     M3%REAL_SEND_PKG2(LL+1) = M%HS(II,JJ,KK)
                     M3%REAL_SEND_PKG2(LL+2) = M%US(II,JJ,KK)
                     M3%REAL_SEND_PKG2(LL+3) = M%VS(II,JJ,KK)
                     M3%REAL_SEND_PKG2(LL+4) = M%WS(II,JJ,KK)
                     LL = LL+4
                  ENDDO
               ENDDO
            ENDDO
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            M2%HS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX) = M%HS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            M2%US(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX) = M%US(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            M2%VS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX) = M%VS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            M2%WS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX) = M%WS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
         ENDIF
      ENDIF

      ! Exchange density and mass fraction following CORRECTOR update

      IF (CODE==4 .AND. M3%NIC_S>0) THEN
         IF (RNODE/=SNODE) THEN
            NQT2 = 2*(4+N_TOTAL_SCALARS)
            PACK_REAL_SEND_PKG3: DO LL=1,M3%NIC_S
               II1 = M3%IIO_S(LL) ; II2 = II1
               JJ1 = M3%JJO_S(LL) ; JJ2 = JJ1
               KK1 = M3%KKO_S(LL) ; KK2 = KK1
               SELECT CASE(M3%IOR_S(LL))
                  CASE(-1) ; II1=M3%IIO_S(LL)   ; II2=II1+1
                  CASE( 1) ; II1=M3%IIO_S(LL)-1 ; II2=II1+1
                  CASE(-2) ; JJ1=M3%JJO_S(LL)   ; JJ2=JJ1+1
                  CASE( 2) ; JJ1=M3%JJO_S(LL)-1 ; JJ2=JJ1+1
                  CASE(-3) ; KK1=M3%KKO_S(LL)   ; KK2=KK1+1
                  CASE( 3) ; KK1=M3%KKO_S(LL)-1 ; KK2=KK1+1
               END SELECT
               M3%REAL_SEND_PKG3(NQT2*(LL-1)+1) =  M%RHO(II1,JJ1,KK1)
               M3%REAL_SEND_PKG3(NQT2*(LL-1)+2) =  M%RHO(II2,JJ2,KK2)
               M3%REAL_SEND_PKG3(NQT2*(LL-1)+3) =   M%MU(II1,JJ1,KK1)
               M3%REAL_SEND_PKG3(NQT2*(LL-1)+4) =   M%MU(II2,JJ2,KK2)
               M3%REAL_SEND_PKG3(NQT2*(LL-1)+5) = M%KRES(II1,JJ1,KK1)
               M3%REAL_SEND_PKG3(NQT2*(LL-1)+6) = M%KRES(II2,JJ2,KK2)
               M3%REAL_SEND_PKG3(NQT2*(LL-1)+7) =   M%DS(II1,JJ1,KK1)
               M3%REAL_SEND_PKG3(NQT2*(LL-1)+8) =   M%DS(II2,JJ2,KK2)
               DO NN=1,N_TOTAL_SCALARS
                  M3%REAL_SEND_PKG3(NQT2*(LL-1)+8+2*NN-1) = M%ZZ(II1,JJ1,KK1,NN)
                  M3%REAL_SEND_PKG3(NQT2*(LL-1)+8+2*NN  ) = M%ZZ(II2,JJ2,KK2,NN)
               ENDDO
            ENDDO PACK_REAL_SEND_PKG3
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            M2%RHO(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX) = M%RHO(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            M2%MU(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)  = M%MU(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            M2%KRES(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)= M%KRES(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            M2%DS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)  = M%DS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            M2%ZZ(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX,1:N_TOTAL_SCALARS)= &
                                  M%ZZ(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX,1:N_TOTAL_SCALARS)
         ENDIF
      ENDIF

      ! Exchange BOUNDARY_TYPE following the CORRECTOR stage of the time step

      IF (CODE==0 .OR. CODE==6) THEN
         IF (RNODE/=SNODE) THEN
            DO IW=1,M%N_EXTERNAL_WALL_CELLS
               M5%BOUNDARY_TYPE(IW) = M%WALL(IW)%BOUNDARY_TYPE
            ENDDO
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            M2%BOUNDARY_TYPE(1:M%N_EXTERNAL_WALL_CELLS) = M5%BOUNDARY_TYPE(1:M%N_EXTERNAL_WALL_CELLS)
         ENDIF
      ENDIF

      ! Exchange BACK_WALL information

      IF (CODE==6) THEN
         IF (RNODE/=SNODE) THEN
            LL = 0
            DO II=1,M%OMESH(NOM)%N_WALL_CELLS_SEND
               IW = M%OMESH(NOM)%WALL_CELL_INDICES_SEND(II)
               M3%REAL_SEND_PKG6(LL+1) = M%WALL(IW)%ONE_D%QRADIN
               M3%REAL_SEND_PKG6(LL+2) = M%TMP(M%WALL(IW)%ONE_D%IIG,M%WALL(IW)%ONE_D%JJG,M%WALL(IW)%ONE_D%KKG)
               LL = LL+2
            ENDDO
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            DO II=1,M2%N_EXPOSED_WALL_CELLS
               IW = M2%EXPOSED_WALL_CELL_BACK_INDICES(II)
               M2%EXPOSED_WALL(II)%QRADIN = M%WALL(IW)%ONE_D%QRADIN
               M2%EXPOSED_WALL(II)%TMP_GAS = M%TMP(M%WALL(IW)%ONE_D%IIG,M%WALL(IW)%ONE_D%JJG,M%WALL(IW)%ONE_D%KKG)
            ENDDO
         ENDIF
      ENDIF

      ! Exchange pressure and velocities following CORRECTOR stage of time step

      IF (CODE==6 .AND. M3%NIC_S>0) THEN
         IF (RNODE/=SNODE) THEN
            LL = 0
            DO KK=KMIN,KMAX
               DO JJ=JMIN,JMAX
                  DO II=IMIN,IMAX
                     M3%REAL_SEND_PKG4(LL+1) = M%H(II,JJ,KK)
                     M3%REAL_SEND_PKG4(LL+2) = M%U(II,JJ,KK)
                     M3%REAL_SEND_PKG4(LL+3) = M%V(II,JJ,KK)
                     M3%REAL_SEND_PKG4(LL+4) = M%W(II,JJ,KK)
                     LL = LL+4
                  ENDDO
               ENDDO
            ENDDO
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            M2%H(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)    = M%H(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            M2%U(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)    = M%U(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            M2%V(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)    = M%V(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
            M2%W(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)    = M%W(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX)
         ENDIF
      ENDIF

      ! Send out radiation info

      SEND_RADIATION: IF (CODE==2 .AND. M3%NIC_S>0) THEN
         IF (RNODE/=SNODE) THEN
            IF (ICYC>1) ANG_INC_COUNTER = M%ANGLE_INC_COUNTER
            LLL = 0
            PACK_REAL_SEND_PKG5: DO LL=1,M3%NIC_S
               IOR = M3%IOR_S(LL)
               DO NN2=1,NUMBER_SPECTRAL_BANDS
                  DO NN1=NUMBER_RADIATION_ANGLES-ANG_INC_COUNTER+1,1,-ANGLE_INCREMENT
                     IF (DLN(IOR,NN1)<=0._EB) CYCLE
                     LLL = LLL + 1
                     M3%REAL_SEND_PKG5(LLL) = M3%IL_S(LL,NN1,NN2)
                  ENDDO
               ENDDO
            ENDDO PACK_REAL_SEND_PKG5
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            M2%IL_R = M3%IL_S
         ENDIF
      ENDIF SEND_RADIATION

      ! Get Number of PARTICLE Orphans (PARTICLEs that have left other meshes and are waiting to be picked up)

      IF (CODE==7 .AND. OMESH_PARTICLES) THEN
         IF (RNODE==SNODE) THEN
            M2=>MESHES(NOM)%OMESH(NM)
            M2%N_PART_ADOPT = M3%N_PART_ORPHANS
         ENDIF
      ENDIF

      ! Sending/Receiving PARTICLE Buffer Arrays

      IF_SEND_PARTICLES: IF (CODE==6 .AND. OMESH_PARTICLES) THEN

         NODE_CHECK_PARTICLE: IF (SNODE/=RNODE) THEN

            DO IPC=1,N_LAGRANGIAN_CLASSES

               IF (M3%N_PART_ORPHANS(IPC)==0) CYCLE

               LPC => LAGRANGIAN_PARTICLE_CLASS(IPC)
               IBC = LPC%SURF_INDEX

               N_STORAGE_SLOTS = M3%ORPHAN_PARTICLE_STORAGE(IPC)%N_STORAGE_SLOTS
               N_REQ=MIN(N_REQ+1,SIZE(REQ))
               CALL MPI_ISEND(M3%ORPHAN_PARTICLE_STORAGE(IPC)%REALS(1,1),LPC%N_STORAGE_REALS*N_STORAGE_SLOTS,MPI_DOUBLE_PRECISION, &
                              SNODE,NM,MPI_COMM_WORLD,REQ(N_REQ),IERR)
               N_REQ=MIN(N_REQ+1,SIZE(REQ))
               CALL MPI_ISEND(M3%ORPHAN_PARTICLE_STORAGE(IPC)%INTEGERS(1,1),LPC%N_STORAGE_INTEGERS*N_STORAGE_SLOTS,MPI_INTEGER, &
                              SNODE,NM,MPI_COMM_WORLD,REQ(N_REQ),IERR)
               N_REQ=MIN(N_REQ+1,SIZE(REQ))
               CALL MPI_ISEND(M3%ORPHAN_PARTICLE_STORAGE(IPC)%LOGICALS(1,1),LPC%N_STORAGE_LOGICALS*N_STORAGE_SLOTS,MPI_LOGICAL, &
                              SNODE,NM,MPI_COMM_WORLD,REQ(N_REQ),IERR)
            ENDDO

         ELSE NODE_CHECK_PARTICLE

            M2 => MESHES(NOM)%OMESH(NM)

            DO IPC=1,N_LAGRANGIAN_CLASSES
               LPC => LAGRANGIAN_PARTICLE_CLASS(IPC)
               M2%ADOPT_PARTICLE_STORAGE(IPC)%REALS    = M3%ORPHAN_PARTICLE_STORAGE(IPC)%REALS
               M2%ADOPT_PARTICLE_STORAGE(IPC)%INTEGERS = M3%ORPHAN_PARTICLE_STORAGE(IPC)%INTEGERS
               M2%ADOPT_PARTICLE_STORAGE(IPC)%LOGICALS = M3%ORPHAN_PARTICLE_STORAGE(IPC)%LOGICALS
            ENDDO

         ENDIF NODE_CHECK_PARTICLE

      ENDIF IF_SEND_PARTICLES

   ENDDO RECEIVING_MESH_LOOP

ENDDO SENDING_MESH_LOOP

! Send information needed by EVACuation routine

DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   IF (CODE==6 .AND. EXCHANGE_EVACUATION.AND.MYID/=MAX(0,EVAC_PROCESS) .AND..NOT.EVACUATION_ONLY(NM)) THEN
      M => MESHES(NM)
      TAG_EVAC = NM*(MAX(0,EVAC_PROCESS)+1)*CODE*10
      IWW = (M%IBAR+2)*(M%JBAR+2)*(M%KBAR+2)
      N_REQ=MIN(N_REQ+1,SIZE(REQ))
      CALL MPI_ISEND(M%ZZ(0,0,0,1),IWW*N_TRACKED_SPECIES,MPI_DOUBLE_PRECISION,MAX(0,EVAC_PROCESS),&
           TAG_EVAC,MPI_COMM_WORLD,REQ(N_REQ),IERR)
      N_REQ=MIN(N_REQ+1,SIZE(REQ))
      CALL MPI_ISEND(M%RHO(0,0,0),IWW,MPI_DOUBLE_PRECISION,MAX(0,EVAC_PROCESS),TAG_EVAC,MPI_COMM_WORLD,REQ(N_REQ),IERR)
      N_REQ=MIN(N_REQ+1,SIZE(REQ))
      CALL MPI_ISEND(M%RSUM(0,0,0),IWW,MPI_DOUBLE_PRECISION,MAX(0,EVAC_PROCESS),TAG_EVAC,MPI_COMM_WORLD,REQ(N_REQ),IERR)
      N_REQ=MIN(N_REQ+1,SIZE(REQ))
      CALL MPI_ISEND(M%TMP(0,0,0),IWW,MPI_DOUBLE_PRECISION,MAX(0,EVAC_PROCESS),TAG_EVAC,MPI_COMM_WORLD,REQ(N_REQ),IERR)
      N_REQ=MIN(N_REQ+1,SIZE(REQ))
      CALL MPI_ISEND(M%UII(0,0,0),IWW,MPI_DOUBLE_PRECISION,MAX(0,EVAC_PROCESS),TAG_EVAC,MPI_COMM_WORLD,REQ(N_REQ),IERR)
      N_REQ=MIN(N_REQ+1,SIZE(REQ))
      CALL MPI_ISEND(M%CELL_INDEX(0,0,0),IWW,MPI_INTEGER,MAX(0,EVAC_PROCESS),TAG_EVAC,MPI_COMM_WORLD,REQ(N_REQ),IERR)
      IWW = MAXVAL(M%CELL_INDEX)
      N_REQ=MIN(N_REQ+1,SIZE(REQ))
      CALL MPI_ISEND(M%SOLID(0),IWW,MPI_LOGICAL,MAX(0,EVAC_PROCESS),TAG_EVAC,MPI_COMM_WORLD,REQ(N_REQ),IERR)
   ENDIF
ENDDO


! Halt communications until all processes are ready to receive the data.

IF (N_MPI_PROCESSES>1 .AND. CODE/=1 .AND. CODE/=3 .AND. CODE/=4 .AND. CODE/=5 .AND. N_REQ>0) THEN
   CALL TIMEOUT('REQ',N_REQ,REQ(1:N_REQ))
ENDIF

IF (N_MPI_PROCESSES>1 .AND. CODE==1 .AND. N_REQ1>0) THEN
   CALL MPI_STARTALL(N_REQ1,REQ1(1:N_REQ1),IERR)
   CALL TIMEOUT('REQ1',N_REQ1,REQ1(1:N_REQ1))
ENDIF

IF (N_MPI_PROCESSES>1 .AND. CODE==7 .AND. OMESH_PARTICLES .AND. N_REQ2>0) THEN
   CALL MPI_STARTALL(N_REQ2,REQ2(1:N_REQ2),IERR)
   CALL TIMEOUT('REQ2',N_REQ2,REQ2(1:N_REQ2))
ENDIF

IF (N_MPI_PROCESSES>1 .AND. CODE==3 .AND. N_REQ3>0) THEN
   CALL MPI_STARTALL(N_REQ3,REQ3(1:N_REQ3),IERR)
   CALL TIMEOUT('REQ3',N_REQ3,REQ3(1:N_REQ3))
ENDIF

IF (N_MPI_PROCESSES>1 .AND. CODE==4 .AND. N_REQ4>0) THEN
   CALL MPI_STARTALL(N_REQ4,REQ4(1:N_REQ4),IERR)
   CALL TIMEOUT('REQ4',N_REQ4,REQ4(1:N_REQ4))
ENDIF

IF (N_MPI_PROCESSES>1 .AND. CODE==5 .AND. N_REQ5>0) THEN
   CALL MPI_STARTALL(N_REQ5,REQ5(1:N_REQ5),IERR)
   CALL TIMEOUT('REQ5',N_REQ5,REQ5(1:N_REQ5))
ENDIF

IF (N_MPI_PROCESSES>1 .AND. CODE==6 .AND. N_REQ6>0) THEN
   CALL MPI_STARTALL(N_REQ6,REQ6(1:N_REQ6),IERR)
   CALL TIMEOUT('REQ6',N_REQ6,REQ6(1:N_REQ6))
ENDIF

IF (N_MPI_PROCESSES>1 .AND. CODE==6 .AND. N_REQ7>0) THEN
   CALL MPI_STARTALL(N_REQ7,REQ7(1:N_REQ7),IERR)
   CALL TIMEOUT('REQ7',N_REQ7,REQ7(1:N_REQ7))
ENDIF

IF (N_MPI_PROCESSES>1 .AND. (CODE==0 .OR. CODE==6) .AND. N_REQ8>0) THEN
   CALL MPI_STARTALL(N_REQ8,REQ8(1:N_REQ8),IERR)
   CALL TIMEOUT('REQ8',N_REQ8,REQ8(1:N_REQ8))
ENDIF

IF (N_MPI_PROCESSES>1 .AND. CODE==2 .AND. N_REQ9>0) THEN
   CALL MPI_STARTALL(N_REQ9,REQ9(1:N_REQ9),IERR)
   CALL TIMEOUT('REQ9',N_REQ9,REQ9(1:N_REQ9))
ENDIF


! Receive the information sent above into the appropriate arrays.

SEND_MESH_LOOP: DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

IF (EVACUATION_ONLY(NOM)) CYCLE SEND_MESH_LOOP

SNODE = PROCESS(NOM)

   RECV_MESH_LOOP: DO NM=1,NMESHES

      M2=>MESHES(NOM)%OMESH(NM)
      IF (M2%NIC_S==0 .AND. M2%NIC_R==0) CYCLE RECV_MESH_LOOP
      IF (EVACUATION_ONLY(NM)) CYCLE RECV_MESH_LOOP
      IF (CODE>0 .AND. (EVACUATION_SKIP(NM).OR.EVACUATION_SKIP(NOM))) CYCLE RECV_MESH_LOOP

      RNODE = PROCESS(NM)

      M =>MESHES(NM)
      M4=>MESHES(NOM)

      IMIN = M2%I_MIN_R
      IMAX = M2%I_MAX_R
      JMIN = M2%J_MIN_R
      JMAX = M2%J_MAX_R
      KMIN = M2%K_MIN_R
      KMAX = M2%K_MAX_R

      ! Unpack densities and species mass fractions following PREDICTOR exchange

      IF (CODE==1 .AND. M2%NIC_R>0 .AND. RNODE/=SNODE) THEN
            NQT2 = 2*(4+N_TOTAL_SCALARS)
            UNPACK_REAL_RECV_PKG1: DO LL=1,M2%NIC_R
               II1 = M2%IIO_R(LL) ; II2 = II1
               JJ1 = M2%JJO_R(LL) ; JJ2 = JJ1
               KK1 = M2%KKO_R(LL) ; KK2 = KK1
               SELECT CASE(M2%IOR_R(LL))
                  CASE(-1) ; II1=M2%IIO_R(LL)   ; II2=II1+1
                  CASE( 1) ; II1=M2%IIO_R(LL)-1 ; II2=II1+1
                  CASE(-2) ; JJ1=M2%JJO_R(LL)   ; JJ2=JJ1+1
                  CASE( 2) ; JJ1=M2%JJO_R(LL)-1 ; JJ2=JJ1+1
                  CASE(-3) ; KK1=M2%KKO_R(LL)   ; KK2=KK1+1
                  CASE( 3) ; KK1=M2%KKO_R(LL)-1 ; KK2=KK1+1
               END SELECT
               M2%RHOS(II1,JJ1,KK1) = M2%REAL_RECV_PKG1(NQT2*(LL-1)+1)
               M2%RHOS(II2,JJ2,KK2) = M2%REAL_RECV_PKG1(NQT2*(LL-1)+2)
                 M2%MU(II1,JJ1,KK1) = M2%REAL_RECV_PKG1(NQT2*(LL-1)+3)
                 M2%MU(II2,JJ2,KK2) = M2%REAL_RECV_PKG1(NQT2*(LL-1)+4)
               M2%KRES(II1,JJ1,KK1) = M2%REAL_RECV_PKG1(NQT2*(LL-1)+5)
               M2%KRES(II2,JJ2,KK2) = M2%REAL_RECV_PKG1(NQT2*(LL-1)+6)
                  M2%D(II1,JJ1,KK1) = M2%REAL_RECV_PKG1(NQT2*(LL-1)+7)
                  M2%D(II2,JJ2,KK2) = M2%REAL_RECV_PKG1(NQT2*(LL-1)+8)
               DO NN=1,N_TOTAL_SCALARS
                  M2%ZZS(II1,JJ1,KK1,NN) = M2%REAL_RECV_PKG1(NQT2*(LL-1)+8+2*NN-1)
                  M2%ZZS(II2,JJ2,KK2,NN) = M2%REAL_RECV_PKG1(NQT2*(LL-1)+8+2*NN  )
               ENDDO
            ENDDO UNPACK_REAL_RECV_PKG1
      ENDIF

      ! Unpack densities and species mass fractions following PREDICTOR exchange

      IF (CODE==5 .AND. M2%NIC_R>0 .AND. RNODE/=SNODE) THEN
         IF (PREDICTOR) HP => M2%H
         IF (CORRECTOR) HP => M2%HS
         UNPACK_REAL_RECV_PKG7: DO LL=1,M2%NIC_R
            SELECT CASE(M2%IOR_R(LL))
               CASE(-1) ; M2%FVX(M2%IIO_R(LL)-1,M2%JJO_R(LL)  ,M2%KKO_R(LL)  ) = M2%REAL_RECV_PKG7(3*LL-2)
                              HP(M2%IIO_R(LL)-1,M2%JJO_R(LL)  ,M2%KKO_R(LL)  ) = M2%REAL_RECV_PKG7(3*LL-1)
                              HP(M2%IIO_R(LL)  ,M2%JJO_R(LL)  ,M2%KKO_R(LL)  ) = M2%REAL_RECV_PKG7(3*LL  )
               CASE( 1) ; M2%FVX(M2%IIO_R(LL)  ,M2%JJO_R(LL)  ,M2%KKO_R(LL)  ) = M2%REAL_RECV_PKG7(3*LL-2)
                              HP(M2%IIO_R(LL)  ,M2%JJO_R(LL)  ,M2%KKO_R(LL)  ) = M2%REAL_RECV_PKG7(3*LL-1)
                              HP(M2%IIO_R(LL)+1,M2%JJO_R(LL)  ,M2%KKO_R(LL)  ) = M2%REAL_RECV_PKG7(3*LL  )
               CASE(-2) ; M2%FVY(M2%IIO_R(LL)  ,M2%JJO_R(LL)-1,M2%KKO_R(LL)  ) = M2%REAL_RECV_PKG7(3*LL-2)
                              HP(M2%IIO_R(LL)  ,M2%JJO_R(LL)-1,M2%KKO_R(LL)  ) = M2%REAL_RECV_PKG7(3*LL-1)
                              HP(M2%IIO_R(LL)  ,M2%JJO_R(LL)  ,M2%KKO_R(LL)  ) = M2%REAL_RECV_PKG7(3*LL  )
               CASE( 2) ; M2%FVY(M2%IIO_R(LL)  ,M2%JJO_R(LL)  ,M2%KKO_R(LL)  ) = M2%REAL_RECV_PKG7(3*LL-2)
                              HP(M2%IIO_R(LL)  ,M2%JJO_R(LL)  ,M2%KKO_R(LL)  ) = M2%REAL_RECV_PKG7(3*LL-1)
                              HP(M2%IIO_R(LL)  ,M2%JJO_R(LL)+1,M2%KKO_R(LL)  ) = M2%REAL_RECV_PKG7(3*LL  )
               CASE(-3) ; M2%FVZ(M2%IIO_R(LL)  ,M2%JJO_R(LL)  ,M2%KKO_R(LL)-1) = M2%REAL_RECV_PKG7(3*LL-2)
                              HP(M2%IIO_R(LL)  ,M2%JJO_R(LL)  ,M2%KKO_R(LL)-1) = M2%REAL_RECV_PKG7(3*LL-1)
                              HP(M2%IIO_R(LL)  ,M2%JJO_R(LL)  ,M2%KKO_R(LL)  ) = M2%REAL_RECV_PKG7(3*LL  )
               CASE( 3) ; M2%FVZ(M2%IIO_R(LL)  ,M2%JJO_R(LL)  ,M2%KKO_R(LL)  ) = M2%REAL_RECV_PKG7(3*LL-2)
                              HP(M2%IIO_R(LL)  ,M2%JJO_R(LL)  ,M2%KKO_R(LL)  ) = M2%REAL_RECV_PKG7(3*LL-1)
                              HP(M2%IIO_R(LL)  ,M2%JJO_R(LL)  ,M2%KKO_R(LL)+1) = M2%REAL_RECV_PKG7(3*LL  )
            END SELECT
         ENDDO UNPACK_REAL_RECV_PKG7
      ENDIF

      ! Unpack pressure following PREDICTOR stage of time step

      IF (CODE==3 .AND. M2%NIC_R>0 .AND. RNODE/=SNODE) THEN
         LL = 0
         DO KK=KMIN,KMAX
            DO JJ=JMIN,JMAX
               DO II=IMIN,IMAX
                  M2%HS(II,JJ,KK)   = M2%REAL_RECV_PKG2(LL+1)
                  M2%US(II,JJ,KK)   = M2%REAL_RECV_PKG2(LL+2)
                  M2%VS(II,JJ,KK)   = M2%REAL_RECV_PKG2(LL+3)
                  M2%WS(II,JJ,KK)   = M2%REAL_RECV_PKG2(LL+4)
                  LL = LL+4
               ENDDO
            ENDDO
         ENDDO
      ENDIF

      ! Unpack density and species mass fractions following CORRECTOR update

      IF (CODE==4 .AND. M2%NIC_R>0 .AND. RNODE/=SNODE) THEN
         NQT2 = 2*(4+N_TOTAL_SCALARS)
         UNPACK_REAL_RECV_PKG3: DO LL=1,M2%NIC_R
            II1 = M2%IIO_R(LL) ; II2 = II1
            JJ1 = M2%JJO_R(LL) ; JJ2 = JJ1
            KK1 = M2%KKO_R(LL) ; KK2 = KK1
            SELECT CASE(M2%IOR_R(LL))
               CASE(-1) ; II1=M2%IIO_R(LL)   ; II2=II1+1
               CASE( 1) ; II1=M2%IIO_R(LL)-1 ; II2=II1+1
               CASE(-2) ; JJ1=M2%JJO_R(LL)   ; JJ2=JJ1+1
               CASE( 2) ; JJ1=M2%JJO_R(LL)-1 ; JJ2=JJ1+1
               CASE(-3) ; KK1=M2%KKO_R(LL)   ; KK2=KK1+1
               CASE( 3) ; KK1=M2%KKO_R(LL)-1 ; KK2=KK1+1
            END SELECT
             M2%RHO(II1,JJ1,KK1) = M2%REAL_RECV_PKG3(NQT2*(LL-1)+1)
             M2%RHO(II2,JJ2,KK2) = M2%REAL_RECV_PKG3(NQT2*(LL-1)+2)
              M2%MU(II1,JJ1,KK1) = M2%REAL_RECV_PKG3(NQT2*(LL-1)+3)
              M2%MU(II2,JJ2,KK2) = M2%REAL_RECV_PKG3(NQT2*(LL-1)+4)
            M2%KRES(II1,JJ1,KK1) = M2%REAL_RECV_PKG3(NQT2*(LL-1)+5)
            M2%KRES(II2,JJ2,KK2) = M2%REAL_RECV_PKG3(NQT2*(LL-1)+6)
              M2%DS(II1,JJ1,KK1) = M2%REAL_RECV_PKG3(NQT2*(LL-1)+7)
              M2%DS(II2,JJ2,KK2) = M2%REAL_RECV_PKG3(NQT2*(LL-1)+8)
            DO NN=1,N_TOTAL_SCALARS
               M2%ZZ(II1,JJ1,KK1,NN) = M2%REAL_RECV_PKG3(NQT2*(LL-1)+8+2*NN-1)
               M2%ZZ(II2,JJ2,KK2,NN) = M2%REAL_RECV_PKG3(NQT2*(LL-1)+8+2*NN)
            ENDDO
         ENDDO UNPACK_REAL_RECV_PKG3
      ENDIF

      ! Unpack pressure and velocities at the end of the CORRECTOR stage of the time step

      IF (CODE==6 .AND. M2%NIC_R>0 .AND. RNODE/=SNODE) THEN
         LL = 0
         DO KK=KMIN,KMAX
            DO JJ=JMIN,JMAX
               DO II=IMIN,IMAX
                  M2%H(II,JJ,KK)    = M2%REAL_RECV_PKG4(LL+1)
                  M2%U(II,JJ,KK)    = M2%REAL_RECV_PKG4(LL+2)
                  M2%V(II,JJ,KK)    = M2%REAL_RECV_PKG4(LL+3)
                  M2%W(II,JJ,KK)    = M2%REAL_RECV_PKG4(LL+4)
                  LL = LL+4
               ENDDO
            ENDDO
         ENDDO
      ENDIF

      ! Unpack radiation information at the end of the CORRECTOR stage of the time step

      RECEIVE_RADIATION: IF (CODE==2 .AND. M2%NIC_R>0 .AND. RNODE/=SNODE) THEN
         IF (ICYC>1) ANG_INC_COUNTER = M4%ANGLE_INC_COUNTER
         LLL = 0
         UNPACK_REAL_RECV_PKG5: DO LL=1,M2%NIC_R
            IOR = M2%IOR_R(LL)
            DO NN2=1,NUMBER_SPECTRAL_BANDS
               DO NN1=NUMBER_RADIATION_ANGLES-ANG_INC_COUNTER+1,1,-ANGLE_INCREMENT
                  IF (DLN(IOR,NN1)<=0._EB) CYCLE
                  LLL = LLL + 1
                  M2%IL_R(LL,NN1,NN2) = M2%REAL_RECV_PKG5(LLL)
               ENDDO
            ENDDO
         ENDDO UNPACK_REAL_RECV_PKG5
      ENDIF RECEIVE_RADIATION

      ! Unpack back wall information at the end of the CORRECTOR stage of the time step

      RECEIVE_BACK_WALL: IF (CODE==6 .AND. SNODE/=RNODE) THEN
         LL = 0
         DO II=1,M2%N_EXPOSED_WALL_CELLS
            M2%EXPOSED_WALL(II)%QRADIN  = M2%REAL_RECV_PKG6(LL+1)
            M2%EXPOSED_WALL(II)%TMP_GAS = M2%REAL_RECV_PKG6(LL+2)
            LL = LL+2
         ENDDO
      ENDIF RECEIVE_BACK_WALL

      ! Sending/Receiving PARTICLE Buffer Arrays

      IF (CODE==7 .AND. OMESH_PARTICLES) THEN
         DO IPC=1,N_LAGRANGIAN_CLASSES
            IF (M2%N_PART_ADOPT(IPC)>M2%ADOPT_PARTICLE_STORAGE(IPC)%N_STORAGE_SLOTS) THEN
               N_NEW_STORAGE_SLOTS = M2%N_PART_ADOPT(IPC)-M2%ADOPT_PARTICLE_STORAGE(IPC)%N_STORAGE_SLOTS
               CALL REALLOCATE_STORAGE_ARRAYS(NOM,3,IPC,N_NEW_STORAGE_SLOTS,NM)
            ENDIF
         ENDDO
      ENDIF

      IF_RECEIVE_PARTICLES: IF (CODE==6 .AND. OMESH_PARTICLES) THEN

         DO IPC=1,N_LAGRANGIAN_CLASSES
            IF (M2%N_PART_ADOPT(IPC)==0) CYCLE
            CNT = 0
            DO N=M4%NLP+1,M4%NLP+M2%N_PART_ADOPT(IPC)
               CNT = CNT + 1
               IBC = LAGRANGIAN_PARTICLE_CLASS(IPC)%SURF_INDEX
               CALL ALLOCATE_STORAGE(NOM,IBC,LPC_INDEX=IPC,LP_INDEX=N,TAG=-1)
               LP=>M4%LAGRANGIAN_PARTICLE(N)
               STORAGE_INDEX_SAVE = LP%STORAGE_INDEX
               M4%PARTICLE_STORAGE(IPC)%REALS(:,STORAGE_INDEX_SAVE)    = M2%ADOPT_PARTICLE_STORAGE(IPC)%REALS(:,CNT)
               M4%PARTICLE_STORAGE(IPC)%INTEGERS(:,STORAGE_INDEX_SAVE) = M2%ADOPT_PARTICLE_STORAGE(IPC)%INTEGERS(:,CNT)
               LP%ARRAY_INDEX = N
               LP%STORAGE_INDEX = STORAGE_INDEX_SAVE
               M4%PARTICLE_STORAGE(IPC)%LOGICALS(:,STORAGE_INDEX_SAVE) = M2%ADOPT_PARTICLE_STORAGE(IPC)%LOGICALS(:,CNT)
            ENDDO
            M4%NLP = M4%NLP + M2%N_PART_ADOPT(IPC)
         ENDDO

      ENDIF IF_RECEIVE_PARTICLES

   ENDDO RECV_MESH_LOOP

ENDDO SEND_MESH_LOOP

T_USED(11)=T_USED(11) + SECOND() - TNOW
END SUBROUTINE MESH_EXCHANGE


SUBROUTINE TIMEOUT(RNAME,NR,RR)

REAL(EB) :: START_TIME,WAIT_TIME
INTEGER :: NR
INTEGER, DIMENSION(:) :: RR
LOGICAL :: FLAG
CHARACTER(*) :: RNAME

IF (.NOT.PROFILING) THEN

   START_TIME = MPI_WTIME()
   FLAG = .FALSE.
   DO WHILE(.NOT.FLAG)
      CALL MPI_TESTALL(NR,RR(1:NR),FLAG,MPI_STATUSES_IGNORE,IERR)
      WAIT_TIME = MPI_WTIME() - START_TIME
      IF (WAIT_TIME>MPI_TIMEOUT) THEN
         WRITE(LU_ERR,'(A,A,I6,A,A)') TRIM(RNAME),' timed out for MPI process ',MYID,' running on ',PNAME(1:PNAMELEN)
         CALL MPI_ABORT(MPI_COMM_WORLD,0,IERR)
      ENDIF
   ENDDO
ELSE

   CALL MPI_WAITALL(NR,RR(1:NR),MPI_STATUSES_IGNORE,IERR)

ENDIF

END SUBROUTINE TIMEOUT


SUBROUTINE DUMP_CPU_TIME

! Write out the file CHID_cpu.csv file containing the time usage of each MPI process.

INTEGER, PARAMETER :: LINE_LENGTH=159
CHARACTER, PARAMETER :: LF=ACHAR(10)
CHARACTER(LEN=LINE_LENGTH+1) :: LINE,HEAD
INTEGER :: ERROR,RECORD,FH
REAL(EB) :: T_MAIN

FN_CPU = TRIM(CHID)//'_cpu.csv'

IF (USE_MPI) THEN
   CALL MPI_TYPE_CONTIGUOUS(LINE_LENGTH+1,MPI_CHARACTER,RECORD,ERROR)
   CALL MPI_TYPE_COMMIT(RECORD,ERROR)
   CALL MPI_FILE_OPEN(MPI_COMM_WORLD,FN_CPU,MPI_MODE_WRONLY+MPI_MODE_CREATE,MPI_INFO_NULL,FH,ERROR)
   CALL MPI_FILE_SET_VIEW(FH,0_MPI_OFFSET_KIND,RECORD,RECORD,'NATIVE',MPI_INFO_NULL,ERROR)
ELSE
   OPEN(LU_CPU,FILE=FN_CPU,FORM='FORMATTED',STATUS='REPLACE')
ENDIF

DO N=0,N_MPI_PROCESSES-1
   IF (MYID/=N) CYCLE
   IF (MYID==0) THEN
      HEAD(1:LINE_LENGTH+1) = ' '
      WRITE(HEAD,'(A)') 'Rank,MAIN,DIVG,MASS,VELO,PRES,WALL,DUMP,PART,RADI,FIRE,COMM,EVAC,HVAC,Total T_USED (s)'
      IF (USE_MPI) THEN
         HEAD(LINE_LENGTH+1:LINE_LENGTH+1) = LF
         CALL MPI_FILE_WRITE_AT(FH,INT(0,MPI_OFFSET_KIND),HEAD,1,RECORD,MPI_STATUS_IGNORE,ERROR)
       ELSE
         WRITE(LU_CPU,'(A)') HEAD
       ENDIF
   ENDIF
   T_MAIN = SECOND() - T_USED(1) - SUM(T_USED(2:N_TIMERS))
   WRITE(LINE,'(I5,14(",",ES10.3))') MYID,T_MAIN,(T_USED(I),I=2,N_TIMERS),T_MAIN+SUM(T_USED(2:N_TIMERS))
   IF (USE_MPI) THEN
      LINE(LINE_LENGTH+1:LINE_LENGTH+1) = LF
      CALL MPI_FILE_WRITE_AT(FH,INT(N+1,MPI_OFFSET_KIND),LINE,1,RECORD,MPI_STATUS_IGNORE,ERROR)
   ELSE
      WRITE(LU_CPU,'(A)') LINE
   ENDIF
ENDDO

IF (USE_MPI) THEN
   CALL MPI_FILE_CLOSE(FH,ERROR)
   CALL MPI_TYPE_FREE(RECORD,ERROR)
ELSE
   CLOSE(LU_CPU)
ENDIF

END SUBROUTINE DUMP_CPU_TIME


SUBROUTINE WRITE_STRINGS

! Write character strings out to the .smv file

INTEGER :: N,NOM,N_STRINGS_DUM
CHARACTER(80), ALLOCATABLE, DIMENSION(:) :: STRING_DUM
REAL(EB) :: TNOW

TNOW = SECOND()

! All meshes send their STRINGs to node 0

DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   IF (MYID>0) THEN
      CALL MPI_SEND(MESHES(NM)%N_STRINGS,1,MPI_INTEGER,0,1,MPI_COMM_WORLD,IERR)
      IF (MESHES(NM)%N_STRINGS>0) CALL MPI_SEND(MESHES(NM)%STRING(1),MESHES(NM)%N_STRINGS*80,MPI_CHARACTER,0,NM, &
                                                MPI_COMM_WORLD,IERR)
   ENDIF
ENDDO

! Node 0 receives the STRINGs and writes them to the .smv file

IF (MYID==0) THEN
   DO N=1,MESHES(1)%N_STRINGS
      WRITE(LU_SMV,'(A)') TRIM(MESHES(1)%STRING(N))
   ENDDO
   OTHER_MESH_LOOP: DO NOM=2,NMESHES
      IF (PROCESS(NOM)>0) THEN
         CALL MPI_RECV(N_STRINGS_DUM,1,MPI_INTEGER,PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
         IF (N_STRINGS_DUM>0) THEN
            ALLOCATE(STRING_DUM(N_STRINGS_DUM))
            CALL MPI_RECV(STRING_DUM(1),N_STRINGS_DUM*80,MPI_CHARACTER,PROCESS(NOM),NOM,MPI_COMM_WORLD,STATUS,IERR)
         ENDIF
      ELSE
         N_STRINGS_DUM = MESHES(NOM)%N_STRINGS
         IF (N_STRINGS_DUM>0) THEN
            ALLOCATE(STRING_DUM(N_STRINGS_DUM))
            STRING_DUM(1:N_STRINGS_DUM) = MESHES(NOM)%STRING(1:N_STRINGS_DUM)
         ENDIF
      ENDIF
      DO N=1,N_STRINGS_DUM
         WRITE(LU_SMV,'(A)') TRIM(STRING_DUM(N))
      ENDDO
      IF (ALLOCATED(STRING_DUM)) DEALLOCATE(STRING_DUM)
   ENDDO OTHER_MESH_LOOP
ENDIF

! All STRING arrays are zeroed out

DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   MESHES(NM)%N_STRINGS = 0
ENDDO

T_USED(11) = T_USED(11) + SECOND() - TNOW
END SUBROUTINE WRITE_STRINGS


SUBROUTINE EXCHANGE_DIAGNOSTICS

INTEGER  :: NOM,CNT,DISP
REAL(EB) :: TNOW

TNOW = SECOND()

DISP = DISPLS(MYID)+1
CNT  = COUNTS(MYID)
IF (N_MPI_PROCESSES>1) THEN
   REAL_BUFFER_11 = Q_DOT
   CALL MPI_GATHERV(REAL_BUFFER_11(1,DISP),CNT*N_Q_DOT,MPI_DOUBLE_PRECISION,Q_DOT,COUNTS_Q_DOT,DISPLS_Q_DOT, &
                    MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,IERR)
   REAL_BUFFER_12 = M_DOT
   CALL MPI_GATHERV(REAL_BUFFER_12(1,DISP),CNT*N_M_DOT,MPI_DOUBLE_PRECISION,M_DOT,COUNTS_M_DOT,DISPLS_M_DOT, &
                    MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,IERR)
ENDIF

! All nodes greater than 0 send various values to node 0

DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   IF (MYID==0) CYCLE
   CALL MPI_SEND(MESHES(NM)%CFL,                     1,MPI_DOUBLE_PRECISION, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%DIVMX,                   1,MPI_DOUBLE_PRECISION, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%DIVMN,                   1,MPI_DOUBLE_PRECISION, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%RESMAX,                  1,MPI_DOUBLE_PRECISION, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%POIS_PTB,                1,MPI_DOUBLE_PRECISION, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%POIS_ERR,                1,MPI_DOUBLE_PRECISION, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%VN,                      1,MPI_DOUBLE_PRECISION, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%ICFL,                    1,MPI_INTEGER,          0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%JCFL,                    1,MPI_INTEGER,          0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%KCFL,                    1,MPI_INTEGER,          0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%IMX,                     1,MPI_INTEGER,          0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%JMX,                     1,MPI_INTEGER,          0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%KMX,                     1,MPI_INTEGER,          0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%IMN,                     1,MPI_INTEGER,          0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%JMN,                     1,MPI_INTEGER,          0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%KMN,                     1,MPI_INTEGER,          0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%IRM,                     1,MPI_INTEGER,          0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%JRM,                     1,MPI_INTEGER,          0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%KRM,                     1,MPI_INTEGER,          0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%I_VN,                    1,MPI_INTEGER,          0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%J_VN,                    1,MPI_INTEGER,          0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%K_VN,                    1,MPI_INTEGER,          0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(NM)%NLP,                     1,MPI_INTEGER,          0,1,MPI_COMM_WORLD,IERR)
ENDDO

! Node 0 receives various values from all other nodes

DO NOM=1,NMESHES
   IF (PROCESS(NOM)==0 .OR. MYID/=0) CYCLE
   CALL MPI_RECV(MESHES(NOM)%CFL,                     1,MPI_DOUBLE_PRECISION,PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%DIVMX,                   1,MPI_DOUBLE_PRECISION,PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%DIVMN,                   1,MPI_DOUBLE_PRECISION,PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%RESMAX,                  1,MPI_DOUBLE_PRECISION,PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%POIS_PTB,                1,MPI_DOUBLE_PRECISION,PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%POIS_ERR,                1,MPI_DOUBLE_PRECISION,PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%VN,                      1,MPI_DOUBLE_PRECISION,PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%ICFL,                    1,MPI_INTEGER,         PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%JCFL,                    1,MPI_INTEGER,         PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%KCFL,                    1,MPI_INTEGER,         PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%IMX,                     1,MPI_INTEGER,         PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%JMX,                     1,MPI_INTEGER,         PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%KMX,                     1,MPI_INTEGER,         PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%IMN,                     1,MPI_INTEGER,         PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%JMN,                     1,MPI_INTEGER,         PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%KMN,                     1,MPI_INTEGER,         PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%IRM,                     1,MPI_INTEGER,         PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%JRM,                     1,MPI_INTEGER,         PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%KRM,                     1,MPI_INTEGER,         PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%I_VN,                    1,MPI_INTEGER,         PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%J_VN,                    1,MPI_INTEGER,         PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%K_VN,                    1,MPI_INTEGER,         PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
   CALL MPI_RECV(MESHES(NOM)%NLP,                     1,MPI_INTEGER,         PROCESS(NOM),1,MPI_COMM_WORLD,STATUS,IERR)
ENDDO

T_USED(11) = T_USED(11) + SECOND() - TNOW
END SUBROUTINE EXCHANGE_DIAGNOSTICS


SUBROUTINE DUMP_GLOBAL_OUTPUTS

! Dump HRR data to CHID_hrr.csv, MASS data to CHID_mass.csv, DEVICE data to _devc.csv

REAL(EB) :: TNOW
INTEGER :: N,CNT
INTEGER :: NM,DISP

TNOW = SECOND()

IF (ANY(EVACUATION_ONLY) .AND. (ICYC<1 .AND. T>T_BEGIN)) RETURN ! No dumps at the evacuation initialization phase

! Dump out HRR info  after first "gathering" data to node 0

DISP = DISPLS(MYID)+1
CNT  = COUNTS(MYID)

IF_DUMP_HRR: IF (T>=HRR_CLOCK) THEN
   IF (N_MPI_PROCESSES>1) THEN
      REAL_BUFFER_11 = Q_DOT_SUM
      CALL MPI_GATHERV(REAL_BUFFER_11(1,DISP),COUNTS_Q_DOT(MYID),MPI_DOUBLE_PRECISION, &
                       Q_DOT_SUM,COUNTS_Q_DOT,DISPLS_Q_DOT,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,IERR)
      REAL_BUFFER_12 = M_DOT_SUM
      CALL MPI_GATHERV(REAL_BUFFER_12(1,DISP),COUNTS_M_DOT(MYID),MPI_DOUBLE_PRECISION, &
                       M_DOT_SUM,COUNTS_M_DOT,DISPLS_M_DOT,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,IERR)
   ENDIF
   !IF (MYID==0) CALL DUMP_HRR(T,DT)
   HRR_CLOCK = HRR_CLOCK + DT_HRR
   Q_DOT_SUM = 0._EB
   M_DOT_SUM = 0._EB
   T_LAST_DUMP_HRR = T
ENDIF IF_DUMP_HRR

! Dump unstructured geometry and boundary element info

IF (N_FACE>0 .AND. T>=GEOM_CLOCK) THEN
   IF (MYID==0) THEN
      !CALL DUMP_GEOM(T)
      IF (GEOM_DIAG) THEN
         !CALL DUMP_GEOM_DIAG(T)
      ENDIF
   ENDIF
   GEOM_CLOCK = GEOM_CLOCK + DT_GEOM
ENDIF

IF (N_GEOM>0 .AND. T>=BNDC_CLOCK) THEN
   IF (MYID==0) CALL DUMP_BNDC(T)
   BNDC_CLOCK = BNDC_CLOCK + DT_BNDC
ENDIF

IF (N_BNDE>0 .AND. T>=BNDE_CLOCK) THEN
   IF (MYID==0) CALL DUMP_BNDE(T)
   BNDE_CLOCK = BNDE_CLOCK + DT_BNDE
ENDIF

! Dump out Evac info

IF (MYID==MAX(0,EVAC_PROCESS)) CALL EVAC_CSV(T)

! Dump out Mass info after first "gathering" data to node 0

IF_DUMP_MASS: IF (T>=MINT_CLOCK) THEN
   IF (N_MPI_PROCESSES>1) THEN
      REAL_BUFFER_5 = MINT_SUM
      CALL MPI_GATHERV(REAL_BUFFER_5(0,DISP),COUNTS_MASS(MYID),MPI_DOUBLE_PRECISION, &
                       MINT_SUM,COUNTS_MASS,DISPLS_MASS,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,IERR)
   ENDIF
   !IF (MYID==0) CALL DUMP_MASS(T,DT)
   MINT_CLOCK = MINT_CLOCK + DT_MASS
   MINT_SUM   = 0._EB
   T_LAST_DUMP_MASS = T
ENDIF IF_DUMP_MASS

! Exchange DEVICE parameters among meshes and dump out DEVICE info after first "gathering" data to node 0

EXCHANGE_DEVICE: IF (N_DEVC>0) THEN

   ! Exchange the CURRENT_STATE and PRIOR_STATE of each DEViCe

   STATE_LOC = .FALSE.  ! _LOC is a temporary array that holds the STATE value for the devices on each node
   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      DO N=1,N_DEVC
         IF (DEVICE(N)%MESH==NM) THEN
            STATE_LOC(N)        = DEVICE(N)%CURRENT_STATE
            STATE_LOC(N+N_DEVC) = DEVICE(N)%PRIOR_STATE
         ENDIF
      ENDDO
   ENDDO
   IF (N_MPI_PROCESSES>1) THEN
      CALL MPI_ALLREDUCE(STATE_LOC(1),STATE_GLB(1),2*N_DEVC,MPI_LOGICAL,MPI_LXOR,MPI_COMM_WORLD,IERR)
   ELSE
      STATE_GLB = STATE_LOC
   ENDIF
   DEVICE(1:N_DEVC)%CURRENT_STATE = STATE_GLB(       1:  N_DEVC)
   DEVICE(1:N_DEVC)%PRIOR_STATE   = STATE_GLB(N_DEVC+1:2*N_DEVC)

   ! Dry pipe sprinkler logic

   DEVC_PIPE_OPERATING = 0
   DO CNT=1,N_DEVC
      IF (DEVICE(CNT)%PROP_INDEX > 0 .AND.  DEVICE(CNT)%CURRENT_STATE) THEN
         IF (PROPERTY(DEVICE(CNT)%PROP_INDEX)%PART_INDEX > 0) DEVC_PIPE_OPERATING(DEVICE(CNT)%PIPE_INDEX) = &
            DEVC_PIPE_OPERATING(DEVICE(CNT)%PIPE_INDEX) + 1
      ENDIF
   ENDDO

   ! Exchange the INSTANT_VALUE, SMOOTHED_VALUE, and T_CHANGE of each DEViCe

   TC_LOC = 0._EB
   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      DO N=1,N_DEVC
         IF (DEVICE(N)%MESH==NM) THEN
            TC_LOC(N)          = DEVICE(N)%INSTANT_VALUE
            TC_LOC(N+N_DEVC)   = DEVICE(N)%SMOOTHED_VALUE
            TC_LOC(N+2*N_DEVC) = DEVICE(N)%T_CHANGE
         ENDIF
      ENDDO
   ENDDO
   IF (N_MPI_PROCESSES>1) THEN
      CALL MPI_ALLREDUCE(TC_LOC(1),TC_GLB(1),3*N_DEVC,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,IERR)
   ELSE
      TC_GLB = TC_LOC
   ENDIF
   DEVICE(1:N_DEVC)%INSTANT_VALUE  = TC_GLB(         1:  N_DEVC)
   DEVICE(1:N_DEVC)%SMOOTHED_VALUE = TC_GLB(  N_DEVC+1:2*N_DEVC)
   DEVICE(1:N_DEVC)%T_CHANGE       = TC_GLB(2*N_DEVC+1:3*N_DEVC)

ENDIF EXCHANGE_DEVICE

! Exchange information about Devices that is only needed at print-out time

IF_DUMP_DEVC: IF (T>=DEVC_CLOCK .AND. N_DEVC>0) THEN

   ! Exchange the current COUNT of each DEViCe

   TI_LOC(1:N_DEVC) = DEVICE(1:N_DEVC)%TIME_INTERVAL
   IF (N_MPI_PROCESSES>1) THEN
      CALL MPI_ALLREDUCE(TI_LOC(1),TI_GLB(1),N_DEVC,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,IERR)
   ELSE
      TI_GLB = TI_LOC
   ENDIF

   ! Get the current VALUEs of all DEViCes into DEVICE(:)%VALUE on node 0

   IF (MINVAL(TI_GLB)>0._EB) THEN
      TC_LOC(1:N_DEVC) = DEVICE(1:N_DEVC)%VALUE
      IF (N_MPI_PROCESSES>1) THEN
         CALL MPI_REDUCE(TC_LOC(1),TC_GLB(1),N_DEVC,MPI_DOUBLE_PRECISION,MPI_SUM,0,MPI_COMM_WORLD,IERR)
      ELSE
         TC_GLB(1:N_DEVC) = TC_LOC(1:N_DEVC)
      ENDIF
      IF (MYID==0) THEN
         DEVICE(1:N_DEVC)%VALUE         = TC_GLB(1:N_DEVC)
         DEVICE(1:N_DEVC)%TIME_INTERVAL = TI_GLB(1:N_DEVC)
         CALL DUMP_DEVICES(T)
      ENDIF
      DEVC_CLOCK = MIN(DEVC_CLOCK + DT_DEVC, T_END)
      DO N=1,N_DEVC
         DEVICE(N)%VALUE = 0._EB
         DEVICE(N)%TIME_INTERVAL = 0._EB
      ENDDO
   ENDIF

ENDIF IF_DUMP_DEVC

! Dump CONTROL info. No gathering required as CONTROL is updated on all meshes

IF (T>=CTRL_CLOCK .AND. N_CTRL>0) THEN
   IF (MYID==0) CALL DUMP_CONTROLS(T)
   CTRL_CLOCK = CTRL_CLOCK + DT_CTRL
ENDIF

! Dump CPU time

IF (T>=CPU_CLOCK) THEN
   CALL DUMP_CPU_TIME
   CPU_CLOCK = CPU_CLOCK + DT_CPU
ENDIF

T_USED(7) = T_USED(7) + SECOND() - TNOW
END SUBROUTINE DUMP_GLOBAL_OUTPUTS


SUBROUTINE INITIALIZE_EVAC

! Initialize evacuation meshes

DO NM=1,NMESHES
   IF (USE_MPI .AND. N_MPI_PROCESSES>1 .AND. MYID==EVAC_PROCESS .AND. .NOT.EVACUATION_ONLY(NM)) THEN
      M=>MESHES(NM)
      !EVACUATION: SOLID, CELL_INDEX, OBST_INDEX_C, OBSTRUCTION are allocated in READ_OBST for the evac process.
      ALLOCATE(M%ZZ(0:M%IBP1,0:M%JBP1,0:M%KBP1,N_TRACKED_SPECIES),STAT=IZERO)
      CALL ChkMemErr('MAIN','Evac ZZ',IZERO)
      M%ZZ=0._EB
      ALLOCATE(M%RHO(0:M%IBP1,0:M%JBP1,0:M%KBP1),STAT=IZERO)
      CALL ChkMemErr('MAIN','Evac RHO',IZERO)
      M%RHO=RHOA
      ALLOCATE(M%RSUM(0:M%IBP1,0:M%JBP1,0:M%KBP1),STAT=IZERO)
      CALL ChkMemErr('MAIN','Evac RSUM',IZERO)
      M%RSUM=RSUM0
      ALLOCATE(M%TMP(0:M%IBP1,0:M%JBP1,0:M%KBP1),STAT=IZERO)
      CALL ChkMemErr('MAIN','Evac TMP',IZERO)
      M%TMP=TMPA
      ALLOCATE(M%UII(0:M%IBP1,0:M%JBP1,0:M%KBP1),STAT=IZERO)
      CALL ChkMemErr('MAIN','Evac UII',IZERO)
      M%UII=4._EB*SIGMA*TMPA4
   ENDIF
   IF (PROCESS(NM)/=MYID) CYCLE
   IF (EVACUATION_ONLY(NM).AND.EMESH_INDEX(NM)>0) PART_CLOCK(NM) = T_EVAC + DT_PART
   IF (MYID/=MAX(0,EVAC_PROCESS)) CYCLE
   IF (ANY(EVACUATION_ONLY)) CALL INITIALIZE_EVACUATION(NM)
   IF (EVACUATION_ONLY(NM).AND.EMESH_INDEX(NM)>0) CALL DUMP_EVAC(T_EVAC,NM)
ENDDO
IF (ANY(EVACUATION_ONLY) .AND. .NOT.RESTART) ICYC = -EVAC_TIME_ITERATIONS
DT_EVAC=DT

END SUBROUTINE INITIALIZE_EVAC

SUBROUTINE INIT_EVAC_DUMPS

! Initialize evacuation dumps

REAL(EB) :: T_TMP

IF (.NOT.ANY(EVACUATION_ONLY)) RETURN ! No evacuation

IF (RESTART) THEN
   T_TMP = T
   T_EVAC_SAVE = T_TMP
ELSE
   T_EVAC  = - EVAC_DT_FLOWFIELD*EVAC_TIME_ITERATIONS + T_BEGIN
   T_EVAC_SAVE = T_EVAC
   T_TMP = T_EVAC
END IF
IF (.NOT.ANY(EVACUATION_SKIP)) RETURN ! No main evacuation meshes
IF ((.NOT.USE_MPI .OR. N_MPI_PROCESSES==1) .OR. (N_MPI_PROCESSES>1 .AND. MYID==EVAC_PROCESS)) &
     CALL INITIALIZE_EVAC_DUMPS(T_TMP,T_EVAC_SAVE)

END SUBROUTINE INIT_EVAC_DUMPS


SUBROUTINE EVAC_CSV(T)

! Dump out Evac info

REAL(EB), INTENT(IN) :: T

IF (T>=EVAC_CLOCK .AND. ANY(EVACUATION_ONLY)) THEN
   CALL DUMP_EVAC_CSV(T)
   EVAC_CLOCK = EVAC_CLOCK + DT_HRR
ENDIF

END SUBROUTINE EVAC_CSV


SUBROUTINE EVAC_EXCHANGE

LOGICAL EXCHANGE_EVACUATION
INTEGER NM, II, IVENT, I, J, EMESH, JJ, N_END

! Fire mesh information ==> Evac meshes

IF (.NOT. ANY(EVACUATION_ONLY)) RETURN
IF (N_MPI_PROCESSES>1 .AND. MYID /= EVAC_PROCESS) CALL EVAC_MESH_EXCHANGE(T_EVAC,T_EVAC_SAVE,I_EVAC,ICYC,EXCHANGE_EVACUATION,1)
IF ((.NOT.USE_MPI .OR. N_MPI_PROCESSES==1) .OR. (N_MPI_PROCESSES>1 .AND. MYID==EVAC_PROCESS)) &
     CALL EVAC_MESH_EXCHANGE(T_EVAC,T_EVAC_SAVE,I_EVAC,ICYC,EXCHANGE_EVACUATION,2)

! Update evacuation devices

DO NM=1,NMESHES
   IF (.NOT.EVACUATION_ONLY(NM).OR.EMESH_INDEX(NM)==0.OR.EVACUATION_SKIP(NM)) CYCLE
   IF (MYID/=MAX(0,EVAC_PROCESS)) CYCLE
   !CALL UPDATE_GLOBAL_OUTPUTS(T,DT,NM)
ENDDO

! Save the evacuation flow fields to the arrays U_EVAC and V_EVAC

N_END = N_EXITS - N_CO_EXITS + N_DOORS
DO NM = 1, NMESHES
   IF (.NOT.EVACUATION_ONLY(NM).OR.EMESH_INDEX(NM)==0.OR.EVACUATION_SKIP(NM)) CYCLE
   IF (MYID /= MAX(0,EVAC_PROCESS)) CYCLE
   II = EVAC_TIME_ITERATIONS / MAXVAL(EMESH_NFIELDS)
   IF (MOD(ABS(ICYC),II)==0) THEN
      IVENT = (ABS(ICYC))/II + 1
      LOOP_EXITS: DO JJ = 1, N_END
         IF (EMESH_EXITS(JJ)%MAINMESH == NM .AND. EMESH_EXITS(JJ)%I_DOORS_EMESH == IVENT) THEN
            EMESH = EMESH_EXITS(JJ)%EMESH
            DO J = 0, EMESH_IJK(2,EMESH) + 1
               DO I = 0, EMESH_IJK(1,EMESH) + 1
                  ! FB is the EFF file precision. Convert to FB here so that EFF read calculation gives
                  ! exactly the same results as EFF write calculation for the agents.
                  IF (MESHES(NM)%PRESSURE_ZONE(I,J,1)>0) THEN
                     EMESH_EXITS(JJ)%U_EVAC(I,J) = REAL(MESHES(NM)%U(I,J,1),FB)
                     EMESH_EXITS(JJ)%V_EVAC(I,J) = REAL(MESHES(NM)%V(I,J,1),FB)
                  ELSE
                     EMESH_EXITS(JJ)%U_EVAC(I,J) = 0.0_FB
                     EMESH_EXITS(JJ)%V_EVAC(I,J) = 0.0_FB
                  END IF
               END DO
            END DO
            EXIT LOOP_EXITS
         END IF
      END DO LOOP_EXITS
   END IF

ENDDO

END SUBROUTINE EVAC_EXCHANGE


SUBROUTINE EVAC_PRESSURE_ITERATION_SCHEME

! Evacuation flow field calculation

INTEGER :: N

COMPUTE_PRESSURE_LOOP: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   IF (EVACUATION_SKIP(NM).OR..NOT.EVACUATION_ONLY(NM)) CYCLE COMPUTE_PRESSURE_LOOP
   PRESSURE_ITERATION_LOOP: DO N=1,EVAC_PRESSURE_ITERATIONS
      !CALL NO_FLUX(DT,NM)
      MESHES(NM)%FVZ = 0._EB
      !CALL PRESSURE_SOLVER(T,NM)
   ENDDO PRESSURE_ITERATION_LOOP
ENDDO COMPUTE_PRESSURE_LOOP

END SUBROUTINE EVAC_PRESSURE_ITERATION_SCHEME


SUBROUTINE EVAC_MAIN_LOOP

! Call the evacuation routine and adjust the time steps for the evacuation meshes

REAL(EB) :: T_FIRE, EVAC_DT, DT_TMP
INTEGER :: II

EVACUATION_SKIP=.FALSE. ! Do not skip the flow calculation

EVAC_DT = EVAC_DT_STEADY_STATE
T_FIRE = T_EVAC + EVAC_DT
IF (ICYC < 1) EVAC_DT = EVAC_DT_FLOWFIELD
IF (ICYC < 1) DT = EVAC_DT
IF (ICYC < 1) DT_NEW = DT_EVAC
IF (ICYC == 1) DT = DT_EVAC ! Initial fire dt that was read in
IF (ICYC == 1) T  = T_BEGIN ! Initial fire t  that was read in
IF (ICYC == 1) T_EVAC = T_BEGIN - 0.1_EB*MIN(EVAC_DT_FLOWFIELD,EVAC_DT_STEADY_STATE)
IF (ICYC > 0) T_FIRE  = T

DT_TMP = DT
IF ((T+DT)>=T_END) DT_TMP = MAX(MIN(EVAC_DT_STEADY_STATE,T_END-T_EVAC),1.E-10_EB)
IF (ICYC > 0) EVAC_DT = DT_TMP

DO NM = 1, NMESHES
   IF (EVACUATION_ONLY(NM).AND.EMESH_INDEX(NM)==0) EVACUATION_SKIP(NM) = .TRUE.
   IF (EVACUATION_ONLY(NM).AND.EMESH_INDEX(NM)>0) DT_NEW(NM) = EVAC_DT
END DO
IF (ICYC <= 0) THEN
   DO NM = 1, NMESHES
      IF (.NOT.EVACUATION_ONLY(NM)) EVACUATION_SKIP(NM) = .TRUE.  ! Be sure that no fire meshes are updated for icyc < 0
   END DO
ENDIF
EVAC_TIME_STEP_LOOP: DO WHILE (T_EVAC < T_FIRE)
   T_EVAC = T_EVAC + EVAC_DT
   IF ((.NOT.USE_MPI .OR. N_MPI_PROCESSES==1) .OR. (N_MPI_PROCESSES>1 .AND. MYID==EVAC_PROCESS)) CALL PREPARE_TO_EVACUATE(ICYC)
   DO NM = 1, NMESHES
      IF (EVACUATION_ONLY(NM)) THEN
         EVACUATION_SKIP(NM)  = .TRUE.
         IF (ICYC <= 1 .AND. .NOT.BTEST(I_EVAC, 2)) THEN
            IF (ICYC <= 0 .AND. EMESH_INDEX(NM)>0) THEN
               II = EVAC_TIME_ITERATIONS / MAXVAL(EMESH_NFIELDS)
               IF ((ABS(ICYC)+1) <= EMESH_NFIELDS(EMESH_INDEX(NM))*II) THEN
                  EVACUATION_SKIP(NM) = .FALSE.
               ELSE
                  EVACUATION_SKIP(NM) = .TRUE.
               END IF
               DIAGNOSTICS = .FALSE.
            END IF
            !
            IF (ICYC <= 0) T = T_EVAC + EVAC_DT_FLOWFIELD*EVAC_TIME_ITERATIONS - EVAC_DT_FLOWFIELD
         ENDIF
         IF (ICYC <= 1 .AND. BTEST(I_EVAC, 2)) THEN
            IF (ICYC <= 0 .AND. EMESH_INDEX(NM)>0) THEN
               EVACUATION_SKIP(NM) = .TRUE.
               DIAGNOSTICS = .FALSE.
            END IF
            IF (ICYC <= 0) T = T_EVAC + EVAC_DT_FLOWFIELD*EVAC_TIME_ITERATIONS - EVAC_DT_FLOWFIELD
         ENDIF
         IF (EMESH_INDEX(NM)==0) THEN
            VELOCITY_ERROR_MAX_LOC(:,NM) = 1
            VELOCITY_ERROR_MAX(NM) = 0._EB
            MESHES(NM)%POIS_ERR = 0.0_EB
            MESHES(NM)%POIS_PTB = 0.0_EB
            MESHES(NM)%RESMAX = 0.0_EB
            MESHES(NM)%CFL = 0.0_EB
            MESHES(NM)%ICFL = 0; MESHES(NM)%JCFL = 0; MESHES(NM)%KCFL = 0
            MESHES(NM)%DIVMX = 0.0_EB
            MESHES(NM)%IMX = 0; MESHES(NM)%JMX = 0; MESHES(NM)%KMX = 0
            MESHES(NM)%DIVMN = 0.0_EB
            MESHES(NM)%IMN = 0; MESHES(NM)%JMN = 0; MESHES(NM)%KMN = 0
         END IF
         IF (EMESH_INDEX(NM)>0) THEN
            IF (PROCESS(NM)==MYID .AND. STOP_STATUS==NO_STOP) CALL EVACUATE_HUMANS(T_EVAC,DT_TMP,NM,ICYC)
            IF (T_EVAC >= PART_CLOCK(NM)) THEN
               IF (PROCESS(NM)==MYID) CALL DUMP_EVAC(T_EVAC, NM)
               DO
                  PART_CLOCK(NM) = PART_CLOCK(NM) + DT_PART
                  IF (PART_CLOCK(NM) >= T_EVAC) EXIT
               ENDDO
            ENDIF
         ENDIF
      ENDIF
   ENDDO
   IF (ICYC < 1) EXIT EVAC_TIME_STEP_LOOP
   IF ((.NOT.USE_MPI .OR. N_MPI_PROCESSES==1) .OR. (N_MPI_PROCESSES>1 .AND. MYID==EVAC_PROCESS)) &
        CALL CLEAN_AFTER_EVACUATE(ICYC, I_EVAC)
ENDDO EVAC_TIME_STEP_LOOP
IF (ICYC < 1 .AND. MYID==0) THEN
   ! Write the diagnostic information for the evacuation mesh initialization time steps
   II = EVAC_TIME_ITERATIONS / MAXVAL(EMESH_NFIELDS)
   IF (MOD(ABS(ICYC)+1,II) == 0 .OR. ABS(ICYC)+1 == EVAC_TIME_ITERATIONS) THEN
      WRITE(LU_ERR,'(1X,A,I7,A,F10.3,A)')  'Time Step:',ICYC,',    Evacuation Initialization Time:',T_EVAC,' s'
   END IF
END IF

END SUBROUTINE EVAC_MAIN_LOOP


SUBROUTINE GET_INFO (REVISION,REVISION_DATE,COMPILE_DATE)
CHARACTER(LEN=255), INTENT(OUT) :: REVISION, REVISION_DATE, COMPILE_DATE

! Unlike svn, the revisioning system git does not perform keyword substitution.
! To perform this function,  a script named expand_file is called before FDS is
! built that expands the following keywords ($Revision, $RevisionDate and
! $CompileDate) with their proper values. Another script named contract_file is
! called after FDS is built to return these keywords back to their original
! values (so the revisioning system will not think this file has changed).

CHARACTER(255), PARAMETER :: GREVISION='$Revision$'
CHARACTER(255), PARAMETER :: GREVISION_DATE='$RevisionDate: unknown $'
CHARACTER(255), PARAMETER :: GCOMPILE_DATE='$CompileDate: unknown $'

WRITE(REVISION,'(A)')      GREVISION(INDEX(GREVISION,':')+2:LEN_TRIM(GREVISION)-2)
WRITE(REVISION_DATE,'(A)') GREVISION_DATE(INDEX(GREVISION_DATE,':')+2:LEN_TRIM(GREVISION_DATE)-2)
WRITE(COMPILE_DATE,'(A)')  GCOMPILE_DATE(INDEX(GCOMPILE_DATE,':')+2:LEN_TRIM(GCOMPILE_DATE)-2)
RETURN
END SUBROUTINE GET_INFO

!----------------------------------------
! Subroutines integrated from init.f90
!----------------------------------------


SUBROUTINE INITIALIZE_MESH_VARIABLES_1(DT,NM)

USE PHYSICAL_FUNCTIONS, ONLY: GET_VISCOSITY,GET_SPECIFIC_GAS_CONSTANT,GET_SPECIFIC_HEAT,LES_FILTER_WIDTH_FUNCTION
USE MEMORY_FUNCTIONS, ONLY: COMPUTE_ONE_D_STORAGE_DIMENSIONS,COMPUTE_PARTICLE_STORAGE_DIMENSIONS,COMPUTE_WALL_STORAGE_DIMENSIONS
USE GEOMETRY_FUNCTIONS, ONLY: ASSIGN_PRESSURE_ZONE
USE RADCONS, ONLY: UIIDIM
USE CONTROL_VARIABLES
USE MATH_FUNCTIONS, ONLY:EVALUATE_RAMP
INTEGER :: N,I,J,K,IW,IC,SURF_INDEX,IOR,IERR,IIG,JJG,KKG,N_OVERLAP,IZERO
REAL(EB), INTENT(IN) :: DT
INTEGER, INTENT(IN) :: NM
REAL(EB) :: MU_N,ZZ_GET(1:N_TRACKED_SPECIES),CS,DELTA,DUMMY,INTEGRAL,TEMP
INTEGER, POINTER :: IBP1, JBP1, KBP1,IBAR, JBAR, KBAR, N_EDGES
INTEGER, TARGET  :: NULL_TARGET=NULL_BOUNDARY,DEFAULT_SURF_INDEX_TARGET=0
REAL(EB),POINTER :: XS,XF,YS,YF,ZS,ZF
TYPE (INITIALIZATION_TYPE), POINTER :: IN=>NULL()
TYPE (P_ZONE_TYPE), POINTER :: PZ=>NULL()
TYPE (VENTS_TYPE), POINTER :: VT=>NULL()
TYPE (OBSTRUCTION_TYPE), POINTER :: OB
TYPE (WALL_TYPE), POINTER :: WC=>NULL()
TYPE (SURFACE_TYPE), POINTER :: SF=>NULL()
TYPE (MESH_TYPE), POINTER :: M
TYPE (RAMPS_TYPE), POINTER :: RP

IERR = 0
M => MESHES(NM)
IBP1 =>M%IBP1
JBP1 =>M%JBP1
KBP1 =>M%KBP1
IBAR =>M%IBAR
JBAR =>M%JBAR
KBAR =>M%KBAR
N_EDGES=>M%N_EDGES
XS=>M%XS
YS=>M%YS
ZS=>M%ZS
XF=>M%XF
YF=>M%YF
ZF=>M%ZF

ALLOCATE(M%EXTERNAL_WALL(M%N_EXTERNAL_WALL_CELLS),STAT=IZERO)
CALL ChkMemErr('INIT','EXTERNAL_WALL',IZERO)

ALLOCATE(M%RHO(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','RHO',IZERO)
ALLOCATE(M%RHOS(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','RHOS',IZERO)
M%RHOS = RHOA
ALLOCATE(M%TMP(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','TMP',IZERO)
ALLOCATE(M%FRHO(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','FRHO',IZERO)
ALLOCATE(M%U(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','U',IZERO)
ALLOCATE(M%V(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','V',IZERO)
ALLOCATE(M%W(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','W',IZERO)
ALLOCATE(M%US(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','US',IZERO)
ALLOCATE(M%VS(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','VS',IZERO)
ALLOCATE(M%WS(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WS',IZERO)
ALLOCATE(M%FVX(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','FVX',IZERO)
ALLOCATE(M%FVY(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','FVY',IZERO)
ALLOCATE(M%FVZ(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','FVZ',IZERO)
ALLOCATE(M%FVX_B(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','FVX_B',IZERO) ; M%FVX_B=0._EB
ALLOCATE(M%FVY_B(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','FVY_B',IZERO) ; M%FVY_B=0._EB
ALLOCATE(M%FVZ_B(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','FVZ_B',IZERO) ; M%FVZ_B=0._EB
ALLOCATE(M%H(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','H',IZERO)
ALLOCATE(M%HS(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','HS',IZERO)
IF (EXTERNAL_BOUNDARY_CORRECTION) THEN
   ALLOCATE(M%H_PRIME(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','H_PRIME',IZERO)
ENDIF
ALLOCATE(M%KRES(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','KRES',IZERO)
ALLOCATE(M%DDDT(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','DDDT',IZERO)
ALLOCATE(M%D(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','D',IZERO)
ALLOCATE(M%DS(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','DS',IZERO)
ALLOCATE(M%MU(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','MU',IZERO)
ALLOCATE(M%MU_DNS(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','MU_DNS',IZERO)
IF (CHECK_VN) THEN
   ALLOCATE(M%D_Z_MAX(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','D_Z_MAX',IZERO)
   M%D_Z_MAX=0._EB
ENDIF
ALLOCATE(M%STRAIN_RATE(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','STRAIN_RATE',IZERO)
M%STRAIN_RATE = 0._EB
ALLOCATE(M%CSD2(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','CS',IZERO)
IF (OUTPUT_CHEM_IT) THEN
   ALLOCATE(M%CHEM_SUBIT(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','CHEM_SUBIT',IZERO)
   M%CHEM_SUBIT = 0._EB
ENDIF
ALLOCATE(M%Q(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','Q',IZERO)

ALLOCATE(M%MIX_TIME(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','MIX_TIME',IZERO)
M%MIX_TIME=DT

! Background pressure, temperature, density as a function of height (Z coordinate)

ALLOCATE(  M%PBAR(0:KBP1,0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','PBAR',IZERO)
ALLOCATE(  M%PBAR_S(0:KBP1,0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','PBAR_S',IZERO)
ALLOCATE(  M%R_PBAR(0:KBP1,0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','R_PBAR',IZERO)
ALLOCATE(  M%D_PBAR_DT(0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','D_PBAR_DT',IZERO)
ALLOCATE(  M%D_PBAR_DT_S(0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','D_PBAR_DT_S',IZERO)
ALLOCATE(M%P_0(0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','P_0',IZERO)
ALLOCATE(M%TMP_0(0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','TMP_0',IZERO)
ALLOCATE(M%RHO_0(0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','RHO_0',IZERO)

! Leaks

ALLOCATE(  M%U_LEAK(0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','U_LEAK',IZERO)
M%U_LEAK = 0._EB

! Allocate species arrays

IF (.NOT.EVACUATION_ONLY(NM)) THEN
   ALLOCATE( M%ZZ(0:IBP1,0:JBP1,0:KBP1,N_TOTAL_SCALARS),STAT=IZERO)
   CALL ChkMemErr('INIT','ZZ',IZERO)
   M%ZZ = 0._EB
   ALLOCATE(M%ZZS(0:IBP1,0:JBP1,0:KBP1,N_TOTAL_SCALARS),STAT=IZERO)
   CALL ChkMemErr('INIT','ZZS',IZERO)
   M%ZZS = 0._EB
   ALLOCATE(M%DEL_RHO_D_DEL_Z(0:IBP1,0:JBP1,0:KBP1,N_TOTAL_SCALARS),STAT=IZERO)
   CALL ChkMemErr('INIT','DEL_RHO_D_DEL_Z',IZERO)
   M%DEL_RHO_D_DEL_Z = 0._EB
   IF (REAC_SOURCE_CHECK) THEN
      ALLOCATE( M%REAC_SOURCE_TERM(0:IBP1,0:JBP1,0:KBP1,N_TRACKED_SPECIES),STAT=IZERO)
      CALL ChkMemErr('INIT','REAC_SOURCE_TERM',IZERO)
      M%REAC_SOURCE_TERM = 0._EB
      ALLOCATE( M%Q_REAC(0:IBP1,0:JBP1,0:KBP1,N_REACTIONS),STAT=IZERO)
      CALL ChkMemErr('INIT','Q_REAC',IZERO)
      M%Q_REAC = 0._EB
   ENDIF
   IF (TRANSPORT_UNMIXED_FRACTION .AND. COMPUTE_ZETA_SOURCE_TERM) THEN
      ALLOCATE( M%ZETA_SOURCE_TERM(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
      CALL ChkMemErr('INIT','ZETA_SOURCE_TERM',IZERO)
      M%ZETA_SOURCE_TERM = 0._EB
   ENDIF
ENDIF

ALLOCATE(M%RSUM(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','RSUM',IZERO)
M%RSUM = RSUM0

! Allocate scalar face values

ALLOCATE( M%FX(0:IBP1,0:JBP1,0:KBP1,1:N_TOTAL_SCALARS),STAT=IZERO)
CALL ChkMemErr('INIT','FX',IZERO)
ALLOCATE( M%FY(0:IBP1,0:JBP1,0:KBP1,1:N_TOTAL_SCALARS),STAT=IZERO)
CALL ChkMemErr('INIT','FY',IZERO)
ALLOCATE( M%FZ(0:IBP1,0:JBP1,0:KBP1,1:N_TOTAL_SCALARS),STAT=IZERO)
CALL ChkMemErr('INIT','FZ',IZERO)
M%FX = 0._EB
M%FY = 0._EB
M%FZ = 0._EB

! Allocate water mass arrays if sprinklers are present

IF (PARTICLE_FILE) PARTICLE_TAG = NM

IF (N_LAGRANGIAN_CLASSES >0 .AND. .NOT. EVACUATION_ONLY(NM)) THEN
   ALLOCATE(M%AVG_DROP_DEN_ALL(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','AVG_DROP_DEN_ALL',IZERO)
   M%AVG_DROP_DEN_ALL=0._EB
ENDIF

IF (N_LP_ARRAY_INDICES>0 .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   ALLOCATE(M%QR_W(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','QR_W',IZERO)
   M%QR_W = 0._EB
   ALLOCATE(M%AVG_DROP_DEN(0:IBP1,0:JBP1,0:KBP1,N_LP_ARRAY_INDICES),STAT=IZERO)
   CALL ChkMemErr('INIT','AVG_DROP_DEN',IZERO)
   M%AVG_DROP_DEN=0._EB
   ALLOCATE(M%AVG_DROP_AREA(0:IBP1,0:JBP1,0:KBP1,N_LP_ARRAY_INDICES),STAT=IZERO)
   CALL ChkMemErr('INIT','AVG_DROP_AREA',IZERO)
   M%AVG_DROP_AREA=0._EB
   ALLOCATE(M%AVG_DROP_TMP(0:IBP1,0:JBP1,0:KBP1,N_LP_ARRAY_INDICES),STAT=IZERO)
   CALL ChkMemErr('INIT','AVG_DROP_TMP',IZERO)
   M%AVG_DROP_TMP=TMPM
   ALLOCATE(M%AVG_DROP_RAD(0:IBP1,0:JBP1,0:KBP1,N_LP_ARRAY_INDICES),STAT=IZERO)
   CALL ChkMemErr('INIT','AVG_DROP_RAD',IZERO)
   M%AVG_DROP_RAD=0._EB
ENDIF

IF (N_LP_ARRAY_INDICES>0 .OR. N_REACTIONS>0 .OR. ANY(SPECIES_MIXTURE%DEPOSITING)) THEN
   ALLOCATE(M%D_SOURCE(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','D_SOURCE',IZERO)
   M%D_SOURCE = 0._EB
   ALLOCATE(M%M_DOT_PPP(0:IBP1,0:JBP1,0:KBP1,1:N_TRACKED_SPECIES),STAT=IZERO)
   CALL ChkMemErr('INIT','M_DOT_PPP',IZERO)
   M%M_DOT_PPP=0._EB
ENDIF

! Allocate unstructured geometry divergence

IF (N_FACE > 0) THEN
   ALLOCATE(M%D_GEOMETRY(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','D_GEOMETRY',IZERO)
   M%D_GEOMETRY = 0._EB
ENDIF

! If radiation absorption desired allocate arrays

IF (.NOT.EVACUATION_ONLY(NM)) THEN
   ALLOCATE(M%CHI_R(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','QR',IZERO)
   M%CHI_R = 0._EB
   ALLOCATE(M%QR(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','QR',IZERO)
   M%QR = 0._EB
   ALLOCATE(M%KAPPA(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','KAPPA',IZERO)
   M%KAPPA = KAPPA0
   ALLOCATE(M%UII(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','UII',IZERO)
   M%UII = 0._EB
ELSE
   ALLOCATE(M%QR(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','QR',IZERO)
   M%QR = 0._EB
ENDIF

! Work arrays

ALLOCATE(M%WORK1(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK1',IZERO)
ALLOCATE(M%WORK2(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK2',IZERO)
ALLOCATE(M%WORK3(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK3',IZERO)
ALLOCATE(M%WORK4(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK4',IZERO)
ALLOCATE(M%WORK5(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK5',IZERO)
ALLOCATE(M%WORK6(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK6',IZERO)
ALLOCATE(M%WORK7(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK7',IZERO)
ALLOCATE(M%WORK8(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK8',IZERO)
ALLOCATE(M%WORK9(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK9',IZERO)

ALLOCATE(M%IWORK1(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','IWORK1',IZERO)
ALLOCATE(M%SCALAR_WORK1(0:IBP1,0:JBP1,0:KBP1,1:N_TOTAL_SCALARS),STAT=IZERO)
CALL ChkMemErr('INIT','SCALAR_WORK1',IZERO)
ALLOCATE(M%SCALAR_WORK2(0:IBP1,0:JBP1,0:KBP1,1:N_TOTAL_SCALARS),STAT=IZERO)
CALL ChkMemErr('INIT','SCALAR_WORK2',IZERO)
ALLOCATE(M%SCALAR_WORK3(0:IBP1,0:JBP1,0:KBP1,1:N_TOTAL_SCALARS),STAT=IZERO)
CALL ChkMemErr('INIT','SCALAR_WORK3',IZERO)
ALLOCATE(M%SCALAR_WORK4(0:IBP1,0:JBP1,0:KBP1,1:N_TOTAL_SCALARS),STAT=IZERO)
CALL ChkMemErr('INIT','SCALAR_WORK4',IZERO)
M%IWORK1=0
M%SCALAR_WORK1=0._EB
M%SCALAR_WORK2=0._EB
M%SCALAR_WORK3=0._EB
M%SCALAR_WORK4=0._EB

! Boundary file patch counter

ALLOCATE(M%INC(-3:3,0:M%N_OBST),STAT=IZERO)
CALL ChkMemErr('INIT','INC',IZERO)

! Initialize background temperature and pressure

M%D_PBAR_DT   = 0._EB
M%D_PBAR_DT_S = 0._EB

IF (STRATIFICATION .AND. .NOT.EVACUATION_ONLY(NM)) THEN

   ! Compute the atmospheric pressure profile ramp using the specified temperature ramp

   RP => RAMPS(I_RAMP_P0_Z)
   INTEGRAL = 0._EB
   DO K=0,RP%NUMBER_INTERPOLATION_POINTS+1
      TEMP = TMPA*RAMPS(I_RAMP_TMP0_Z)%INTERPOLATED_DATA(K)
      INTEGRAL = INTEGRAL + (GVEC(3)/(RSUM0*TEMP))/RP%RDT
      RP%INTERPOLATED_DATA(K) = P_INF *EXP(INTEGRAL)
   ENDDO

   ! Populate the cell-centered background temperature and pressure

   DO K=0,M%KBP1
      M%TMP_0(K) = TMPA*EVALUATE_RAMP(M%ZC(K),DUMMY,I_RAMP_TMP0_Z)
      M%P_0(K)   = EVALUATE_RAMP(M%ZC(K),DUMMY,I_RAMP_P0_Z)
   ENDDO

ELSE

   M%TMP_0(:) = TMPA
   M%P_0(:)   = P_INF

ENDIF

! Initialize pressure and density of pressure zones

DO K=0,M%KBP1
   M%PBAR(K,:)   = M%P_0(K)
   M%PBAR_S(K,:) = M%P_0(K)
   M%RHO_0(K)    = M%P_0(K)/(M%TMP_0(K)*RSUM0)
ENDDO

! Initialize various time step variables

DT_INITIAL = DT

! Initialize major arrays

DO K=0,M%KBP1
   M%RHO(:,:,K) = M%RHO_0(K)
   M%TMP(:,:,K) = M%TMP_0(K)
   M%U(:,:,K)   = U0*EVALUATE_RAMP(T_BEGIN,DUMMY,I_RAMP_U0_T)*EVALUATE_RAMP(M%ZC(K),DUMMY,I_RAMP_U0_Z)
   M%V(:,:,K)   = V0*EVALUATE_RAMP(T_BEGIN,DUMMY,I_RAMP_V0_T)*EVALUATE_RAMP(M%ZC(K),DUMMY,I_RAMP_V0_Z)
   M%W(:,:,K)   = W0*EVALUATE_RAMP(T_BEGIN,DUMMY,I_RAMP_W0_T)*EVALUATE_RAMP(M%ZC(K),DUMMY,I_RAMP_W0_Z)
ENDDO

IF (ANY(MEAN_FORCING)) THEN
   DO K=0,M%KBP1
      DO J=0,M%JBP1
         DO I=0,M%IBAR
            IF ( .NOT.(M%MEAN_FORCING_CELL(I,J,K) .AND. M%MEAN_FORCING_CELL(I+1,J,K)) ) M%U(I,J,K)=0._EB
         ENDDO
      ENDDO
   ENDDO
   DO K=0,M%KBP1
      DO J=0,M%JBAR
         DO I=0,M%IBP1
            IF ( .NOT.(M%MEAN_FORCING_CELL(I,J,K) .AND.  M%MEAN_FORCING_CELL(I,J+1,K)) ) M%V(I,J,K)=0._EB
         ENDDO
      ENDDO
   ENDDO
   DO K=0,M%KBAR
      DO J=0,M%JBP1
         DO I=0,M%IBP1
            IF ( .NOT.(M%MEAN_FORCING_CELL(I,J,K) .AND.  M%MEAN_FORCING_CELL(I,J,K+1)) ) M%W(I,J,K)=0._EB
         ENDDO
      ENDDO
   ENDDO
ENDIF

M%US    = M%U
M%VS    = M%V
M%WS    = M%W
M%FRHO  = 0._EB
M%FVX   = 0._EB
M%FVY   = 0._EB
M%FVZ   = 0._EB
M%H     = H0
M%HS    = H0
M%KRES  = 0._EB
IF (EXTERNAL_BOUNDARY_CORRECTION) M%H_PRIME=0._EB

M%DDDT  = 0._EB
M%D     = 0._EB
M%DS    = 0._EB
M%Q  = 0._EB
IF (EVACUATION_ONLY(NM)) THEN
   M%U  = 0._EB
   M%V  = 0._EB
   M%W  = 0._EB
   M%US = 0._EB
   M%VS = 0._EB
   M%WS = 0._EB
   M%H  = 0._EB
   M%HS = 0._EB
ENDIF

! Viscosity

ZZ_GET(1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
CALL GET_VISCOSITY(ZZ_GET,MU_N,TMPA)
M%MU = MU_N

CS = C_SMAGORINSKY
IF (EVACUATION_ONLY(NM)) CS=0.9_EB
DO K=0,KBP1
   DO J=0,JBP1
      DO I=0,IBP1
         DELTA = LES_FILTER_WIDTH_FUNCTION(M%DX(I),M%DY(J),M%DZ(K))
         M%CSD2(I,J,K) = (CS*DELTA)**2
      ENDDO
   ENDDO
ENDDO

! Initialize mass fraction arrays

IF (.NOT.EVACUATION_ONLY(NM)) THEN
   DO N=1,N_TRACKED_SPECIES
      M%ZZ(:,:,:,N)  = SPECIES_MIXTURE(N)%ZZ0
      M%ZZS(:,:,:,N) = SPECIES_MIXTURE(N)%ZZ0
   ENDDO
   DO N=N_TRACKED_SPECIES+1,N_TOTAL_SCALARS
      M%ZZ(:,:,:,N)  = INITIAL_UNMIXED_FRACTION
      M%ZZS(:,:,:,N) = INITIAL_UNMIXED_FRACTION
   ENDDO
ENDIF

! Initialize pressure ZONEs

ALLOCATE(M%PRESSURE_ZONE(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','PRESSURE_ZONE',IZERO)
M%PRESSURE_ZONE = 0
ZONE_LOOP: DO N=1,N_ZONE
   PZ => P_ZONE(N)
   IF (EVACUATION_ONLY(NM) .OR. PZ%EVACUATION) CYCLE ZONE_LOOP
   DO K=0,KBP1
      DO J=0,JBP1
         DO I=0,IBP1
            IF (M%PRESSURE_ZONE(I,J,K)==N) CYCLE
            IF (M%XC(I) > PZ%X1 .AND. M%XC(I) < PZ%X2 .AND. &
                M%YC(J) > PZ%Y1 .AND. M%YC(J) < PZ%Y2 .AND. &
                M%ZC(K) > PZ%Z1 .AND. M%ZC(K) < PZ%Z2) THEN
                IF (.NOT.M%SOLID(M%CELL_INDEX(I,J,K)) .AND. M%PRESSURE_ZONE(I,J,K)>0) THEN
                   WRITE(LU_ERR,'(A,I2,A,I2)') 'ERROR: ZONE ',N,' overlaps ZONE ',M%PRESSURE_ZONE(I,J,K)
                   STOP_STATUS = SETUP_STOP
                   RETURN
                ENDIF
                M%PRESSURE_ZONE(I,J,K) = N
                IF (.NOT.M%SOLID(M%CELL_INDEX(I,J,K))) THEN
                   CALL ASSIGN_PRESSURE_ZONE(NM,M%XC(I),M%YC(J),M%ZC(K),N,N_OVERLAP)
                   IF (N_OVERLAP>0) THEN
                      WRITE(LU_ERR,'(A,I2,A,I2)') 'ERROR: ZONE ',N,' overlaps ZONE ',N_OVERLAP
                      STOP_STATUS = SETUP_STOP
                      RETURN
                   ENDIF
                ENDIF
            ENDIF
         ENDDO
      ENDDO
   ENDDO
ENDDO ZONE_LOOP
EVACUATION_ZONE_LOOP: DO N=1,N_ZONE
   PZ => P_ZONE(N)
   IF (.NOT.PZ%EVACUATION .OR. .NOT.EVACUATION_ONLY(NM)) CYCLE EVACUATION_ZONE_LOOP
   IF (.NOT.EVACUATION_SKIP(NM)) CYCLE EVACUATION_ZONE_LOOP
   IF (.NOT.  PZ%MESH_INDEX == NM) CYCLE EVACUATION_ZONE_LOOP
   DO K=0,KBP1
      DO J=0,JBP1
         DO I=0,IBP1
            IF (M%PRESSURE_ZONE(I,J,K)==N) CYCLE
            IF (M%XC(I) - PZ%X1 >=0._EB .AND. M%XC(I) < PZ%X2 .AND. &
                M%YC(J) - PZ%Y1 >=0._EB .AND. M%YC(J) < PZ%Y2 .AND. &
                M%ZC(K) - PZ%Z1 >=0._EB .AND. M%ZC(K) < PZ%Z2) THEN
                M%PRESSURE_ZONE(I,J,K) = N
                IF (.NOT.M%SOLID(M%CELL_INDEX(I,J,K))) CALL ASSIGN_PRESSURE_ZONE(NM,M%XC(I),M%YC(J),M%ZC(K),N,N_OVERLAP)
            ENDIF
         ENDDO
      ENDDO
   ENDDO
ENDDO EVACUATION_ZONE_LOOP

! Allocate local auto-ignition temperature

IF (REIGNITION_MODEL) THEN
   ALLOCATE(M%AIT(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','AIT',IZERO)
   M%AIT = 1.E20_EB
ENDIF

! Over-ride default ambient conditions with user-prescribed INITializations

DO N=1,N_INIT
   IF (EVACUATION_ONLY(NM)) CYCLE
   IN => INITIALIZATION(N)
   DO K=0,KBP1
      DO J=0,JBP1
         DO I=0,IBP1
            IF (M%XC(I) > IN%X1 .AND. M%XC(I) < IN%X2 .AND. &
                M%YC(J) > IN%Y1 .AND. M%YC(J) < IN%Y2 .AND. &
                M%ZC(K) > IN%Z1 .AND. M%ZC(K) < IN%Z2) THEN
               M%TMP(I,J,K)            = IN%TEMPERATURE
               M%RHO(I,J,K)            = IN%DENSITY
               M%ZZ(I,J,K,1:N_TRACKED_SPECIES) = IN%MASS_FRACTION(1:N_TRACKED_SPECIES)
               IF (IN%ADJUST_DENSITY)     M%RHO(I,J,K) = M%RHO(I,J,K)*M%P_0(K)/P_INF
               IF (IN%ADJUST_TEMPERATURE) M%TMP(I,J,K) = M%TMP(I,J,K)*M%P_0(K)/P_INF
               M%Q(I,J,K) = IN%HRRPUV
               IF (REIGNITION_MODEL) M%AIT(I,J,K) = IN%AIT
            ENDIF
         ENDDO
      ENDDO
   ENDDO
ENDDO

! Compute molecular weight term RSUM=R0*SUM(Y_i/M_i)

IF (.NOT.EVACUATION_ONLY(NM)) THEN
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            ZZ_GET(1:N_TRACKED_SPECIES) = M%ZZ(I,J,K,1:N_TRACKED_SPECIES)
            CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,M%RSUM(I,J,K))
         ENDDO
      ENDDO
   ENDDO
ENDIF

! Allocate and Initialize Mesh-Dependent Radiation Arrays

M%QR    = 0._EB
IF (.NOT.EVACUATION_ONLY(NM)) THEN
   M%KAPPA = KAPPA0
   M%UII   = 4._EB*SIGMA*TMPA4
ENDIF
M%ANGLE_INC_COUNTER = 0
M%RAD_CALL_COUNTER  = 0
IF (RADIATION .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   ALLOCATE(M%UIID(0:M%IBP1,0:M%JBP1,0:M%KBP1,1:UIIDIM),STAT=IZERO)
   CALL ChkMemErr('INIT','UIID',IZERO)
   M%UIID = 4._EB*SIGMA*TMPA4/REAL(UIIDIM,EB)
ENDIF

! General work arrays

M%WORK1 = 0._EB
M%WORK2 = 0._EB
M%WORK3 = 0._EB
M%WORK4 = 0._EB
M%WORK5 = 0._EB
M%WORK6 = 0._EB
IF (.NOT.EVACUATION_ONLY(NM)) M%WORK7 = 0._EB

! Immersed Boundary Method

IF (N_FACE>0) THEN
   ALLOCATE(M%U_MASK(0:M%IBP1,0:M%JBP1,0:M%KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','U_MASK',IZERO)
   ALLOCATE(M%V_MASK(0:M%IBP1,0:M%JBP1,0:M%KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','V_MASK',IZERO)
   ALLOCATE(M%W_MASK(0:M%IBP1,0:M%JBP1,0:M%KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','W_MASK',IZERO)
   ALLOCATE(M%P_MASK(0:M%IBP1,0:M%JBP1,0:M%KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','P_MASK',IZERO)
   M%U_MASK=1
   M%V_MASK=1
   M%W_MASK=1
   M%P_MASK=1
ENDIF

! Allocate ONE_D data storage array and compute the dimensions of its components

ALLOCATE(M%WALL_STORAGE(0:N_SURF))

DO N=0,N_SURF
   CALL COMPUTE_ONE_D_STORAGE_DIMENSIONS(N)
   CALL COMPUTE_WALL_STORAGE_DIMENSIONS(N)
ENDDO

! Allocate lagrangian particle storage array and compute the dimensions of its components

M%NLP = 0
M%NLPDIM = 1000
IF (PARTICLE_FILE .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   ALLOCATE(M%LAGRANGIAN_PARTICLE(M%NLPDIM),STAT=IZERO)
   CALL ChkMemErr('INIT','PARTICLE',IZERO)
   ALLOCATE(M%PARTICLE_STORAGE(N_LAGRANGIAN_CLASSES))
   DO N=1,N_LAGRANGIAN_CLASSES
      CALL COMPUTE_PARTICLE_STORAGE_DIMENSIONS(N)
   ENDDO
ENDIF

! Allocate wall cell arrays. This array will grow as needed.

M%N_WALL_CELLS_DIM = 1000

ALLOCATE(M%WALL(0:M%N_WALL_CELLS_DIM),STAT=IZERO)
CALL ChkMemErr('INIT','WALL',IZERO)

M%WALL(0)%BOUNDARY_TYPE => NULL_TARGET
M%WALL(0)%SURF_INDEX    => DEFAULT_SURF_INDEX_TARGET

! Allocate arrays that are dimensioned by the number of external wall cells

NOT_EVAC_IF_1: IF (.NOT.EVACUATION_ONLY(NM)) THEN

   ALLOCATE(M%D_CORR(M%N_EXTERNAL_WALL_CELLS),STAT=IZERO)
   CALL ChkMemErr('INIT','D_CORR',IZERO)
   ALLOCATE(M%DS_CORR(M%N_EXTERNAL_WALL_CELLS),STAT=IZERO)
   CALL ChkMemErr('INIT','DS_CORR',IZERO)
   M%D_CORR = 0._EB
   M%DS_CORR = 0._EB
   ALLOCATE(M%UVW_SAVE(M%N_EXTERNAL_WALL_CELLS),STAT=IZERO)
   CALL ChkMemErr('INIT','UVW_SAVE',IZERO)
   M%UVW_SAVE = 0._EB

   ALLOCATE(M%U_GHOST(M%N_EXTERNAL_WALL_CELLS),STAT=IZERO)
   CALL ChkMemErr('INIT','U_GHOST',IZERO)
   ALLOCATE(M%V_GHOST(M%N_EXTERNAL_WALL_CELLS),STAT=IZERO)
   CALL ChkMemErr('INIT','V_GHOST',IZERO)
   ALLOCATE(M%W_GHOST(M%N_EXTERNAL_WALL_CELLS),STAT=IZERO)
   CALL ChkMemErr('INIT','W_GHOST',IZERO)
   M%U_GHOST = 0._EB
   M%V_GHOST = 0._EB
   M%W_GHOST = 0._EB

ENDIF NOT_EVAC_IF_1

! Allocate arrays for turbulent inflow boundary conditions (experimental)

VENT_LOOP: DO N=1,M%N_VENT
   VT => M%VENTS(N)
   EDDY_IF: IF (VT%N_EDDY>0) THEN
      SELECT CASE(ABS(VT%IOR))
         CASE(1)
            ALLOCATE(VT%U_EDDY(VT%J1+1:VT%J2,VT%K1+1:VT%K2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','U_EDDY',IZERO)
            ALLOCATE(VT%V_EDDY(VT%J1+1:VT%J2,VT%K1+1:VT%K2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','V_EDDY',IZERO)
            ALLOCATE(VT%W_EDDY(VT%J1+1:VT%J2,VT%K1+1:VT%K2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','W_EDDY',IZERO)
         CASE(2)
            ALLOCATE(VT%U_EDDY(VT%I1+1:VT%I2,VT%K1+1:VT%K2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','U_EDDY',IZERO)
            ALLOCATE(VT%V_EDDY(VT%I1+1:VT%I2,VT%K1+1:VT%K2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','V_EDDY',IZERO)
            ALLOCATE(VT%W_EDDY(VT%I1+1:VT%I2,VT%K1+1:VT%K2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','W_EDDY',IZERO)
         CASE(3)
            ALLOCATE(VT%U_EDDY(VT%I1+1:VT%I2,VT%J1+1:VT%J2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','U_EDDY',IZERO)
            ALLOCATE(VT%V_EDDY(VT%I1+1:VT%I2,VT%J1+1:VT%J2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','V_EDDY',IZERO)
            ALLOCATE(VT%W_EDDY(VT%I1+1:VT%I2,VT%J1+1:VT%J2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','W_EDDY',IZERO)
      END SELECT
      ALLOCATE(VT%X_EDDY(VT%N_EDDY),STAT=IZERO)
      CALL ChkMemErr('READ_VENT','X_EDDY',IZERO)
      ALLOCATE(VT%Y_EDDY(VT%N_EDDY),STAT=IZERO)
      CALL ChkMemErr('READ_VENT','Y_EDDY',IZERO)
      ALLOCATE(VT%Z_EDDY(VT%N_EDDY),STAT=IZERO)
      CALL ChkMemErr('READ_VENT','Z_EDDY',IZERO)
      ALLOCATE(VT%CU_EDDY(VT%N_EDDY),STAT=IZERO)
      CALL ChkMemErr('READ_VENT','CU_EDDY',IZERO)
      ALLOCATE(VT%CV_EDDY(VT%N_EDDY),STAT=IZERO)
      CALL ChkMemErr('READ_VENT','CV_EDDY',IZERO)
      ALLOCATE(VT%CW_EDDY(VT%N_EDDY),STAT=IZERO)
      CALL ChkMemErr('READ_VENT','CW_EDDY',IZERO)
      VT%U_EDDY=0._EB
      VT%V_EDDY=0._EB
      VT%W_EDDY=0._EB
      VT%X_EDDY=0._EB
      VT%Y_EDDY=0._EB
      VT%Z_EDDY=0._EB
      VT%CU_EDDY=0._EB
      VT%CV_EDDY=0._EB
      VT%CW_EDDY=0._EB
   ENDIF EDDY_IF
ENDDO VENT_LOOP

! Allocate wall and edge index arrays

ALLOCATE(M%WALL_INDEX(0:CELL_COUNT(NM),-3:3),STAT=IZERO)
CALL ChkMemErr('INIT','WALL_INDEX',IZERO)
M%WALL_INDEX = 0

ALLOCATE(M%EDGE_INDEX(1:12,0:CELL_COUNT(NM)),STAT=IZERO)
CALL ChkMemErr('INIT','EDGE_INDEX',IZERO)
M%EDGE_INDEX = 0

ALLOCATE(M%UVW_GHOST(0:CELL_COUNT(NM),3),STAT=IZERO)
CALL ChkMemErr('INIT','UVW_GHOST',IZERO)
M%UVW_GHOST(:,1)=U0
M%UVW_GHOST(:,2)=V0
M%UVW_GHOST(:,3)=W0

! Vegetation surface drag

ALLOCATE(M%VEG_DRAG(0:IBP1,0:JBP1),STAT=IZERO)
CALL ChkMemErr('INIT','VEG_DRAG',IZERO)
M%VEG_DRAG = 0._EB

! Set up WALL for external boundaries of the current mesh

M%N_WALL_CELLS = 0

DO IOR=1,-1,-2
   IF (IOR== 1) I = 0
   IF (IOR==-1) I = IBP1
   DO K=1,KBAR
      DO J=1,JBAR
         M%N_WALL_CELLS = M%N_WALL_CELLS + 1
         CALL INIT_WALL_CELL(NM,I,J,K,0,M%N_WALL_CELLS,IOR,DEFAULT_SURF_INDEX,IERR,T_BEGIN) ; IF (IERR>0) RETURN
      ENDDO
   ENDDO
ENDDO

DO IOR=2,-2,-4
   IF (IOR== 2) J = 0
   IF (IOR==-2) J = JBP1
   DO K=1,KBAR
      DO I=1,IBAR
         M%N_WALL_CELLS = M%N_WALL_CELLS + 1
         CALL INIT_WALL_CELL(NM,I,J,K,0,M%N_WALL_CELLS,IOR,DEFAULT_SURF_INDEX,IERR,T_BEGIN) ; IF (IERR>0) RETURN
      ENDDO
   ENDDO
ENDDO

NOT_EVAC_IF_2: IF (.NOT.EVACUATION_ONLY(NM)) THEN
DO IOR=3,-3,-6
   IF (IOR== 3) K = 0
   IF (IOR==-3) K = KBP1
   DO J=1,JBAR
      DO I=1,IBAR
         M%N_WALL_CELLS = M%N_WALL_CELLS + 1
         CALL INIT_WALL_CELL(NM,I,J,K,0,M%N_WALL_CELLS,IOR,DEFAULT_SURF_INDEX,IERR,T_BEGIN) ; IF (IERR>0) RETURN
      ENDDO
   ENDDO
ENDDO
ENDIF NOT_EVAC_IF_2

! Go through all obstructions and decide which cell faces ought to be given a wall cell index and initialized

M%N_INTERNAL_WALL_CELLS = 0

OBST_LOOP_2: DO N=1,M%N_OBST
   OB=>M%OBSTRUCTION(N)

   DO K=OB%K1+1,OB%K2
      DO J=OB%J1+1,OB%J2
         I = OB%I1+1
         ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IF (I==1 .AND. .NOT.OB%HT3D) CYCLE
         IC = M%CELL_INDEX(I-1,J,K)
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE .AND. .NOT.OB%HT3D) CYCLE ! Permanently covered face
         IOR = -1
         SURF_INDEX = OB%SURF_INDEX(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS + 1
            M%N_WALL_CELLS = M%N_EXTERNAL_WALL_CELLS + M%N_INTERNAL_WALL_CELLS
            IW  = M%N_WALL_CELLS
         ELSE
            IF (.NOT.OB%OVERLAY .OR. OB%HIDDEN .OR. M%WALL(IW)%SURF_INDEX==SURF_INDEX) CYCLE
            M%WALL(IW)%WALL_INDEX = 0
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,SURF_INDEX,IERR,T_BEGIN)
         IF (IERR>0) RETURN
      ENDDO
   ENDDO

   DO K=OB%K1+1,OB%K2
      DO J=OB%J1+1,OB%J2
         I = OB%I2
         ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IF (I==M%IBAR .AND. .NOT.OB%HT3D) CYCLE
         IC = M%CELL_INDEX(I+1,J,K)
         ! Permanently covered face
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE .AND. .NOT.OB%HT3D) CYCLE
         IOR = 1
         SURF_INDEX = OB%SURF_INDEX(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS + 1
            M%N_WALL_CELLS = M%N_EXTERNAL_WALL_CELLS + M%N_INTERNAL_WALL_CELLS
            IW  = M%N_WALL_CELLS
         ELSE
            IF (.NOT.OB%OVERLAY .OR. OB%HIDDEN .OR. M%WALL(IW)%SURF_INDEX==SURF_INDEX) CYCLE
            M%WALL(IW)%WALL_INDEX = 0
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,SURF_INDEX,IERR,T_BEGIN)
         IF (IERR>0) RETURN
      ENDDO
   ENDDO

   DO K=OB%K1+1,OB%K2
      DO I=OB%I1+1,OB%I2
         J = OB%J1+1
         ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IF (J==1 .AND. .NOT.OB%HT3D) CYCLE
         IC = M%CELL_INDEX(I,J-1,K)
         ! Permanently covered face
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE .AND. .NOT.OB%HT3D) CYCLE
         IOR = -2
         SURF_INDEX = OB%SURF_INDEX(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS + 1
            M%N_WALL_CELLS = M%N_EXTERNAL_WALL_CELLS + M%N_INTERNAL_WALL_CELLS
            IW  = M%N_WALL_CELLS
         ELSE
            IF (.NOT.OB%OVERLAY .OR. OB%HIDDEN .OR. M%WALL(IW)%SURF_INDEX==SURF_INDEX) CYCLE
            M%WALL(IW)%WALL_INDEX = 0
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,SURF_INDEX,IERR,T_BEGIN)
         IF (IERR>0) RETURN
      ENDDO
   ENDDO

   DO K=OB%K1+1,OB%K2
      DO I=OB%I1+1,OB%I2
         J = OB%J2
         ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IF (J==M%JBAR .AND. .NOT.OB%HT3D) CYCLE
         IC = M%CELL_INDEX(I,J+1,K)
         ! Permanently covered face
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE .AND. .NOT.OB%HT3D) CYCLE
         IOR = 2
         SURF_INDEX = OB%SURF_INDEX(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS + 1
            M%N_WALL_CELLS = M%N_EXTERNAL_WALL_CELLS + M%N_INTERNAL_WALL_CELLS
            IW  = M%N_WALL_CELLS
         ELSE
            IF (.NOT.OB%OVERLAY .OR. OB%HIDDEN .OR. M%WALL(IW)%SURF_INDEX==SURF_INDEX) CYCLE
            M%WALL(IW)%WALL_INDEX = 0
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,SURF_INDEX,IERR,T_BEGIN)
         IF (IERR>0) RETURN
      ENDDO
   ENDDO

   DO J=OB%J1+1,OB%J2
      DO I=OB%I1+1,OB%I2
         K = OB%K1+1
         ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IF (K==1 .AND. .NOT.OB%HT3D) CYCLE
         IC = M%CELL_INDEX(I,J,K-1)
         ! Permanently covered face
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE .AND. .NOT.OB%HT3D) CYCLE
         IOR = -3
         SURF_INDEX = OB%SURF_INDEX(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS + 1
            M%N_WALL_CELLS = M%N_EXTERNAL_WALL_CELLS + M%N_INTERNAL_WALL_CELLS
            IW  = M%N_WALL_CELLS
         ELSE
            IF (.NOT.OB%OVERLAY .OR. OB%HIDDEN .OR. M%WALL(IW)%SURF_INDEX==SURF_INDEX) CYCLE
            M%WALL(IW)%WALL_INDEX = 0
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,SURF_INDEX,IERR,T_BEGIN)
         IF (IERR>0) RETURN
      ENDDO
   ENDDO

   DO J=OB%J1+1,OB%J2
      DO I=OB%I1+1,OB%I2
         K = OB%K2
         ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IF (K==M%KBAR .AND. .NOT.OB%HT3D) CYCLE
         IC = M%CELL_INDEX(I,J,K+1)
         ! Permanently covered face
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE .AND. .NOT.OB%HT3D) CYCLE
         IOR = 3
         SURF_INDEX = OB%SURF_INDEX(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS + 1
            M%N_WALL_CELLS = M%N_EXTERNAL_WALL_CELLS + M%N_INTERNAL_WALL_CELLS
            IW  = M%N_WALL_CELLS
         ELSE
            IF (.NOT.OB%OVERLAY .OR. OB%HIDDEN .OR. M%WALL(IW)%SURF_INDEX==SURF_INDEX) CYCLE
            M%WALL(IW)%WALL_INDEX = 0
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,SURF_INDEX,IERR,T_BEGIN)
         IF (IERR>0) RETURN
      ENDDO
   ENDDO

ENDDO OBST_LOOP_2

! Solid 3D heat transfer

SOLID_HT3D=.FALSE.
IF (ANY(OBSTRUCTION%HT3D)) SOLID_HT3D=.TRUE.

! Allocate local auto-ignition temperature

IF (REIGNITION_MODEL) THEN
   DO IW=1,M%N_EXTERNAL_WALL_CELLS+M%N_INTERNAL_WALL_CELLS
      WC=>M%WALL(IW)
      SF=>SURFACE(WC%SURF_INDEX)
      IIG = WC%ONE_D%IIG
      JJG = WC%ONE_D%JJG
      KKG = WC%ONE_D%KKG
      IF (SF%AUTO_IGNITION_TEMPERATURE<1.E20_EB) M%AIT(IIG,JJG,KKG) = SF%AUTO_IGNITION_TEMPERATURE
   ENDDO
ENDIF

END SUBROUTINE INITIALIZE_MESH_VARIABLES_1


SUBROUTINE INITIALIZE_MESH_VARIABLES_2(NM)

USE PHYSICAL_FUNCTIONS, ONLY: GET_VISCOSITY,GET_SPECIFIC_GAS_CONSTANT,GET_SPECIFIC_HEAT,LES_FILTER_WIDTH_FUNCTION
USE MEMORY_FUNCTIONS, ONLY: COMPUTE_ONE_D_STORAGE_DIMENSIONS,COMPUTE_PARTICLE_STORAGE_DIMENSIONS,COMPUTE_WALL_STORAGE_DIMENSIONS
USE GEOMETRY_FUNCTIONS, ONLY: ASSIGN_PRESSURE_ZONE,SEARCH_OTHER_MESHES
USE CONTROL_VARIABLES
INTEGER :: N,I,J,K,II,JJ,KK,IPTS,JPTS,KPTS,N_EDGES_DIM,IW,IC,ICG,IOR,IERR,IPZ,NOM,ITER,IZERO
INTEGER, INTENT(IN) :: NM
REAL(EB) :: ZZ_GET(1:N_TRACKED_SPECIES),VC,RTRM,CP,XXC,YYC,ZZC
INTEGER, POINTER :: IBP1, JBP1, KBP1,IBAR, JBAR, KBAR, N_EDGES
INTEGER, ALLOCATABLE, DIMENSION(:) :: IW_EXPORT
REAL(EB),POINTER :: XS,XF,YS,YF,ZS,ZF
TYPE (MESH_TYPE), POINTER :: M
TYPE (WALL_TYPE), POINTER :: WC
TYPE (MESH_TYPE), POINTER :: OM
TYPE (VENTS_TYPE), POINTER :: VT
TYPE (OBSTRUCTION_TYPE), POINTER :: OB
TYPE (SURFACE_TYPE), POINTER :: SF
LOGICAL :: SOLID_CELL

IERR = 0
M => MESHES(NM)
IBP1 =>M%IBP1
JBP1 =>M%JBP1
KBP1 =>M%KBP1
IBAR =>M%IBAR
JBAR =>M%JBAR
KBAR =>M%KBAR
N_EDGES=>M%N_EDGES
XS=>M%XS
YS=>M%YS
ZS=>M%ZS
XF=>M%XF
YF=>M%YF
ZF=>M%ZF

! Surface work arrays

ALLOCATE(M%WALL_WORK1(M%N_WALL_CELLS),STAT=IZERO)
CALL ChkMemErr('INIT','WALL_WORK1',IZERO)
ALLOCATE(M%WALL_WORK2(M%N_WALL_CELLS),STAT=IZERO)
CALL ChkMemErr('INIT','WALL_WORK2',IZERO)

! Initialize PSUM for zone cases

IF (N_ZONE > 0) THEN
   N_ZONE_LOOP: DO IPZ = 1,N_ZONE
      PSUM(IPZ,NM) = 0._EB
      IF (EVACUATION_ONLY(NM)) EXIT N_ZONE_LOOP
      DO K=1,M%KBAR
         DO J=1,M%JBAR
            DO I=1,M%IBAR
               IF (M%PRESSURE_ZONE(I,J,K) /= IPZ) CYCLE
               IF (M%SOLID(M%CELL_INDEX(I,J,K)))    CYCLE
               VC   = M%DX(I)*M%RC(I)*M%DY(J)*M%DZ(K)
               ZZ_GET(1:N_TRACKED_SPECIES) = M%ZZ(I,J,K,1:N_TRACKED_SPECIES)
               CALL GET_SPECIFIC_HEAT(ZZ_GET,CP,M%TMP(I,J,K))
               RTRM = M%RSUM(I,J,K)/(CP*M%PBAR(K,IPZ))
               PSUM(IPZ,NM) = PSUM(IPZ,NM) + VC*(1._EB/M%PBAR(K,IPZ)-RTRM)
            ENDDO
         ENDDO
      ENDDO
   ENDDO N_ZONE_LOOP
ENDIF

! Loop through all wall cells and check if the boundary conditions are appropriate

WALL_LOOP_0: DO IW=1,M%N_EXTERNAL_WALL_CELLS+M%N_INTERNAL_WALL_CELLS

   WC => M%WALL(IW)
   SF => SURFACE(WC%SURF_INDEX)

   IF (IW<=M%N_EXTERNAL_WALL_CELLS) THEN
      IF (M%EXTERNAL_WALL(IW)%NOM>0) THEN
         OM => MESHES(M%EXTERNAL_WALL(IW)%NOM)
         IC = OM%CELL_INDEX(M%EXTERNAL_WALL(IW)%IIO_MIN,M%EXTERNAL_WALL(IW)%JJO_MIN,M%EXTERNAL_WALL(IW)%KKO_MIN)
         SOLID_CELL = OM%SOLID(IC)
      ELSE
         IC =  M%CELL_INDEX(WC%ONE_D%II,WC%ONE_D%JJ,WC%ONE_D%KK)
         SOLID_CELL = M%SOLID(IC)
      ENDIF
   ELSE
      IC =  M%CELL_INDEX(WC%ONE_D%II,WC%ONE_D%JJ,WC%ONE_D%KK)
      SOLID_CELL = M%SOLID(IC)
   ENDIF

   IF (.NOT.SOLID_CELL) THEN
      IF ( (ABS(WC%UW0)>TWO_EPSILON_EB .OR. ANY(SF%LEAK_PATH>=0) .OR. SF%PYROLYSIS_MODEL/=PYROLYSIS_NONE) &
           .AND. WC%OBST_INDEX>0 ) THEN
         WRITE(LU_ERR,'(A,A,A,I4)') 'ERROR: SURF ',TRIM(SF%ID),' cannot be applied to a thin obstruction, OBST #',&
                                    M%OBSTRUCTION(WC%OBST_INDEX)%ORDINAL
         STOP_STATUS = SETUP_STOP
         RETURN
      ENDIF
      IF (WC%VENT_INDEX>0 .AND. WC%OBST_INDEX>0) THEN
         VT => VENTS(WC%VENT_INDEX)
         IF (VT%BOUNDARY_TYPE==HVAC_BOUNDARY) THEN
            WRITE(LU_ERR,'(A,A,A,I4)') 'ERROR: VENT ',TRIM(VT%ID),' cannot be applied to a thin obstruction, OBST #',&
                                    M%OBSTRUCTION(WC%OBST_INDEX)%ORDINAL
            STOP_STATUS = SETUP_STOP
            RETURN
         ENDIF
      ENDIF
   ENDIF

ENDDO WALL_LOOP_0

! Loop through all internal and external wall cells and look for thermally thick
! solids with EXPOSED back wall cells. If the exposed back wall cell is in
! another mesh, store the cell info into arrays that are to be MPI exchanged.

! DEFINITION MESHES(NM)%OMESH(NOM)%N_EXPOSED_WALL_CELLS
! Number of wall cells in Mesh NM whose exposed back faces are in Mesh NOM.

! DEFINITION MESHES(NM)%OMESH(NOM)%EXPOSED_WALL_CELL_BACK_INDICES(1:N_EXPOSED_WALL_CELLS)
! Wall indices of the back faces of the exposed wall cells.

NON_EVAC_IF: IF (.NOT.EVACUATION_ONLY(NM)) THEN

DO NOM=1,NMESHES
   M%OMESH(NOM)%N_EXPOSED_WALL_CELLS = 0
ENDDO

WALL_LOOP: DO IW=1,M%N_EXTERNAL_WALL_CELLS+M%N_INTERNAL_WALL_CELLS

   WC => M%WALL(IW)
   IF (WC%OBST_INDEX==0) CYCLE WALL_LOOP
   ICG = M%CELL_INDEX(WC%ONE_D%IIG,WC%ONE_D%JJG,WC%ONE_D%KKG)
   IF (M%SOLID(ICG)) CYCLE WALL_LOOP
   SF => SURFACE(WC%SURF_INDEX)

   IF_THERM_THICK_EXPOSED: IF (SF%THERMALLY_THICK .AND. SF%BACKING==EXPOSED) THEN ! search for the back side

      IOR = WC%ONE_D%IOR
      NOM = NM
      OM => MESHES(NOM)
      II = WC%ONE_D%II
      JJ = WC%ONE_D%JJ
      KK = WC%ONE_D%KK

      ZERO_OR_ONE_CELL_THICK: DO ITER=1,2  ! Look for the back wall cell face if the obstruction is either zero or one cell thick.

         IF (II==0 .OR. II==OM%IBP1 .OR. JJ==0 .OR. JJ==OM%JBP1 .OR. KK==0 .OR. KK==OM%KBP1) THEN
            XXC=OM%XC(II) ; YYC=OM%YC(JJ) ; ZZC=OM%ZC(KK)
            IF (II==0)       XXC = OM%X(II)  -0.01_EB*OM%DX(II)
            IF (II==OM%IBP1) XXC = OM%X(II-1)+0.01_EB*OM%DX(II-1)
            IF (JJ==0)       YYC = OM%Y(JJ)  -0.01_EB*OM%DY(JJ)
            IF (JJ==OM%JBP1) YYC = OM%Y(JJ-1)+0.01_EB*OM%DY(JJ-1)
            IF (KK==0)       ZZC = OM%Z(KK)  -0.01_EB*OM%DZ(KK)
            IF (KK==OM%KBP1) ZZC = OM%Z(KK-1)+0.01_EB*OM%DZ(KK-1)
            CALL SEARCH_OTHER_MESHES(XXC,YYC,ZZC,NOM,II,JJ,KK)
            IF (NOM==0) CYCLE WALL_LOOP
            OM => MESHES(NOM)
         ENDIF
         IC = OM%CELL_INDEX(II,JJ,KK)
         IF (.NOT.OM%SOLID(IC) .AND. OM%WALL_INDEX(IC,IOR)>0) THEN ! the back wall face is found
            WC%BACK_INDEX = OM%WALL_INDEX(IC,IOR)
            WC%BACK_MESH  = NOM
            EXIT ZERO_OR_ONE_CELL_THICK
         ELSE ! see if the obstruction is one cell thick. If not, get out.
            IF (ITER==2) CYCLE WALL_LOOP
            SELECT CASE(IOR)
               CASE(-1) ; II=II+1
               CASE( 1) ; II=II-1
               CASE(-2) ; JJ=JJ+1
               CASE( 2) ; JJ=JJ-1
               CASE(-3) ; KK=KK+1
               CASE( 3) ; KK=KK-1
            END SELECT
         ENDIF

      ENDDO ZERO_OR_ONE_CELL_THICK

      IF (NOM/=NM) THEN ! count the number of wall cells that need to be exchanged
         M%OMESH(NOM)%N_EXPOSED_WALL_CELLS = M%OMESH(NOM)%N_EXPOSED_WALL_CELLS + 1
      ENDIF

   ENDIF IF_THERM_THICK_EXPOSED

ENDDO WALL_LOOP

DO NOM=1,NMESHES
   IF (M%OMESH(NOM)%N_EXPOSED_WALL_CELLS==0) CYCLE
   ALLOCATE(M%OMESH(NOM)%EXPOSED_WALL_CELL_BACK_INDICES(M%OMESH(NOM)%N_EXPOSED_WALL_CELLS))
ENDDO

ALLOCATE(IW_EXPORT(NMESHES)) ; IW_EXPORT = 0  ! This is just a counter for each neighboring mesh.

DO IW=1,M%N_EXTERNAL_WALL_CELLS+M%N_INTERNAL_WALL_CELLS
   WC => M%WALL(IW)
   IF (WC%BACK_MESH/=NM) THEN ! Save the back wall cell index, and then reset the index to form a short list of exposed back cells.
      IW_EXPORT(WC%BACK_MESH) = IW_EXPORT(WC%BACK_MESH) + 1
      M%OMESH(WC%BACK_MESH)%EXPOSED_WALL_CELL_BACK_INDICES(IW_EXPORT(WC%BACK_MESH)) = WC%BACK_INDEX
      WC%BACK_INDEX = IW_EXPORT(WC%BACK_MESH)
   ENDIF
ENDDO

DEALLOCATE(IW_EXPORT)

ENDIF NON_EVAC_IF

! Set clocks and counters related to frequency of solid phase conduction updates

M%BC_CLOCK     = T_BEGIN
M%WALL_COUNTER = 0

! Set clock for boudary fuel vegetation model

M%VEG_CLOCK_BC = T_BEGIN

! Allocate arrays for storing velocity boundary condition info

N_EDGES_DIM = 4*(IBP1*JBP1+IBP1*KBP1+JBP1*KBP1)
IF (EVACUATION_ONLY(NM)) N_EDGES_DIM = 4*(IBP1*KBP1+JBP1*KBP1)
DO N=1,M%N_OBST
   OB=>M%OBSTRUCTION(N)
   IPTS = OB%I2-OB%I1
   JPTS = OB%J2-OB%J1
   KPTS = OB%K2-OB%K1
   IF (EVACUATION_ONLY(NM)) THEN
      N_EDGES_DIM = N_EDGES_DIM + 4*(IPTS*KPTS+JPTS*KPTS)
   ELSE
      N_EDGES_DIM = N_EDGES_DIM + 4*(IPTS*JPTS+IPTS*KPTS+JPTS*KPTS)
   ENDIF
ENDDO

ALLOCATE(M%IJKE(16,N_EDGES_DIM),STAT=IZERO)
CALL ChkMemErr('INIT','IJKE',IZERO)
M%IJKE  = 0
ALLOCATE(M%OME_E(-2:2,0:N_EDGES_DIM),STAT=IZERO)
CALL ChkMemErr('INIT','OME_E',IZERO)
M%OME_E = 0._EB
ALLOCATE(M%TAU_E(-2:2,0:N_EDGES_DIM),STAT=IZERO)
CALL ChkMemErr('INIT','TAU_E',IZERO)
M%TAU_E = 0._EB
ALLOCATE(M%EDGE_INTERPOLATION_FACTOR(N_EDGES_DIM,2),STAT=IZERO)
CALL ChkMemErr('INIT','EDGE_INTERPOLATION_FACTOR',IZERO)
M%EDGE_INTERPOLATION_FACTOR = 1._EB

! Allocate array to hold character strings for Smokeview file

M%N_STRINGS     =   0
M%N_STRINGS_MAX = 100
ALLOCATE(M%STRING(M%N_STRINGS_MAX),STAT=IZERO)
CALL ChkMemErr('INIT','STRING',IZERO)

! Set up arrays to hold velocity boundary condition info

CALL INITIALIZE_EDGES

! Initialize Pressure solver

CALL INITIALIZE_POISSON_SOLVER
!CALL INITIALIZE_LAPLACE_SOLVER
IF (IERR/=0) RETURN

! Initialize Mesh Exchange

CALL INITIALIZE_INTERPOLATION


CONTAINS


SUBROUTINE INITIALIZE_EDGES

! Set up edge arrays for velocity boundary conditions

INTEGER I,J,K,N

CALL POINT_TO_MESH(NM)

N_EDGES = 0

! Arguments for DEFINE_EDGE(I,J,K,IOR,IEC,NM,OBST_INDEX)

DO K=0,KBAR
   DO J=0,JBAR
      IF (J>0) CALL DEFINE_EDGE(   0,J,K, 1,2,NM,0,IERR)
      IF (J>0) CALL DEFINE_EDGE(IBAR,J,K,-1,2,NM,0,IERR)
      IF (K>0) CALL DEFINE_EDGE(   0,J,K, 1,3,NM,0,IERR)
      IF (K>0) CALL DEFINE_EDGE(IBAR,J,K,-1,3,NM,0,IERR)
   ENDDO
ENDDO
DO K=0,KBAR
   DO I=0,IBAR
      IF (I>0) CALL DEFINE_EDGE(I,   0,K, 2,1,NM,0,IERR)
      IF (I>0) CALL DEFINE_EDGE(I,JBAR,K,-2,1,NM,0,IERR)
      IF (K>0) CALL DEFINE_EDGE(I,   0,K, 2,3,NM,0,IERR)
      IF (K>0) CALL DEFINE_EDGE(I,JBAR,K,-2,3,NM,0,IERR)
   ENDDO
ENDDO
DO J=0,JBAR
   DO I=0,IBAR
      IF (I>0) CALL DEFINE_EDGE(I,J,   0, 3,1,NM,0,IERR)
      IF (I>0) CALL DEFINE_EDGE(I,J,KBAR,-3,1,NM,0,IERR)
      IF (J>0) CALL DEFINE_EDGE(I,J,   0, 3,2,NM,0,IERR)
      IF (J>0) CALL DEFINE_EDGE(I,J,KBAR,-3,2,NM,0,IERR)
   ENDDO
ENDDO

IF (IERR/=0) RETURN

OBST_LOOP_3: DO N=1,N_OBST
   OB => OBSTRUCTION(N)
   DO K=OB%K1,OB%K2
      DO J=OB%J1,OB%J2
         IF (J>OB%J1) CALL DEFINE_EDGE(OB%I1,J,K,-1,2,NM,N,IERR)
         IF (J>OB%J1) CALL DEFINE_EDGE(OB%I2,J,K, 1,2,NM,N,IERR)
         IF (K>OB%K1) CALL DEFINE_EDGE(OB%I1,J,K,-1,3,NM,N,IERR)
         IF (K>OB%K1) CALL DEFINE_EDGE(OB%I2,J,K, 1,3,NM,N,IERR)
      ENDDO
   ENDDO
   DO K=OB%K1,OB%K2
      DO I=OB%I1,OB%I2
         IF (I>OB%I1) CALL DEFINE_EDGE(I,OB%J1,K,-2,1,NM,N,IERR)
         IF (I>OB%I1) CALL DEFINE_EDGE(I,OB%J2,K, 2,1,NM,N,IERR)
         IF (K>OB%K1) CALL DEFINE_EDGE(I,OB%J1,K,-2,3,NM,N,IERR)
         IF (K>OB%K1) CALL DEFINE_EDGE(I,OB%J2,K, 2,3,NM,N,IERR)
      ENDDO
   ENDDO
   DO J=OB%J1,OB%J2
      DO I=OB%I1,OB%I2
         IF (I>OB%I1) CALL DEFINE_EDGE(I,J,OB%K1,-3,1,NM,N,IERR)
         IF (I>OB%I1) CALL DEFINE_EDGE(I,J,OB%K2, 3,1,NM,N,IERR)
         IF (J>OB%J1) CALL DEFINE_EDGE(I,J,OB%K1,-3,2,NM,N,IERR)
         IF (J>OB%J1) CALL DEFINE_EDGE(I,J,OB%K2, 3,2,NM,N,IERR)
      ENDDO
   ENDDO
ENDDO OBST_LOOP_3

IF (N_EDGES>N_EDGES_DIM .AND. EVACUATION_ONLY(NM)) THEN
   WRITE(LU_ERR,'(A,I2,A,2I8)') 'ERROR: Edges memory; Mesh: ',NM,', n_edges, n_edges_dim ',N_EDGES, N_EDGES_DIM
   STOP_STATUS = SETUP_STOP
   IERR = 1
ENDIF

END SUBROUTINE INITIALIZE_EDGES


SUBROUTINE INITIALIZE_POISSON_SOLVER

USE POIS, ONLY: H3CZIS,H2CZIS,H3CSIS,H2CYIS
REAL(EB) :: XLM,XMU
INTEGER  :: N,IZERO
INTEGER, POINTER :: ITRN,JTRN,KTRN,LBC,MBC,NBC
INTEGER, POINTER, DIMENSION(:) :: NOC
TYPE (VENTS_TYPE), POINTER :: VT
TYPE (WALL_TYPE), POINTER :: WC

! Allocate major arrays

ITRN =>M%ITRN
JTRN =>M%JTRN
KTRN =>M%KTRN
LBC =>M%LBC
MBC =>M%MBC
NBC =>M%NBC
LBC2 =>M%LBC2
MBC2 =>M%MBC2
NBC2 =>M%NBC2
NOC=>TRANS(NM)%NOC
IF (NOC(1)==0 .AND. NOC(2)==0 .AND. NOC(3)==0) M%IPS=0
IF (NOC(1)/=0 .AND. NOC(2)==0 .AND. NOC(3)==0) M%IPS=1
IF (NOC(1)==0 .AND. NOC(2)/=0 .AND. NOC(3)==0) M%IPS=2
IF (NOC(1)==0 .AND. NOC(2)==0 .AND. NOC(3)/=0) M%IPS=3
IF (NOC(1)/=0 .AND. NOC(2)/=0 .AND. NOC(3)==0) M%IPS=4
IF (NOC(1)/=0 .AND. NOC(2)==0 .AND. NOC(3)/=0) M%IPS=5
IF (NOC(1)==0 .AND. NOC(2)/=0 .AND. NOC(3)/=0) M%IPS=6
IF (EVACUATION_ONLY(NM)                      ) M%IPS=7
IF (NOC(1)/=0 .AND. NOC(2)/=0 .AND. NOC(3)/=0) THEN
   WRITE(LU_ERR,'(A,I3)') 'ERROR: Stretch at most 2 coordinate directions in MESH ',NM
   STOP_STATUS = SETUP_STOP
   IERR = 1
   RETURN
ENDIF

IF (M%IPS<=1 .OR. M%IPS==4) THEN
   ITRN = IBP1
   IF (JBAR>1) JTRN = JBP1
   IF (JBAR==1) JTRN = 1
   KTRN = KBP1

   ! pressure periodic boundary conditions
   IF (FISHPAK_BC(1)==FISHPAK_BC_PERIODIC) ITRN=IBAR
   IF (FISHPAK_BC(2)==FISHPAK_BC_PERIODIC) JTRN=JBAR
   IF (FISHPAK_BC(3)==FISHPAK_BC_PERIODIC) KTRN=KBAR
ENDIF

IF (M%IPS==2) THEN
   ITRN = JBP1
   JTRN = IBP1
   KTRN = KBP1
   ALLOCATE(M%BZST(JBP1,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BZST',IZERO)
   ALLOCATE(M%BZFT(JBP1,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BZFT',IZERO)
ENDIF

IF (M%IPS==3 .OR. M%IPS==6) THEN
   ITRN = KBP1
   IF (JBAR>1) JTRN = JBP1
   IF (JBAR==1) JTRN = 1
   KTRN = IBP1
   ALLOCATE(M%BXST(KBP1,JTRN),STAT=IZERO)
   CALL ChkMemErr('INIT','BXST',IZERO)
   ALLOCATE(M%BXFT(KBP1,JTRN),STAT=IZERO)
   CALL ChkMemErr('INIT','BXFT',IZERO)
   ALLOCATE(M%BYST(KBP1,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BYST',IZERO)
   ALLOCATE(M%BYFT(KBP1,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BYFT',IZERO)
   ALLOCATE(M%BZST(JTRN,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BZST',IZERO)
   ALLOCATE(M%BZFT(JTRN,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BZFT',IZERO)
ENDIF

IF (M%IPS==5) THEN
   ITRN = IBP1
   JTRN = KBP1
   KTRN = JBP1
   ALLOCATE(M%BXST(KBP1,JBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BXST',IZERO)
   ALLOCATE(M%BXFT(KBP1,JBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BXFT',IZERO)
ENDIF

IF (M%IPS==7) THEN
   ITRN = IBP1
   JTRN = JBP1
   KTRN = 1
ENDIF

IF (M%IPS<=3 .OR. M%IPS==7) THEN
   M%LSAVE = (ITRN+1)*JTRN*KTRN+7*ITRN+5*JTRN+6*KTRN+56
   M%LWORK = (ITRN+1)*JTRN*KTRN
ELSE
   N_LOOP: DO N=1,50
      IF ((JTRN+1)<=2**N) EXIT N_LOOP
   ENDDO N_LOOP
   M%LSAVE = KTRN*(6*N*(2**N)+2*N+19)+8*ITRN+7*JTRN+38
   M%LWORK = JTRN*(ITRN*(KTRN+1)+1)
ENDIF

ALLOCATE(M%SAVE1(-3:M%LSAVE),STAT=IZERO)
CALL ChkMemErr('INIT','SAVE1',IZERO)
IF (EXTERNAL_BOUNDARY_CORRECTION) THEN
   ALLOCATE(M%SAVE2(-3:M%LSAVE),STAT=IZERO)
   CALL ChkMemErr('INIT','SAVE2',IZERO)
ENDIF
ALLOCATE(M%WORK(M%LWORK),STAT=IZERO)
CALL ChkMemErr('INIT','WORK',IZERO)
ALLOCATE(M%PRHS(ITRN,JTRN,KTRN),STAT=IZERO)
CALL ChkMemErr('INIT','PRHS',IZERO)
IF (KBAR>1) THEN
   IF (JBAR>1 ) ALLOCATE(M%BXS(JBP1,KBP1),STAT=IZERO)
   IF (JBAR==1) ALLOCATE(M%BXS(1,KBP1)   ,STAT=IZERO)
ELSE
   ALLOCATE(M%BXS(JBP1,1)   ,STAT=IZERO)
ENDIF
CALL ChkMemErr('INIT','BXS',IZERO)
IF (KBAR>1) THEN
   IF (JBAR>1 ) ALLOCATE(M%BXF(JBP1,KBP1),STAT=IZERO)
   IF (JBAR==1) ALLOCATE(M%BXF(1,KBP1)   ,STAT=IZERO)
ELSE
   ALLOCATE(M%BXF(JBP1,1)   ,STAT=IZERO)
ENDIF
CALL ChkMemErr('INIT','BXF',IZERO)
IF (KBAR>1) THEN
   ALLOCATE(M%BYS(IBP1,KBP1),STAT=IZERO)
ELSE
   ALLOCATE(M%BYS(IBP1,1),STAT=IZERO)
ENDIF
CALL ChkMemErr('INIT','BYS',IZERO)
IF (KBAR>1) THEN
   ALLOCATE(M%BYF(IBP1,KBP1),STAT=IZERO)
ELSE
   ALLOCATE(M%BYF(IBP1,1),STAT=IZERO)
ENDIF
CALL ChkMemErr('INIT','BYF',IZERO)
IF (JBAR>1) ALLOCATE(M%BZS(IBP1,JBP1),STAT=IZERO)
IF (JBAR==1) ALLOCATE(M%BZS(IBP1,1)   ,STAT=IZERO)
CALL ChkMemErr('INIT','BZS',IZERO)
IF (JBAR>1) ALLOCATE(M%BZF(IBP1,JBP1),STAT=IZERO)
IF (JBAR==1) ALLOCATE(M%BZF(IBP1,1)   ,STAT=IZERO)
CALL ChkMemErr('INIT','BZF',IZERO)

M%POIS_PTB = 0._EB
M%SAVE1 = 0._EB
M%WORK = 0._EB
M%PRHS = 0._EB
M%BXS  = 0._EB
M%BXF  = 0._EB
M%BYS  = 0._EB
M%BYF  = 0._EB
M%BZS  = 0._EB
M%BZF  = 0._EB

IF (EXTERNAL_BOUNDARY_CORRECTION) THEN
   M%LAPLACE_PTB = 0._EB
   M%SAVE2 = 0._EB
ENDIF

! Initialize pressure solver

XLM = 0._EB         ! No Helmholtz equation
XMU = 0._EB         ! No Helmholtz equation

! BC index for Fishpak solver

! From Roland Sweet's notes:
!
! Here we use LBC as an example, this is the BC index for the X direction. MBC and NMC are
! analogous for the Y and Z directions.
!
! LBC = 0, solution is periodic in X.
!
! LBC = 1, solution is specified at XS (Dirichlet) and XF (Dirichlet).
!
! LBC = 2, solution is specified at XS (Dirichlet) and derivative of solution is specified at XF (Neumann).
!
! LBC = 3, derivative of solution is specified at XS (Neumann) and XF (Neumann).
!
! LBC = 4, derivative of solution is specified at XS (Neumann) and solution is specified at XF (Dirichlet).
!
! LBC = 5, the solution is unspecified at r = RS = 0 and the solution is specified at r = RF.
!
! LBC = 6, if the solution is unspecified at r = RS = 0 and the derivative of the solution with respect to r is specified
!          at r = RF.

LBC = FISHPAK_BC_NEUMANN_NEUMANN
MBC = FISHPAK_BC_NEUMANN_NEUMANN
NBC = FISHPAK_BC_NEUMANN_NEUMANN
IF (EXTERNAL_BOUNDARY_CORRECTION) THEN
   LBC2 = FISHPAK_BC_NEUMANN_NEUMANN
   MBC2 = FISHPAK_BC_NEUMANN_NEUMANN
   NBC2 = FISHPAK_BC_NEUMANN_NEUMANN
ENDIF

! Look for OPEN vents -- this will change the entire face to DIRICHLET BCs

VENT_LOOP: DO N=1,M%N_VENT
   VT => M%VENTS(N)
   IF (VT%BOUNDARY_TYPE /= OPEN_BOUNDARY .OR. VT%GHOST_CELLS_ONLY) CYCLE VENT_LOOP
   IF (VT%I1==0 .AND. VT%I2==0) THEN
      IF (LBC==FISHPAK_BC_NEUMANN_NEUMANN)   LBC = FISHPAK_BC_DIRICHLET_NEUMANN
      IF (LBC==FISHPAK_BC_NEUMANN_DIRICHLET) LBC = FISHPAK_BC_DIRICHLET_DIRICHLET
   ENDIF
   IF (VT%I1==M%IBAR .AND. VT%I2==M%IBAR) THEN
      IF (LBC==FISHPAK_BC_NEUMANN_NEUMANN)   LBC = FISHPAK_BC_NEUMANN_DIRICHLET
      IF (LBC==FISHPAK_BC_DIRICHLET_NEUMANN) LBC = FISHPAK_BC_DIRICHLET_DIRICHLET
   ENDIF
   IF (VT%J1==0 .AND. VT%J2==0) THEN
      IF (MBC==FISHPAK_BC_NEUMANN_NEUMANN)   MBC = FISHPAK_BC_DIRICHLET_NEUMANN
      IF (MBC==FISHPAK_BC_NEUMANN_DIRICHLET) MBC = FISHPAK_BC_DIRICHLET_DIRICHLET
   ENDIF
   IF (VT%J1==M%JBAR .AND. VT%J2==M%JBAR) THEN
      IF (MBC==FISHPAK_BC_NEUMANN_NEUMANN)   MBC = FISHPAK_BC_NEUMANN_DIRICHLET
      IF (MBC==FISHPAK_BC_DIRICHLET_NEUMANN) MBC = FISHPAK_BC_DIRICHLET_DIRICHLET
   ENDIF
   IF (VT%K1==0 .AND. VT%K2==0) THEN
      IF (NBC==FISHPAK_BC_NEUMANN_NEUMANN)   NBC = FISHPAK_BC_DIRICHLET_NEUMANN
      IF (NBC==FISHPAK_BC_NEUMANN_DIRICHLET) NBC = FISHPAK_BC_DIRICHLET_DIRICHLET
   ENDIF
   IF (VT%K1==M%KBAR .AND. VT%K2==M%KBAR) THEN
      IF (NBC==FISHPAK_BC_NEUMANN_NEUMANN)   NBC = FISHPAK_BC_NEUMANN_DIRICHLET
      IF (NBC==FISHPAK_BC_DIRICHLET_NEUMANN) NBC = FISHPAK_BC_DIRICHLET_DIRICHLET
   ENDIF
ENDDO VENT_LOOP

! All interpolated boundaries are Dirichlet

DO IW=1,M%N_EXTERNAL_WALL_CELLS
   IF (M%EXTERNAL_WALL(IW)%NOM==0) CYCLE
   SELECT CASE(M%WALL(IW)%ONE_D%IOR)
      CASE( 1)
         IF (LBC==FISHPAK_BC_NEUMANN_NEUMANN)   LBC = FISHPAK_BC_DIRICHLET_NEUMANN
         IF (LBC==FISHPAK_BC_NEUMANN_DIRICHLET) LBC = FISHPAK_BC_DIRICHLET_DIRICHLET
      CASE(-1)
         IF (LBC==FISHPAK_BC_NEUMANN_NEUMANN)   LBC = FISHPAK_BC_NEUMANN_DIRICHLET
         IF (LBC==FISHPAK_BC_DIRICHLET_NEUMANN) LBC = FISHPAK_BC_DIRICHLET_DIRICHLET
      CASE( 2)
         IF (MBC==FISHPAK_BC_NEUMANN_NEUMANN)   MBC = FISHPAK_BC_DIRICHLET_NEUMANN
         IF (MBC==FISHPAK_BC_NEUMANN_DIRICHLET) MBC = FISHPAK_BC_DIRICHLET_DIRICHLET
      CASE(-2)
         IF (MBC==FISHPAK_BC_NEUMANN_NEUMANN)   MBC = FISHPAK_BC_NEUMANN_DIRICHLET
         IF (MBC==FISHPAK_BC_DIRICHLET_NEUMANN) MBC = FISHPAK_BC_DIRICHLET_DIRICHLET
      CASE( 3)
         IF (NBC==FISHPAK_BC_NEUMANN_NEUMANN)   NBC = FISHPAK_BC_DIRICHLET_NEUMANN
         IF (NBC==FISHPAK_BC_NEUMANN_DIRICHLET) NBC = FISHPAK_BC_DIRICHLET_DIRICHLET
      CASE(-3)
         IF (NBC==FISHPAK_BC_NEUMANN_NEUMANN)   NBC = FISHPAK_BC_NEUMANN_DIRICHLET
         IF (NBC==FISHPAK_BC_DIRICHLET_NEUMANN) NBC = FISHPAK_BC_DIRICHLET_DIRICHLET
   END SELECT
ENDDO

! Test setting interpolated boundaries to Dirichlet for Laplace solve

IF (EXTERNAL_BOUNDARY_CORRECTION) THEN
   DO IW=1,M%N_EXTERNAL_WALL_CELLS
      IF (M%EXTERNAL_WALL(IW)%NOM==0) CYCLE
      SELECT CASE(M%WALL(IW)%ONE_D%IOR)
         CASE( 1)
            IF (LBC2==FISHPAK_BC_NEUMANN_NEUMANN)   LBC2 = FISHPAK_BC_DIRICHLET_NEUMANN
            IF (LBC2==FISHPAK_BC_NEUMANN_DIRICHLET) LBC2 = FISHPAK_BC_DIRICHLET_DIRICHLET
         CASE(-1)
            IF (LBC2==FISHPAK_BC_NEUMANN_NEUMANN)   LBC2 = FISHPAK_BC_NEUMANN_DIRICHLET
            IF (LBC2==FISHPAK_BC_DIRICHLET_NEUMANN) LBC2 = FISHPAK_BC_DIRICHLET_DIRICHLET
         CASE( 2)
            IF (MBC2==FISHPAK_BC_NEUMANN_NEUMANN)   MBC2 = FISHPAK_BC_DIRICHLET_NEUMANN
            IF (MBC2==FISHPAK_BC_NEUMANN_DIRICHLET) MBC2 = FISHPAK_BC_DIRICHLET_DIRICHLET
         CASE(-2)
            IF (MBC2==FISHPAK_BC_NEUMANN_NEUMANN)   MBC2 = FISHPAK_BC_NEUMANN_DIRICHLET
            IF (MBC2==FISHPAK_BC_DIRICHLET_NEUMANN) MBC2 = FISHPAK_BC_DIRICHLET_DIRICHLET
         CASE( 3)
            IF (NBC2==FISHPAK_BC_NEUMANN_NEUMANN)   NBC2 = FISHPAK_BC_DIRICHLET_NEUMANN
            IF (NBC2==FISHPAK_BC_NEUMANN_DIRICHLET) NBC2 = FISHPAK_BC_DIRICHLET_DIRICHLET
         CASE(-3)
            IF (NBC2==FISHPAK_BC_NEUMANN_NEUMANN)   NBC2 = FISHPAK_BC_NEUMANN_DIRICHLET
            IF (NBC2==FISHPAK_BC_DIRICHLET_NEUMANN) NBC2 = FISHPAK_BC_DIRICHLET_DIRICHLET
      END SELECT
   ENDDO
ENDIF

! Periodic pressure boundary conditions for CrayFishpak

IF (FISHPAK_BC(1)==FISHPAK_BC_PERIODIC) LBC=FISHPAK_BC_PERIODIC
IF (FISHPAK_BC(2)==FISHPAK_BC_PERIODIC) MBC=FISHPAK_BC_PERIODIC
IF (FISHPAK_BC(3)==FISHPAK_BC_PERIODIC) NBC=FISHPAK_BC_PERIODIC

! Wannier flow boundaries

IF (PERIODIC_TEST==5) THEN
   LBC = FISHPAK_BC_DIRICHLET_DIRICHLET
   NBC = FISHPAK_BC_DIRICHLET_DIRICHLET
ENDIF

! Poisson solver with stretching in the 1st coordinate

SELECT_POISSON_SOLVER: SELECT CASE(M%IPS)

   CASE (0:1) SELECT_POISSON_SOLVER
      IF (.NOT.TWO_D) CALL H3CZIS(XS,XF,IBAR,LBC,YS,YF,JBAR,MBC,ZS,ZF,KBAR,NBC,M%HX,XLM,ITRN,JTRN,IERR,M%SAVE1)
      IF (TWO_D .AND. .NOT.CYLINDRICAL) CALL H2CZIS(XS,XF,IBAR,LBC,ZS,ZF,KBAR,NBC,M%HX,XLM,ITRN,IERR,M%SAVE1)
      IF (TWO_D .AND. CYLINDRICAL) THEN
         IF (ABS(XS)<=TWO_EPSILON_EB .AND. LBC==FISHPAK_BC_DIRICHLET_DIRICHLET) LBC = 5
         IF (ABS(XS)<=TWO_EPSILON_EB .AND. LBC==FISHPAK_BC_DIRICHLET_NEUMANN)   LBC = 6
         IF (ABS(XS)<=TWO_EPSILON_EB .AND. LBC==FISHPAK_BC_NEUMANN_NEUMANN)     LBC = 6
         IF (ABS(XS)<=TWO_EPSILON_EB .AND. LBC==FISHPAK_BC_NEUMANN_DIRICHLET)   LBC = 5
         CALL H2CYIS(XS,XF,IBAR,LBC,ZS,ZF,KBAR,NBC,XLM,XMU,ITRN,IERR,M%SAVE1)
      ENDIF
      IF (EXTERNAL_BOUNDARY_CORRECTION) THEN
         IF (.NOT.TWO_D) CALL H3CZIS(XS,XF,IBAR,LBC2,YS,YF,JBAR,MBC2,ZS,ZF,KBAR,NBC2,M%HX,XLM,ITRN,JTRN,IERR,M%SAVE2)
      ENDIF
   CASE (2) SELECT_POISSON_SOLVER
      CALL H3CZIS(YS,YF,JBAR,MBC,XS,XF,IBAR,LBC,ZS,ZF,KBAR,NBC,M%HY,XLM,ITRN,JTRN,IERR,M%SAVE1)
   CASE (3) SELECT_POISSON_SOLVER
      IF (TWO_D) THEN
         CALL H2CZIS(ZS,ZF,KBAR,NBC,XS,XF,IBAR,LBC,M%HZ,XLM,ITRN,IERR,M%SAVE1)
      ELSE
         CALL H3CZIS(ZS,ZF,KBAR,NBC,YS,YF,JBAR,MBC,XS,XF,IBAR,LBC,M%HZ,XLM,ITRN,JTRN,IERR,M%SAVE1)
      ENDIF
   CASE (4) SELECT_POISSON_SOLVER
      CALL H3CSIS(XS,XF,IBAR,LBC,YS,YF,JBAR,MBC,ZS,ZF,KBAR,NBC,XLM,ITRN,JTRN,IERR,M%SAVE1,M%WORK,M%HX,M%HY)
   CASE (5) SELECT_POISSON_SOLVER
      IF (TWO_D) THEN
         CALL H2CZIS(ZS,ZF,KBAR,NBC,XS,XF,IBAR,LBC,M%HZ,XLM,ITRN,IERR,M%SAVE1)
      ELSE
         CALL H3CSIS(XS,XF,IBAR,LBC,ZS,ZF,KBAR,NBC,YS,YF,JBAR,MBC,XLM,ITRN,JTRN,IERR,M%SAVE1,M%WORK,M%HX,M%HZ)
      ENDIF
   CASE (6) SELECT_POISSON_SOLVER
      CALL H3CSIS(ZS,ZF,KBAR,NBC,YS,YF,JBAR,MBC,XS,XF,IBAR,LBC,XLM,ITRN,JTRN,IERR,M%SAVE1,M%WORK,M%HZ,M%HY)
   CASE (7) SELECT_POISSON_SOLVER
      CALL H2CZIS(XS,XF,IBAR,LBC,YS,YF,JBAR,MBC,M%HX,XLM,ITRN,IERR,M%SAVE1)

END SELECT SELECT_POISSON_SOLVER

! Specify the pressure boundary condition for each wall cell

WALL_CELL_LOOP: DO IW=1,M%N_EXTERNAL_WALL_CELLS
   WC => M%WALL(IW)
   IOR = WC%ONE_D%IOR
   SELECT CASE(IOR)
      CASE( 1)
         IF (LBC==FISHPAK_BC_NEUMANN_NEUMANN     .OR. &
             LBC==FISHPAK_BC_NEUMANN_DIRICHLET   .OR. LBC==6) WC%PRESSURE_BC_INDEX = NEUMANN
         IF (LBC==FISHPAK_BC_DIRICHLET_DIRICHLET .OR. &
             LBC==FISHPAK_BC_DIRICHLET_NEUMANN   .OR. LBC==5) WC%PRESSURE_BC_INDEX = DIRICHLET
      CASE(-1)
         IF (LBC==FISHPAK_BC_DIRICHLET_NEUMANN   .OR. &
             LBC==FISHPAK_BC_NEUMANN_NEUMANN     .OR. LBC==6) WC%PRESSURE_BC_INDEX = NEUMANN
         IF (LBC==FISHPAK_BC_DIRICHLET_DIRICHLET .OR. &
             LBC==FISHPAK_BC_NEUMANN_DIRICHLET   .OR. LBC==5) WC%PRESSURE_BC_INDEX = DIRICHLET
      CASE( 2)
         IF (MBC==FISHPAK_BC_NEUMANN_NEUMANN     .OR. MBC==FISHPAK_BC_NEUMANN_DIRICHLET) WC%PRESSURE_BC_INDEX = NEUMANN
         IF (MBC==FISHPAK_BC_DIRICHLET_DIRICHLET .OR. MBC==FISHPAK_BC_DIRICHLET_NEUMANN) WC%PRESSURE_BC_INDEX = DIRICHLET
      CASE(-2)
         IF (MBC==FISHPAK_BC_NEUMANN_NEUMANN     .OR. MBC==FISHPAK_BC_DIRICHLET_NEUMANN) WC%PRESSURE_BC_INDEX = NEUMANN
         IF (MBC==FISHPAK_BC_DIRICHLET_DIRICHLET .OR. MBC==FISHPAK_BC_NEUMANN_DIRICHLET) WC%PRESSURE_BC_INDEX = DIRICHLET
      CASE( 3)
         IF (NBC==FISHPAK_BC_NEUMANN_NEUMANN     .OR. NBC==FISHPAK_BC_NEUMANN_DIRICHLET) WC%PRESSURE_BC_INDEX = NEUMANN
         IF (NBC==FISHPAK_BC_DIRICHLET_DIRICHLET .OR. NBC==FISHPAK_BC_DIRICHLET_NEUMANN) WC%PRESSURE_BC_INDEX = DIRICHLET
      CASE(-3)
         IF (NBC==FISHPAK_BC_NEUMANN_NEUMANN     .OR. NBC==FISHPAK_BC_DIRICHLET_NEUMANN) WC%PRESSURE_BC_INDEX = NEUMANN
         IF (NBC==FISHPAK_BC_DIRICHLET_DIRICHLET .OR. NBC==FISHPAK_BC_NEUMANN_DIRICHLET) WC%PRESSURE_BC_INDEX = DIRICHLET
   END SELECT
ENDDO WALL_CELL_LOOP

IF (EXTERNAL_BOUNDARY_CORRECTION) THEN
   WALL_CELL_LOOP_2: DO IW=1,M%N_EXTERNAL_WALL_CELLS
      WC => M%WALL(IW)
      IOR = WC%ONE_D%IOR
      WC%LAPLACE_BC_INDEX = NEUMANN
      SELECT CASE(IOR)
         CASE( 1)
            IF (LBC2==FISHPAK_BC_DIRICHLET_DIRICHLET .OR. &
                LBC2==FISHPAK_BC_DIRICHLET_NEUMANN   .OR. LBC2==5) WC%LAPLACE_BC_INDEX = DIRICHLET
         CASE(-1)
            IF (LBC2==FISHPAK_BC_DIRICHLET_DIRICHLET .OR. &
                LBC2==FISHPAK_BC_NEUMANN_DIRICHLET   .OR. LBC2==5) WC%LAPLACE_BC_INDEX = DIRICHLET
         CASE( 2)
            IF (MBC2==FISHPAK_BC_DIRICHLET_DIRICHLET .OR. MBC2==FISHPAK_BC_DIRICHLET_NEUMANN) WC%LAPLACE_BC_INDEX = DIRICHLET
         CASE(-2)
            IF (MBC2==FISHPAK_BC_DIRICHLET_DIRICHLET .OR. MBC2==FISHPAK_BC_NEUMANN_DIRICHLET) WC%LAPLACE_BC_INDEX = DIRICHLET
         CASE( 3)
            IF (NBC2==FISHPAK_BC_DIRICHLET_DIRICHLET .OR. NBC2==FISHPAK_BC_DIRICHLET_NEUMANN) WC%LAPLACE_BC_INDEX = DIRICHLET
         CASE(-3)
            IF (NBC2==FISHPAK_BC_DIRICHLET_DIRICHLET .OR. NBC2==FISHPAK_BC_NEUMANN_DIRICHLET) WC%LAPLACE_BC_INDEX = DIRICHLET
      END SELECT
   ENDDO WALL_CELL_LOOP_2
ENDIF

! Check for errors with Poisson solver initialization

IF (IERR/=0) THEN
   WRITE(LU_ERR,'(A,I2,A,I3)') 'ERROR: Poisson initialization error, Number=',IERR, ', Mesh=',NM
   STOP_STATUS = SETUP_STOP
   RETURN
ENDIF

END SUBROUTINE INITIALIZE_POISSON_SOLVER


!SUBROUTINE INITIALIZE_LAPLACE_SOLVER
!USE PRES, ONLY: BUILD_SPARSE_MATRIX_LAPLACE
!USE MKL_DSS
!TYPE(MKL_DSS_HANDLE) :: handle
!INTEGER :: IERR,perm(1)
!
!IF (.NOT.LAPLACE_PRESSURE_CORRECTION) RETURN
!
!CALL BUILD_SPARSE_MATRIX_LAPLACE(NM)
!
!! Initialize the solver
!IERR = dss_create( handle, MKL_DSS_DEFAULTS )
!
!! Define the non-zero structure of the matrix
!IERR = dss_define_structure( handle, MKL_DSS_SYMMETRIC, M%A_ROW_INDEX, M%A_N_ROWS, M%A_N_COLS, M%A_COLUMNS, M%A_N_ELEMENTS )
!print *,'dss_define_structure complete...'
!
!! Reorder the matrix
!perm(1)=0
!IERR = dss_reorder( handle, MKL_DSS_DEFAULTS, perm )
!print *,'dss_reorder complete...'
!
!! Factor the matrix
!IERR = dss_factor_real( handle, MKL_DSS_DEFAULTS, M%A_VALUES )
!print *,'dss_factor_real complete...'
!
!stop
!
!END SUBROUTINE INITIALIZE_LAPLACE_SOLVER


SUBROUTINE INITIALIZE_INTERPOLATION

! Create arrays by which info is to exchanged across meshes

INTEGER :: NOM,I,J,K
TYPE (MESH_TYPE), POINTER :: M2

ALLOCATE(M%INTERPOLATED_MESH(1:M%IBAR,1:M%JBAR,1:M%KBAR),  STAT=IZERO)
CALL ChkMemErr('INIT','INTERPOLATED_MESH',IZERO)
M%INTERPOLATED_MESH = 0

IF (EVACUATION_ONLY(NM)) RETURN

DO K=1,M%KBAR
   DO J=1,M%JBAR
      DO I=1,M%IBAR
         OTHER_MESH_LOOP: DO NOM=1,NM-1
            M2=>MESHES(NOM)
            IF (M%X(I-1)>=M2%XS .AND. M%X(I)<=M2%XF .AND.  M%Y(J-1)>=M2%YS .AND. M%Y(J)<=M2%YF .AND. &
                M%Z(K-1)>=M2%ZS .AND. M%Z(K)<=M2%ZF) THEN
               M%INTERPOLATED_MESH(I,J,K) = NOM
               EXIT OTHER_MESH_LOOP
            ENDIF
         ENDDO OTHER_MESH_LOOP
      ENDDO
   ENDDO
ENDDO

END SUBROUTINE INITIALIZE_INTERPOLATION

END SUBROUTINE INITIALIZE_MESH_VARIABLES_2



SUBROUTINE INITIALIZE_DEVICES(NM)

! Find the WALL_INDEX for a device that is near a solid wall

INTEGER, INTENT(IN) :: NM
INTEGER :: III,N,II,JJ,KK,IOR,IW,SURF_INDEX
REAL(EB) :: DEPTH
TYPE (DEVICE_TYPE), POINTER :: DV
TYPE (MESH_TYPE), POINTER :: M

M => MESHES(NM)

DEVICE_LOOP: DO N=1,N_DEVC

   DV => DEVICE(N)
   IF (DV%OUTPUT_INDEX>=0) CYCLE DEVICE_LOOP

   IF (DV%INIT_ID=='null') THEN ! Assume the device is tied to a wall cell

      IF (NM/=DV%MESH) CYCLE DEVICE_LOOP
      II  = GINV(DV%X-M%XS,1,NM)*M%RDXI   + 1._EB
      JJ  = GINV(DV%Y-M%YS,2,NM)*M%RDETA  + 1._EB
      KK  = GINV(DV%Z-M%ZS,3,NM)*M%RDZETA + 1._EB
      IOR = DV%IOR
      CALL GET_WALL_INDEX(NM,II,JJ,KK,IOR,IW)

      IF (IW==0 .AND. DV%STATISTICS=='null') THEN
         WRITE(LU_ERR,'(A,I4,A)') 'ERROR: Reposition DEVC No.',DV%ORDINAL,'. FDS cannot determine which boundary cell to assign.'
         STOP_STATUS = SETUP_STOP
         RETURN
      ELSE
         DV%WALL_INDEX = IW
         SURF_INDEX = M%WALL(IW)%SURF_INDEX
      ENDIF
      IF (IW==0) SURF_INDEX = DV%SURF_INDEX

   ELSE ! Assume the device is tied to a particle

      IF (DV%PART_INDEX<1) CYCLE DEVICE_LOOP
      SURF_INDEX = LAGRANGIAN_PARTICLE_CLASS(DV%PART_INDEX)%SURF_INDEX

   ENDIF

   ! Make sure that thermally-thick output is appropriate

   IF (OUTPUT_QUANTITY(DV%OUTPUT_INDEX)%INSIDE_SOLID) THEN
      IF (SURFACE(SURF_INDEX)%THERMAL_BC_INDEX /= THERMALLY_THICK) THEN
         WRITE(LU_ERR,'(A,I3,A)') 'ERROR: DEViCe ',N, ' must be associated with a heat-conducting surface'
         STOP_STATUS = SETUP_STOP
         RETURN
      ENDIF
      IF (DV%DEPTH>EPSILON_EB) THEN
         DEPTH = DV%DEPTH
      ELSE
         DEPTH = MAX(0._EB,SUM(SURFACE(SURF_INDEX)%LAYER_THICKNESS)+DV%DEPTH)
      ENDIF
      DV%I_DEPTH = SURFACE(SURF_INDEX)%N_CELLS_INI
      DO III=SURFACE(SURF_INDEX)%N_CELLS_INI,1,-1
         IF (DEPTH<=SURFACE(SURF_INDEX)%X_S(III)) DV%I_DEPTH = III
      ENDDO
   ENDIF

ENDDO DEVICE_LOOP

END SUBROUTINE INITIALIZE_DEVICES


SUBROUTINE INITIALIZE_PROFILES(NM)

INTEGER, INTENT(IN) :: NM
INTEGER :: NN,N,II,JJ,KK,IW,IOR
LOGICAL :: SUCCESS
TYPE (PROFILE_TYPE), POINTER :: PF
TYPE (MESH_TYPE), POINTER :: M
TYPE (SURFACE_TYPE), POINTER :: SF

IF (EVACUATION_ONLY(NM)) RETURN

M => MESHES(NM)

PROF_LOOP: DO N=1,N_PROF
   PF => PROFILE(N)
   IF (NM/=PF%MESH) CYCLE PROF_LOOP
   II  = GINV(PF%X-M%XS,1,NM)*M%RDXI   + 1._EB
   JJ  = GINV(PF%Y-M%YS,2,NM)*M%RDETA  + 1._EB
   KK  = GINV(PF%Z-M%ZS,3,NM)*M%RDZETA + 1._EB
   IOR = PF%IOR
   CALL GET_WALL_INDEX(NM,II,JJ,KK,IOR,IW)
   IF (IW>0) THEN
      PF%IW = IW
      SF => SURFACE(M%WALL(IW)%SURF_INDEX)
      IF (.NOT.SF%THERMALLY_THICK) THEN
         WRITE(LU_ERR,'(A,I3,A)') 'ERROR: PROFile ',N, ' must be associated with a heat-conducting surface'
         STOP_STATUS = SETUP_STOP
         RETURN
      ENDIF
      IF (PF%QUANTITY /= 'TEMPERATURE' .AND. PF%QUANTITY /= 'DENSITY') THEN
         SUCCESS = .FALSE.
         DO NN=1,SF%N_MATL
            IF (PF%QUANTITY==SF%MATL_NAME(NN)) SUCCESS = .TRUE.
         ENDDO
         IF (.NOT.SUCCESS) THEN
            WRITE(LU_ERR,'(A,A,A)') 'ERROR: QUANTITY ',TRIM(PF%QUANTITY), ' is not appropriate for the designated location'
            STOP_STATUS = SETUP_STOP
            RETURN
         ENDIF
      ENDIF
   ELSE
      WRITE(LU_ERR,'(A,I4,A)') 'ERROR: Reposition PROF No.',PF%ORDINAL, '. FDS cannot determine which boundary cell to assign'
      STOP_STATUS = SETUP_STOP
      RETURN
   ENDIF
ENDDO PROF_LOOP

END SUBROUTINE INITIALIZE_PROFILES


SUBROUTINE GET_WALL_INDEX(NM,II,JJ,KK,IOR,IW)

! Find the wall index corresponding to the -IOR face of cell (II,JJ,KK)

INTEGER, INTENT(IN) :: NM,IOR
INTEGER, INTENT(OUT) :: IW
INTEGER :: IC,II,JJ,KK
TYPE (MESH_TYPE), POINTER :: M

M => MESHES(NM)
IC  = M%CELL_INDEX(II,JJ,KK)

IF (M%SOLID(IC)) THEN
   SELECT CASE(IOR)
      CASE(-1)
         IF (II>0)      II = II-1
      CASE( 1)
         IF (II<M%IBP1) II = II+1
      CASE(-2)
         IF (JJ>0)      JJ = JJ-1
      CASE( 2)
         IF (JJ<M%JBP1) JJ = JJ+1
      CASE(-3)
         IF (KK>0)      KK = KK-1
      CASE( 3)
         IF (KK<M%KBP1) KK = KK+1
   END SELECT
ENDIF

IC  = M%CELL_INDEX(II,JJ,KK)
IW  = M%WALL_INDEX(IC,-IOR)

IF (IW<=0) THEN
   SELECT CASE(IOR)
      CASE(-1)
         IF (II>0)      IC = M%CELL_INDEX(II-1,JJ,KK)
      CASE( 1)
         IF (II<M%IBP1) IC = M%CELL_INDEX(II+1,JJ,KK)
      CASE(-2)
         IF (JJ>0)      IC = M%CELL_INDEX(II,JJ-1,KK)
      CASE( 2)
         IF (JJ<M%JBP1) IC = M%CELL_INDEX(II,JJ+1,KK)
      CASE(-3)
         IF (KK>0)      IC = M%CELL_INDEX(II,JJ,KK-1)
      CASE( 3)
         IF (KK<M%KBP1) IC = M%CELL_INDEX(II,JJ,KK+1)
   END SELECT
   IW = M%WALL_INDEX(IC,-IOR)
ENDIF

END SUBROUTINE GET_WALL_INDEX



SUBROUTINE INITIALIZE_GLOBAL_VARIABLES

USE CONTROL_VARIABLES, ONLY: N_CTRL
INTEGER :: IZERO

! Initialize time, printout and plot clocks

ALLOCATE(PART_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','PART_CLOCK',IZERO)
ALLOCATE(ISOF_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','ISOF_CLOCK',IZERO)
ALLOCATE(BNDF_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','BNDF_CLOCK',IZERO)
ALLOCATE(SLCF_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','SLCF_CLOCK',IZERO)
ALLOCATE(SL3D_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','SLCF_CLOCK',IZERO)
ALLOCATE(PL3D_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','PL3D_CLOCK',IZERO)
ALLOCATE(PROF_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','PROF_CLOCK',IZERO)

ICYC              = 0
PART_CLOCK        = T_BEGIN
DEVC_CLOCK        = T_BEGIN
CTRL_CLOCK        = T_BEGIN
PROF_CLOCK        = T_BEGIN
PL3D_CLOCK        = T_BEGIN + DT_PL3D
ISOF_CLOCK        = T_BEGIN
SLCF_CLOCK        = T_BEGIN
SL3D_CLOCK        = T_BEGIN + DT_SL3D
GEOC_CLOCK        = T_BEGIN
GEOM_CLOCK        = T_BEGIN
BNDC_CLOCK        = T_BEGIN
BNDE_CLOCK        = T_BEGIN
BNDF_CLOCK        = T_BEGIN
RESTART_CLOCK     = T_BEGIN + DT_RESTART
FLUSH_CLOCK       = T_BEGIN + DT_FLUSH
HRR_CLOCK         = T_BEGIN
CPU_CLOCK         = T_BEGIN + DT_CPU
MINT_CLOCK        = T_BEGIN
T_LAST_DUMP_HRR   = T_BEGIN
T_LAST_DUMP_MASS  = T_BEGIN

IF (N_DEVC==0)      DEVC_CLOCK = 1.E10_EB
IF (N_CTRL==0)      CTRL_CLOCK = 1.E10_EB
IF (N_PROF==0)      PROF_CLOCK = 1.E10_EB
IF (N_ISOF==0)      ISOF_CLOCK = 1.E10_EB
IF (N_FACE==0)      GEOC_CLOCK = 1.E10_EB
IF (N_FACE==0)      GEOM_CLOCK = 1.E10_EB
IF (N_FACE==0)      BNDC_CLOCK = 1.E10_EB
IF (N_BNDE==0)      BNDE_CLOCK = 1.E10_EB
IF (N_BNDF==0)      BNDF_CLOCK = 1.E10_EB
IF (.NOT.MASS_FILE) MINT_CLOCK = 1.E10_EB

ALLOCATE(SPECIFIC_ENTHALPY_SUM(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','SPECIFIC_ENTHALPY_SUM',IZERO)
SPECIFIC_ENTHALPY_SUM = 0._EB
ALLOCATE(Q_DOT(N_Q_DOT,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','Q_DOT',IZERO)
Q_DOT = 0._EB
ALLOCATE(Q_DOT_SUM(N_Q_DOT,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','Q_DOT_SUM',IZERO)
Q_DOT_SUM = 0._EB
ALLOCATE(M_DOT(N_M_DOT,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','M_DOT',IZERO)
M_DOT = 0._EB
ALLOCATE(M_DOT_SUM(N_M_DOT,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','M_DOT_SUM',IZERO)
M_DOT_SUM=0._EB

ALLOCATE(MINT(0:MINT_SPECIES,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','MINT',IZERO)
ALLOCATE(MINT_SUM(0:MINT_SPECIES,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','MINT_SUM',IZERO)
MINT_SUM=0._EB

ALLOCATE(DSUM(N_ZONE,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','DSUM',IZERO)
DSUM = 0._EB
ALLOCATE(PSUM(N_ZONE,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','PSUM',IZERO)
PSUM = 0._EB
ALLOCATE(USUM(N_ZONE,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','USUM',IZERO)
USUM = 0._EB

ALLOCATE(PRESSURE_ERROR_MAX(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','PRESSURE_ERROR_MAX',IZERO)
ALLOCATE(PRESSURE_ERROR_MAX_LOC(3,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','PRESSURE_ERROR_MAX_LOC',IZERO)
PRESSURE_ERROR_MAX     = 0._EB
PRESSURE_ERROR_MAX_LOC = 0._EB

ALLOCATE(VELOCITY_ERROR_MAX(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','VELOCITY_ERROR_MAX',IZERO)
ALLOCATE(VELOCITY_ERROR_MAX_LOC(3,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','VELOCITY_ERROR_MAX_LOC',IZERO)
VELOCITY_ERROR_MAX     = 0._EB
VELOCITY_ERROR_MAX_LOC = 0

END SUBROUTINE INITIALIZE_GLOBAL_VARIABLES


SUBROUTINE INIT_WALL_CELL(NM,I,J,K,OBST_INDEX,IW,IOR,SURF_INDEX,IERR,TT)

! Initialize wall cell variables at external and obstruction boundaries

USE MATH_FUNCTIONS, ONLY: EVALUATE_RAMP
USE MEMORY_FUNCTIONS, ONLY: ALLOCATE_STORAGE
USE GEOMETRY_FUNCTIONS, ONLY: SEARCH_OTHER_MESHES
USE COMP_FUNCTIONS, ONLY: SHUTDOWN
USE PHYSICAL_FUNCTIONS, ONLY: GET_SPECIFIC_GAS_CONSTANT
INTEGER, INTENT(IN) :: I,J,K,NM,OBST_INDEX,IW,IOR,SURF_INDEX
INTEGER  :: NOM_FOUND,NOM=0,ITER,IIO_MIN,IIO_MAX,JJO_MIN,JJO_MAX,KKO_MIN,KKO_MAX,VENT_INDEX
INTEGER, INTENT(OUT) :: IERR
REAL(EB), INTENT(IN) :: TT
REAL(EB) :: PX,PY,PZ,T_ACTIVATE,XIN,YIN,ZIN,DIST,XW,YW,ZW,UW,RDN,AW,TSI,&
            ZZ_GET(1:N_TRACKED_SPECIES),RSUM_F,R1,RR,DELTA
INTEGER  :: N,SURF_INDEX_NEW,IIG,JJG,KKG,IIO,JJO,KKO,IC,ICG,NOM_CHECK(0:1),BOUNDARY_TYPE
INTEGER :: NSLICE
LOGICAL :: VENT_FOUND,ALIGNED
TYPE (MESH_TYPE), POINTER :: M,MM=>NULL()
TYPE (OBSTRUCTION_TYPE), POINTER :: OBX=>NULL()
TYPE (VENTS_TYPE), POINTER :: VT=>NULL()
TYPE (WALL_TYPE), POINTER :: WC=>NULL()
TYPE (SURFACE_TYPE), POINTER :: SF

IERR = 0
M=>MESHES(NM)

! Determine if a VENT covers the surface

VENT_INDEX = 0
SURF_INDEX_NEW = SURF_INDEX
VENT_FOUND = .FALSE.

VENT_SEARCH_LOOP: DO N=1,M%N_VENT

   VT => M%VENTS(N)
   IF (OBST_INDEX>0) THEN
      IF (VT%BOUNDARY_TYPE==OPEN_BOUNDARY)           CYCLE VENT_SEARCH_LOOP
      IF (.NOT.M%OBSTRUCTION(OBST_INDEX)%ALLOW_VENT) CYCLE VENT_SEARCH_LOOP
   ENDIF
   IF (VT%IOR/=IOR) CYCLE VENT_SEARCH_LOOP

   IF (ABS(IOR)==1) THEN
      IF (IOR== 1 .AND. I/=VT%I1  ) CYCLE VENT_SEARCH_LOOP
      IF (IOR==-1 .AND. I/=VT%I1+1) CYCLE VENT_SEARCH_LOOP
      IF (J<VT%J1+1 .OR. J>VT%J2)   CYCLE VENT_SEARCH_LOOP
      IF (K<VT%K1+1 .OR. K>VT%K2)   CYCLE VENT_SEARCH_LOOP
      IF ( VT%RADIUS>0._EB .AND. ((M%YC(J)-VT%Y0)**2 + (M%ZC(K)-VT%Z0)**2)>(VT%RADIUS**2) ) CYCLE VENT_SEARCH_LOOP
   ENDIF
   IF (ABS(IOR)==2) THEN
      IF (IOR== 2 .AND. J/=VT%J1  ) CYCLE VENT_SEARCH_LOOP
      IF (IOR==-2 .AND. J/=VT%J1+1) CYCLE VENT_SEARCH_LOOP
      IF (I<VT%I1+1 .OR. I>VT%I2)   CYCLE VENT_SEARCH_LOOP
      IF (K<VT%K1+1 .OR. K>VT%K2)   CYCLE VENT_SEARCH_LOOP
      IF ( VT%RADIUS>0._EB .AND. ((M%XC(I)-VT%X0)**2 + (M%ZC(K)-VT%Z0)**2)>(VT%RADIUS**2) ) CYCLE VENT_SEARCH_LOOP
   ENDIF
   IF (ABS(IOR)==3) THEN
      IF (IOR== 3 .AND. K/=VT%K1  ) CYCLE VENT_SEARCH_LOOP
      IF (IOR==-3 .AND. K/=VT%K1+1) CYCLE VENT_SEARCH_LOOP
      IF (I<VT%I1+1 .OR. I>VT%I2)   CYCLE VENT_SEARCH_LOOP
      IF (J<VT%J1+1 .OR. J>VT%J2)   CYCLE VENT_SEARCH_LOOP
      IF ( VT%RADIUS>0._EB .AND. ((M%XC(I)-VT%X0)**2 + (M%YC(J)-VT%Y0)**2)>(VT%RADIUS**2) ) CYCLE VENT_SEARCH_LOOP
   ENDIF

   ! Check if there are over-lapping VENTs

   IF (VENT_FOUND) THEN
      WRITE(LU_ERR,'(A,I0,A,3(I0,1X),A,I0,A)') 'WARNING: Two VENTs overlap in MESH ',NM,', Cell ',I,J,K,'. VENT ', &
                                           VT%ORDINAL,' rejected for that cell'
      EXIT VENT_SEARCH_LOOP
   ENDIF

   VENT_FOUND = .TRUE.

   ! Reassign the SURF index to be that of the VENT

   VENT_INDEX = N
   SURF_INDEX_NEW = VT%SURF_INDEX

ENDDO VENT_SEARCH_LOOP

! Compute boundary cell physical coords (XW,YW,ZW) and area (AW)

IF (ABS(IOR)==1) THEN
   IF (IOR== 1) THEN
      XW     = M%X(I)
      IIG    = I+1
      RDN    = M%RDXN(I)
      AW     = M%R(I)*M%DY(J)*M%DZ(K)
      UW     = -U0
   ENDIF
   IF (IOR==-1) THEN
      XW     = M%X(I-1)
      IIG    = I-1
      RDN    = M%RDXN(I-1)
      AW     = M%R(I-1)*M%DY(J)*M%DZ(K)
      UW     = U0
   ENDIF
   JJG    = J
   KKG    = K
   YW = M%YC(J)
   ZW = M%ZC(K)
ENDIF
IF (ABS(IOR)==2) THEN
   IF (IOR== 2) THEN
      YW     = M%Y(J)
      JJG    = J+1
      RDN    = M%RDYN(J)
      UW     = -V0
   ENDIF
   IF (IOR==-2) THEN
      YW     = M%Y(J-1)
      JJG    = J-1
      RDN    = M%RDYN(J-1)
      UW     = V0
   ENDIF
   IIG    = I
   KKG    = K
   XW = M%XC(I)
   ZW = M%ZC(K)
   AW = M%DX(I)*M%DZ(K)
ENDIF
IF (ABS(IOR)==3) THEN
   IF (IOR== 3) THEN
      ZW     = M%Z(K)
      KKG    = K+1
      RDN    = M%RDZN(K)
      UW     = -W0
   ENDIF
   IF (IOR==-3) THEN
      ZW     = M%Z(K-1)
      KKG    = K-1
      RDN    = M%RDZN(K-1)
      UW     = W0
   ENDIF
   IIG    = I
   JJG    = J
   XW = M%XC(I)
   YW = M%YC(J)
   AW = M%DX(I)*M%RC(I)*M%DY(J)
ENDIF

IF (IOR==0) THEN
   IIG = I
   JJG = J
   KKG = K
ENDIF

! Save the wall index

IC  = M%CELL_INDEX(I  ,J  ,K  )
ICG = M%CELL_INDEX(IIG,JJG,KKG)
M%WALL_INDEX(ICG,-IOR) = IW

! Use BOUNDARY_TYPE to indicate whether the boundary cell is blocked or on an obstruction that is HIDDEN

BOUNDARY_TYPE = NULL_BOUNDARY

IF (IW<=M%N_EXTERNAL_WALL_CELLS .AND. OBST_INDEX==0) BOUNDARY_TYPE = SOLID_BOUNDARY

IF (OBST_INDEX>0) THEN
   IF (.NOT.M%OBSTRUCTION(OBST_INDEX)%HIDDEN) THEN
      BOUNDARY_TYPE = SOLID_BOUNDARY
      IF (IW<=M%N_EXTERNAL_WALL_CELLS) M%SOLID(IC) = .TRUE.
   ENDIF
ENDIF

IF (M%SOLID(ICG)) BOUNDARY_TYPE = NULL_BOUNDARY

! Check for neighboring meshes in a multiple mesh calculation

NOM_FOUND = 0
IIO_MIN =  1000000
IIO_MAX = -1000000
JJO_MIN =  1000000
JJO_MAX = -1000000
KKO_MIN =  1000000
KKO_MAX = -1000000
NOM_CHECK = 0

CHECK_MESHES: IF (IW<=M%N_EXTERNAL_WALL_CELLS .AND. .NOT.EVACUATION_ONLY(NM)) THEN

   DO ITER=0,1
      XIN = XW
      YIN = YW
      ZIN = ZW
      IF (SURF_INDEX_NEW==PERIODIC_SURF_INDEX .OR. SURF_INDEX_NEW==PERIODIC_WIND_SURF_INDEX) THEN
         SELECT CASE(IOR)
            CASE( 1) ; XIN = XF_MAX
            CASE(-1) ; XIN = XS_MIN
            CASE( 2) ; YIN = YF_MAX
            CASE(-2) ; YIN = YS_MIN
            CASE( 3) ; ZIN = ZF_MAX
            CASE(-3) ; ZIN = ZS_MIN
         END SELECT
      ENDIF
      IF (ABS(IOR)/=1) XIN = XW + (ITER*0.95_EB-0.475_EB)*(M%X(I)-M%X(I-1))
      IF (ABS(IOR)/=2) YIN = YW + (ITER*0.95_EB-0.475_EB)*(M%Y(J)-M%Y(J-1))
      IF (ABS(IOR)/=3) ZIN = ZW + (ITER*0.95_EB-0.475_EB)*(M%Z(K)-M%Z(K-1))
      IF (IOR== 1) XIN = XIN - 0.05*M%DX(0)
      IF (IOR==-1) XIN = XIN + 0.05*M%DX(M%IBP1)
      IF (IOR== 2) YIN = YIN - 0.05*M%DY(0)
      IF (IOR==-2) YIN = YIN + 0.05*M%DY(M%JBP1)
      IF (IOR== 3) ZIN = ZIN - 0.05*M%DZ(0)
      IF (IOR==-3) ZIN = ZIN + 0.05*M%DZ(M%KBP1)
      CALL SEARCH_OTHER_MESHES(XIN,YIN,ZIN,NOM,IIO,JJO,KKO)
      NOM_CHECK(ITER) = NOM
      IF (NOM/=0) THEN
         IIO_MIN = MIN(IIO_MIN,IIO)
         IIO_MAX = MAX(IIO_MAX,IIO)
         JJO_MIN = MIN(JJO_MIN,JJO)
         JJO_MAX = MAX(JJO_MAX,JJO)
         KKO_MIN = MIN(KKO_MIN,KKO)
         KKO_MAX = MAX(KKO_MAX,KKO)
      ENDIF
   ENDDO

   ! Check to see if the current interpolated cell face spans more than one other mesh

   IF (NOM_CHECK(0)/=NOM_CHECK(1)) THEN
      WRITE(LU_ERR,'(A,I3,A,I3)') 'ERROR: MESH ',NM,' is not in alignment with MESH ',MAXVAL(NOM_CHECK)
      STOP_STATUS = SETUP_STOP
      IERR = 1
      RETURN
   ENDIF

   FOUND_OTHER_MESH: IF (NOM>0) THEN
      MM=>MESHES(NOM)
      ALIGNED = .TRUE.
      IF ( (ABS(IOR)==2 .OR. ABS(IOR)==3) .AND. MM%DX(IIO_MIN)<=M%DX(I) ) THEN
         IF (ABS( ((MM%X(IIO_MAX)-MM%X(IIO_MIN-1))-(M%X(I)-M%X(I-1))) / MM%DX(IIO_MIN))>0.01 ) ALIGNED = .FALSE.
      ENDIF
      IF ( (ABS(IOR)==1 .OR. ABS(IOR)==3) .AND. MM%DY(JJO_MIN)<=M%DY(J) ) THEN
         IF (ABS( ((MM%Y(JJO_MAX)-MM%Y(JJO_MIN-1))-(M%Y(J)-M%Y(J-1))) / MM%DY(JJO_MIN))>0.01 ) ALIGNED = .FALSE.
      ENDIF
      IF ( (ABS(IOR)==1 .OR. ABS(IOR)==2) .AND. MM%DZ(KKO_MIN)<=M%DZ(K) ) THEN
         IF (ABS( ((MM%Z(KKO_MAX)-MM%Z(KKO_MIN-1))-(M%Z(K)-M%Z(K-1))) / MM%DZ(KKO_MIN))>0.01 ) ALIGNED = .FALSE.
      ENDIF
      IF (.NOT.ALIGNED) THEN
         WRITE(LU_ERR,'(A,I3,A,I3)') 'ERROR: MESH ',NM,' is out of alignment with MESH ',NOM
         STOP_STATUS = SETUP_STOP
         IERR = 1
         RETURN
      ENDIF

      SELECT CASE(ABS(IOR))
         CASE(1)
            IF ( (M%DY(J)<0.99_EB*MM%DY(JJO_MIN)) .AND. (M%DZ(K)>1.01_EB*MM%DZ(KKO_MIN)) ) ALIGNED = .FALSE.
            IF ( (M%DY(J)>1.01_EB*MM%DY(JJO_MIN)) .AND. (M%DZ(K)<0.99_EB*MM%DZ(KKO_MIN)) ) ALIGNED = .FALSE.
         CASE(2)
            IF ( (M%DX(I)<0.99_EB*MM%DX(IIO_MIN)) .AND. (M%DZ(K)>1.01_EB*MM%DZ(KKO_MIN)) ) ALIGNED = .FALSE.
            IF ( (M%DX(I)>1.01_EB*MM%DX(IIO_MIN)) .AND. (M%DZ(K)<0.99_EB*MM%DZ(KKO_MIN)) ) ALIGNED = .FALSE.
         CASE(3)
            IF ( (M%DY(J)<0.99_EB*MM%DY(JJO_MIN)) .AND. (M%DX(I)>1.01_EB*MM%DX(IIO_MIN)) ) ALIGNED = .FALSE.
            IF ( (M%DY(J)>1.01_EB*MM%DY(JJO_MIN)) .AND. (M%DX(I)<0.99_EB*MM%DX(IIO_MIN)) ) ALIGNED = .FALSE.
      END SELECT
      IF (.NOT.ALIGNED) THEN
         WRITE(LU_ERR,'(A,I3,A,I3)') 'ERROR: MESH ',NM,' is finer in one direction and coarser in the other than MESH ',NOM
         STOP_STATUS = SETUP_STOP
         IERR = 1
         RETURN
      ENDIF

      ! NOM = "Number of the Other Mesh"
      !
      !     Mesh 1       Mesh 2
      !      3x6          1x2
      !  -------------------------
      !  |   |   |   |           |
      !  |---|---|---|           |
      !  |   |   |   #->         |
      !  |---|---|---|           |
      !  |   |   | <-*           |
      !  |---|---|---|-----------|
      !  |   |   |   |           |
      !  |---|---|---|           |
      !  |   |   |   |           |
      !  |---|---|---|           |
      !  |   |   |   |           |
      !  -------------------------
      !
      !                         NM=1,NOM=2,IW=*        NM=2,NOM=1,IW=#

      NOM_FOUND = NOM

      IF (OBST_INDEX==0) THEN
         IF (.NOT.M%SOLID(ICG)) BOUNDARY_TYPE = INTERPOLATED_BOUNDARY
         IF (SURF_INDEX_NEW/=PERIODIC_WIND_SURF_INDEX) SURF_INDEX_NEW = INTERPOLATED_SURF_INDEX
         VENT_INDEX = 0
      ENDIF

      IF (BOUNDARY_TYPE == INTERPOLATED_BOUNDARY) M%SOLID(M%CELL_INDEX(I,J,K)) = .FALSE.

   ENDIF FOUND_OTHER_MESH

ENDIF CHECK_MESHES

! Initialize solid properties included in the WALL derived type variable

CALL ALLOCATE_STORAGE(NM,SURF_INDEX_NEW,WALL_INDEX=IW)

! Initialize wall cell (WC) variables

SF => SURFACE(SURF_INDEX_NEW)
WC => M%WALL(IW)

WC%ONE_D%II = I
WC%ONE_D%JJ = J
WC%ONE_D%KK = K
WC%ONE_D%IOR = IOR
WC%SURF_INDEX = SURF_INDEX_NEW
WC%OBST_INDEX = OBST_INDEX
WC%BOUNDARY_TYPE = BOUNDARY_TYPE

WC%XW     = XW
WC%YW     = YW
WC%ZW     = ZW
WC%ONE_D%IIG    = IIG
WC%ONE_D%JJG    = JJG
WC%ONE_D%KKG    = KKG
WC%RDN    = RDN
WC%AW     = AW
IF (WC%AW>0._EB) WC%RAW = 1._EB/WC%AW
WC%ONE_D%UW     = UW
WC%ONE_D%UWS    = UW

IF (IW<=M%N_EXTERNAL_WALL_CELLS) THEN
   M%EXTERNAL_WALL(IW)%NOM     = NOM_FOUND
   M%EXTERNAL_WALL(IW)%IIO_MIN = IIO_MIN
   M%EXTERNAL_WALL(IW)%JJO_MIN = JJO_MIN
   M%EXTERNAL_WALL(IW)%KKO_MIN = KKO_MIN
   M%EXTERNAL_WALL(IW)%IIO_MAX = IIO_MAX
   M%EXTERNAL_WALL(IW)%JJO_MAX = JJO_MAX
   M%EXTERNAL_WALL(IW)%KKO_MAX = KKO_MAX
ENDIF

! If the simulation is only a TGA analysis, get the wall index

IF (WC%SURF_INDEX==TGA_SURF_INDEX) TGA_WALL_INDEX = IW

! Assign the ZONE number to all boundary cells

IF (.NOT.EVACUATION_ONLY(NM)) WC%PRESSURE_ZONE = M%PRESSURE_ZONE(IIG,JJG,KKG)

! Fill array containing K index of terrain following slice, used in dump slice

DO NSLICE = 1, M%N_TERRAIN_SLCF
   IF (IOR==3) M%K_AGL_SLICE(I,J,NSLICE) = M%K_AGL_SLICE(I,J,NSLICE) + WC%ONE_D%KKG
ENDDO

! Fill arrays containing K index and physical height of terrain for use in level set firespread

IF (VEG_LEVEL_SET .AND. IOR==3) THEN
  M%LS_Z_TERRAIN(WC%ONE_D%IIG,WC%ONE_D%JJG) = M%Z(WC%ONE_D%KKG-1)
ENDIF

! Do not assign normal velocities at boundaries of evacuation meshes

IF (EVACUATION_ONLY(NM)) WC%ONE_D%UW = 0._EB

! Assign internal values of temp, density, and mass fraction

WC%RHO_F = M%RHO(IIG,JJG,KKG)
WC%U_TAU = 0._EB
WC%Y_PLUS = 1._EB
WC%RHODW = 0._EB

IF (.NOT.EVACUATION_ONLY(NM) .AND. (M%SOLID(M%CELL_INDEX(I,J,K)).OR.IW<=M%N_EXTERNAL_WALL_CELLS)) THEN
   M%RSUM(I,J,K) = M%RSUM(IIG,JJG,KKG)
   WC%ZZ_F(1:N_TRACKED_SPECIES)  = M%ZZ(IIG,JJG,KKG,1:N_TRACKED_SPECIES)
   M%ZZ(I,J,K,1:N_TRACKED_SPECIES) = M%ZZ(IIG,JJG,KKG,1:N_TRACKED_SPECIES)
ENDIF

! Compute the mass of the grid cell corresponding to the wall cell

IF (OBST_INDEX>0 .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   OBX=>M%OBSTRUCTION(OBST_INDEX)
   WC%ONE_D%AREA_ADJUST = OBX%INPUT_AREA(ABS(IOR))/OBX%FDS_AREA(ABS(IOR))
   IF (WC%ONE_D%AREA_ADJUST<=TWO_EPSILON_EB) WC%ONE_D%AREA_ADJUST = 1._EB
   IF (OBX%MASS>1.E5_EB) THEN
      OBX%MASS = SF%SURFACE_DENSITY*WC%AW*WC%ONE_D%AREA_ADJUST
      IF (OBX%BULK_DENSITY>0._EB) OBX%MASS = OBX%BULK_DENSITY*(OBX%X2-OBX%X1)*(OBX%Y2-OBX%Y1)*(OBX%Z2-OBX%Z1)/OBX%VOLUME_ADJUST
   ENDIF
ENDIF

! Prescribe normal velocity for surface cell (UW0)

WC%UW0 = SF%VEL

IF (OBST_INDEX>0 .AND. ABS(SF%VOLUME_FLOW)>=TWO_EPSILON_EB .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   OBX=>M%OBSTRUCTION(OBST_INDEX)
   WC%UW0 = SF%VOLUME_FLOW*(OBX%INPUT_AREA(ABS(IOR))/OBX%UNDIVIDED_INPUT_AREA(ABS(IOR))) / OBX%FDS_AREA(ABS(IOR))
ENDIF
IF (OBST_INDEX>0 .AND. ABS(SF%MASS_FLUX_TOTAL)>=TWO_EPSILON_EB .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   OBX=>M%OBSTRUCTION(OBST_INDEX)
   WC%UW0 = SF%MASS_FLUX_TOTAL / RHOA * WC%ONE_D%AREA_ADJUST
ENDIF

! Do VENT-specific set-ups

T_ACTIVATE    = T_BEGIN-1._EB
WC%VENT_INDEX = VENT_INDEX

PROCESS_VENT: IF (WC%VENT_INDEX>0) THEN

   VT => M%VENTS(WC%VENT_INDEX)

   IF (.NOT.EVACUATION_ONLY(NM)) THEN
   WC%ONE_D%AREA_ADJUST = VT%INPUT_AREA/VT%FDS_AREA
   IF (WC%ONE_D%AREA_ADJUST<=TWO_EPSILON_EB) WC%ONE_D%AREA_ADJUST = 1._EB
   ENDIF

   ! Set the velocity at each surface cell

   WC%UW0 = SF%VEL

   IF (ABS(SF%VOLUME_FLOW)>TWO_EPSILON_EB)   THEN
      WC%UW0 = SF%VOLUME_FLOW*(VT%INPUT_AREA/VT%UNDIVIDED_INPUT_AREA)/VT%FDS_AREA
   ENDIF
   IF (ABS(SF%MASS_FLUX_TOTAL)>TWO_EPSILON_EB .AND. .NOT.EVACUATION_ONLY(NM)) THEN
      WC%UW0 = SF%MASS_FLUX_TOTAL/RHOA*WC%ONE_D%AREA_ADJUST
   ENDIF

   IF (SF%CONVERT_VOLUME_TO_MASS) THEN
      IF (ABS(WC%UW0)>TWO_EPSILON_EB) THEN
         ZZ_GET=0._EB
         ZZ_GET(1:N_TRACKED_SPECIES) = MAX(0._EB,SF%MASS_FRACTION(1:N_TRACKED_SPECIES))
         CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,RSUM_F)
         SF%MASS_FLUX = -RHOA*(RSUM0/RSUM_F)*(TMPA/SF%TMP_FRONT)*SF%MASS_FRACTION*WC%UW0
         SF%SPECIES_BC_INDEX = SPECIFIED_MASS_FLUX
      ELSE
         CALL SHUTDOWN('ERROR: SURF: '//TRIM(SF%ID)//' must specify velocity boundary condition for conversion')
         IERR = 1
         RETURN
      ENDIF
   ENDIF

   ! Special velocity profiles

   PARABOLIC_IF: IF (SF%PROFILE==PARABOLIC_PROFILE) THEN
      SELECT CASE(ABS(IOR))
         CASE(1)
            IF (VT%RADIUS>0._EB) THEN
               RR = (M%YC(J)-VT%Y0)**2 + (M%ZC(K)-VT%Z0)**2
               WC%UW0 = WC%UW0*(VT%RADIUS**2-RR)/VT%RADIUS**2
            ELSE
               PY = 4._EB*(M%YC(J)-VT%Y1_ORIG)*(VT%Y2_ORIG-M%YC(J))/(VT%Y2_ORIG-VT%Y1_ORIG)**2
               PZ = 4._EB*(M%ZC(K)-VT%Z1_ORIG)*(VT%Z2_ORIG-M%ZC(K))/(VT%Z2_ORIG-VT%Z1_ORIG)**2
               WC%UW0 = WC%UW0*PY*PZ
            ENDIF
         CASE(2)
            IF (VT%RADIUS>0._EB) THEN
               RR = (M%XC(I)-VT%X0)**2 + (M%ZC(K)-VT%Z0)**2
               WC%UW0 = WC%UW0*(VT%RADIUS**2-RR)/VT%RADIUS**2
            ELSE
               PX = 4._EB*(M%XC(I)-VT%X1_ORIG)*(VT%X2_ORIG-M%XC(I))/(VT%X2_ORIG-VT%X1_ORIG)**2
               PZ = 4._EB*(M%ZC(K)-VT%Z1_ORIG)*(VT%Z2_ORIG-M%ZC(K))/(VT%Z2_ORIG-VT%Z1_ORIG)**2
               WC%UW0 = WC%UW0*PX*PZ
            ENDIF
         CASE(3)
            IF (VT%RADIUS>0._EB) THEN
               RR = (M%XC(I)-VT%X0)**2 + (M%YC(J)-VT%Y0)**2
               WC%UW0 = WC%UW0*(VT%RADIUS**2-RR)/VT%RADIUS**2
            ELSE
               PX = 4._EB*(M%XC(I)-VT%X1_ORIG)*(VT%X2_ORIG-M%XC(I))/(VT%X2_ORIG-VT%X1_ORIG)**2
               PY = 4._EB*(M%YC(J)-VT%Y1_ORIG)*(VT%Y2_ORIG-M%YC(J))/(VT%Y2_ORIG-VT%Y1_ORIG)**2
               IF (CYLINDRICAL) THEN
                  WC%UW0 = WC%UW0*PX
               ELSE
                  WC%UW0 = WC%UW0*PX*PY
               ENDIF
            ENDIF
      END SELECT
      IF (ABS(SF%VOLUME_FLOW)>=TWO_EPSILON_EB) THEN   ! Match desired volume flow
         IF (VT%RADIUS>0._EB) THEN
            WC%UW0 = WC%UW0*2._EB
         ELSE
            WC%UW0 = WC%UW0*9._EB/4._EB
         ENDIF
      ENDIF
   ENDIF PARABOLIC_IF

   IF (SF%PROFILE==BOUNDARY_LAYER_PROFILE) THEN

      ! Currently only set up for circular vents

      SELECT CASE(ABS(IOR))
         CASE(1)
            IF (VT%RADIUS>0._EB) THEN
               DELTA = VT%RADIUS - SQRT( VT%RADIUS**2*(2._EB*ABS(SF%VEL_BULK/SF%VEL)-1._EB) )
               R1 = VT%RADIUS - DELTA
               RR = SQRT( (M%YC(J)-VT%Y0)**2 + (M%ZC(K)-VT%Z0)**2 )
               IF (RR>R1 .AND. RR<=VT%RADIUS .AND. DELTA>TWO_EPSILON_EB) THEN
                  WC%UW0 = WC%UW0*(1._EB - ((RR-R1)/DELTA)**2 )
               ENDIF
            ENDIF
         CASE(2)
            IF (VT%RADIUS>0._EB) THEN
               DELTA = VT%RADIUS - SQRT( VT%RADIUS**2*(2._EB*ABS(SF%VEL_BULK/SF%VEL)-1._EB) )
               R1 = VT%RADIUS - DELTA
               RR = SQRT( (M%XC(I)-VT%X0)**2 + (M%ZC(K)-VT%Z0)**2 )
               IF (RR>R1 .AND. RR<=VT%RADIUS .AND. DELTA>TWO_EPSILON_EB) THEN
                  WC%UW0 = WC%UW0*(1._EB - ((RR-R1)/DELTA)**2 )
               ENDIF
            ENDIF
         CASE(3)
            IF (VT%RADIUS>0._EB) THEN
               DELTA = VT%RADIUS - SQRT( VT%RADIUS**2*(2._EB*ABS(SF%VEL_BULK/SF%VEL)-1._EB) )
               R1 = VT%RADIUS - DELTA
               RR = SQRT( (M%XC(I)-VT%X0)**2 + (M%YC(J)-VT%Y0)**2 )
               IF (RR>R1 .AND. RR<=VT%RADIUS .AND. DELTA>TWO_EPSILON_EB) THEN
                  WC%UW0 = WC%UW0*(1._EB - ((RR-R1)/DELTA)**2 )
               ENDIF
            ENDIF
      END SELECT
   ENDIF

   IF (SF%PROFILE==ATMOSPHERIC_PROFILE) THEN
      IF (M%ZC(K)<GROUND_LEVEL) THEN
         CALL SHUTDOWN('ERROR: SURF '//TRIM(SF%ID)//' cannot be applied below GROUND_LEVEL')
         IERR = 1
         RETURN
      ENDIF
      WC%UW0 =  WC%UW0*((M%ZC(K)-GROUND_LEVEL)/SF%Z0)**SF%PLE
   ENDIF

   IF (SF%PROFILE==RAMP_PROFILE) THEN
      SELECT CASE(ABS(IOR))
         CASE(1)
            IF (SF%RAMP_V_X/='null') THEN
               CALL SHUTDOWN('ERROR: RAMP_V_X assigned to SURF '//TRIM(SF%ID))
               IERR = 1
               RETURN
            ENDIF
            WC%UW0 = WC%UW0*EVALUATE_RAMP(M%YC(J),1._EB,SF%RAMP_INDEX(VELO_PROF_Y))
            WC%UW0 = WC%UW0*EVALUATE_RAMP(M%ZC(K),1._EB,SF%RAMP_INDEX(VELO_PROF_Z))
         CASE(2)
            IF (SF%RAMP_V_Y/='null') THEN
               CALL SHUTDOWN('ERROR: RAMP_V_Y assigned to SURF '//TRIM(SF%ID))
               IERR = 1
               RETURN
            ENDIF
            WC%UW0 = WC%UW0*EVALUATE_RAMP(M%XC(I),1._EB,SF%RAMP_INDEX(VELO_PROF_X))
            WC%UW0 = WC%UW0*EVALUATE_RAMP(M%ZC(K),1._EB,SF%RAMP_INDEX(VELO_PROF_Z))
         CASE(3)
            IF (SF%RAMP_V_Z/='null') THEN
               CALL SHUTDOWN('ERROR: RAMP_V_Z assigned to SURF '//TRIM(SF%ID))
               IERR = 1
               RETURN
            ENDIF
            WC%UW0 = WC%UW0*EVALUATE_RAMP(M%XC(I),1._EB,SF%RAMP_INDEX(VELO_PROF_X))
            WC%UW0 = WC%UW0*EVALUATE_RAMP(M%YC(J),1._EB,SF%RAMP_INDEX(VELO_PROF_Y))
      END SELECT
   ENDIF

   ! Check if fire spreads radially over this vent

   IF (VT%FIRE_SPREAD_RATE>0._EB) THEN
      DIST = SQRT((WC%XW-VT%X0)**2 + (WC%YW-VT%Y0)**2 + (WC%ZW-VT%Z0)**2)
      T_ACTIVATE = TT + DIST/VT%FIRE_SPREAD_RATE
   ENDIF

   ! Miscellaneous settings

   IF (.NOT.M%SOLID(ICG)) THEN
      IF (VT%BOUNDARY_TYPE==MIRROR_BOUNDARY) THEN
         WC%BOUNDARY_TYPE = MIRROR_BOUNDARY
         WC%SURF_INDEX    = MIRROR_SURF_INDEX
      ENDIF
      IF (VT%BOUNDARY_TYPE==OPEN_BOUNDARY) THEN
         WC%BOUNDARY_TYPE = OPEN_BOUNDARY
         WC%SURF_INDEX    = OPEN_SURF_INDEX
      ENDIF
   ENDIF

ENDIF PROCESS_VENT

! Check if fire spreads radially over this surface type

IF (SF%FIRE_SPREAD_RATE>0._EB) THEN
   DIST = SQRT((WC%XW-SF%XYZ(1))**2 +(WC%YW-SF%XYZ(2))**2 +(WC%ZW-SF%XYZ(3))**2)
   T_ACTIVATE = TT + DIST/SF%FIRE_SPREAD_RATE
ENDIF

! Set ignition time of each boundary cell

IF (T_ACTIVATE < T_BEGIN) THEN
   IF (SF%T_IGN==T_BEGIN) THEN
      WC%ONE_D%T_IGN = TT
   ELSE
      WC%ONE_D%T_IGN = SF%T_IGN
   ENDIF
ELSE
   WC%ONE_D%T_IGN = T_ACTIVATE
ENDIF

! Set correct initial value of temperature for RAMP_T

IF (ABS(WC%ONE_D%T_IGN-T_BEGIN) <= SPACING(WC%ONE_D%T_IGN) .AND. SF%RAMP_INDEX(TIME_TEMP)>=1) THEN
   TSI = TT
ELSE
   TSI = TT - WC%ONE_D%T_IGN
ENDIF

IF (SF%TMP_FRONT>0._EB) THEN
   WC%ONE_D%TMP_F = M%TMP_0(WC%ONE_D%KK) + &
                    EVALUATE_RAMP(TSI,SF%TAU(TIME_TEMP),SF%RAMP_INDEX(TIME_TEMP))*(SF%TMP_FRONT-M%TMP_0(WC%ONE_D%KK))
ELSE
   IF (SF%RAMP_T_I_INDEX < 0) WC%ONE_D%TMP_F = M%TMP_0(WC%ONE_D%KK)
ENDIF

! Allocate vegetation arrays

IF (SF%VEGETATION .AND. .NOT.EVACUATION_ONLY(NM)) THEN

   WC%VEG_FUELMASS_L(:)  = SF%VEG_LOAD / SF%NVEG_L
   WC%VEG_MOISTMASS_L(:) = SF%VEG_MOISTURE*WC%VEG_FUELMASS_L(:)
   WC%VEG_TMP_L(:)       = SF%VEG_INITIAL_TEMP + 273.15_EB
   WC%ONE_D%TMP_F        = SF%VEG_INITIAL_TEMP + 273.15_EB
   IF(SF%VEG_NO_BURN) WC%ONE_D%TMP_F = TMPA

ENDIF

! Record original boundary condition index for exterior wall cells that might get covered up

IF (OBST_INDEX==0) WC%SURF_INDEX_ORIG = SURF_INDEX_NEW

END SUBROUTINE INIT_WALL_CELL


SUBROUTINE OPEN_AND_CLOSE(T,NM)

! Check to see if a cell or OBSTruction is to be created or removed, or a VENT activated of deactivated

USE MEMORY_FUNCTIONS, ONLY : RE_ALLOCATE_STRINGS
USE CONTROL_VARIABLES, ONLY : CONTROL
USE DEVICE_VARIABLES, ONLY : DEVICE
USE COMP_FUNCTIONS, ONLY : SECOND
REAL(EB), INTENT(IN) :: T
REAL(EB) :: T_TMP,TNOW
INTEGER  :: N,II,JJ,KK,IW,IC,VENT_INDEX,CVENT_INDEX
INTEGER, INTENT(IN) :: NM
LOGICAL :: CREATE_OBST,REMOVE_OBST,ACTIVATE_VENT,DEACTIVATE_VENT
CHARACTER(12) :: SV_LABEL
TYPE (VENTS_TYPE), POINTER :: VT
TYPE (OBSTRUCTION_TYPE), POINTER :: OB

TNOW = SECOND()

CALL POINT_TO_MESH(NM)

T_TMP = T

! Check to see if an obstacle is to be removed or created

OBST_LOOP: DO N=1,N_OBST

   OB=>OBSTRUCTION(N)
   IF (.NOT. OB%REMOVABLE) CYCLE OBST_LOOP
   CREATE_OBST = .FALSE.
   REMOVE_OBST = .FALSE.

   ! Over-ride DEVICE/CONTROL logic

   CREATE_REMOVE_IF:IF (OB%CONSUMABLE .AND. OB%MASS <= 0._EB) THEN
      REMOVE_OBST = .TRUE.
   ELSE CREATE_REMOVE_IF
      SET_T_BEGIN_IF: IF (T<=T_BEGIN) THEN
         ! Set initial state of OBST
         HOLE_FILL_IF: IF (.NOT. OB%HOLE_FILLER) THEN
            !OBST is not a HOLE
            IF (OB%DEVC_INDEX > 0) THEN
               IF (DEVICE(OB%DEVC_INDEX)%CURRENT_STATE) THEN
                  CREATE_OBST = .TRUE.
               ELSE
                  REMOVE_OBST = .TRUE.
               ENDIF
            ELSEIF (OB%CTRL_INDEX > 0) THEN
               IF (CONTROL(OB%CTRL_INDEX)%CURRENT_STATE) THEN
                  CREATE_OBST = .TRUE.
               ELSE
                  REMOVE_OBST = .TRUE.
               ENDIF
            ENDIF
         ELSE HOLE_FILL_IF
            !OBST is a HOLE.  CREATE/REMOVE also depends on parent OBST.
            CHECK_PARENT: IF (OB%DEVC_INDEX_O > 0 .OR. OB%CTRL_INDEX_O > 0) THEN
               !Parent OBST controllable, check state and if parent OBST is hidden, do not fill hole.
               IF (OB%DEVC_INDEX_O > 0) THEN
                  IF (.NOT. DEVICE(OB%DEVC_INDEX_O)%CURRENT_STATE) REMOVE_OBST = .TRUE.
               ELSEIF(OB%CTRL_INDEX_O > 0) THEN
                  IF (.NOT. CONTROL(OB%CTRL_INDEX_O)%CURRENT_STATE) REMOVE_OBST = .TRUE.
               ENDIF
               !If parent OBST is visible, check to see if hole needs to be made.
               IF (.NOT. REMOVE_OBST) THEN
                  IF (OB%DEVC_INDEX > 0) THEN
                     IF (DEVICE(OB%DEVC_INDEX)%CURRENT_STATE) THEN
                        REMOVE_OBST = .TRUE.
                     ELSE
                        CREATE_OBST = .TRUE.
                     ENDIF
                  ELSEIF (OB%CTRL_INDEX > 0) THEN
                     IF (CONTROL(OB%CTRL_INDEX)%CURRENT_STATE) THEN
                        REMOVE_OBST = .TRUE.
                     ELSE
                        CREATE_OBST = .TRUE.
                     ENDIF
                  ENDIF
               ENDIF
            ELSE CHECK_PARENT
               !Parent OBST always present
               IF (OB%DEVC_INDEX > 0) THEN
                  IF (DEVICE(OB%DEVC_INDEX)%CURRENT_STATE) THEN
                     REMOVE_OBST = .TRUE.
                  ELSE
                     CREATE_OBST = .TRUE.
                  ENDIF
               ELSEIF (OB%CTRL_INDEX > 0) THEN
                  IF (CONTROL(OB%CTRL_INDEX)%CURRENT_STATE) THEN
                     REMOVE_OBST = .TRUE.
                  ELSE
                     CREATE_OBST = .TRUE.
                  ENDIF
               ENDIF
            ENDIF CHECK_PARENT

         ENDIF HOLE_FILL_IF
      ELSE SET_T_BEGIN_IF
      ! Decide if a DEVICE/CONTROL action is needed
         HOLE_FILL_IF_2: IF (.NOT. OB%HOLE_FILLER) THEN
            !OBST is not a HOLE
            IF (OB%DEVC_INDEX > 0) THEN
               IF (DEVICE(OB%DEVC_INDEX)%CURRENT_STATE .EQV. DEVICE(OB%DEVC_INDEX)%PRIOR_STATE) CYCLE OBST_LOOP
               IF (DEVICE(OB%DEVC_INDEX)%CURRENT_STATE) THEN
                  CREATE_OBST = .TRUE.
               ELSE
                  REMOVE_OBST = .TRUE.
               ENDIF
            ELSEIF (OB%CTRL_INDEX > 0) THEN
               IF (CONTROL(OB%CTRL_INDEX)%CURRENT_STATE .EQV. CONTROL(OB%CTRL_INDEX)%PRIOR_STATE) CYCLE OBST_LOOP
               IF (CONTROL(OB%CTRL_INDEX)%CURRENT_STATE) THEN
                  CREATE_OBST = .TRUE.
               ELSE
                  REMOVE_OBST = .TRUE.
               ENDIF
            ENDIF
         ELSE HOLE_FILL_IF_2
            !OBST is a HOLE.  CREATE/REMOVE also depends on parent OBST.
            CHECK_PARENT_2: IF (OB%DEVC_INDEX_O > 0 .OR. OB%CTRL_INDEX_O > 0) THEN
               !Parent OBST controllable, check state and if parent OBST is hidden, do not fill hole.
               IF (OB%DEVC_INDEX_O > 0) THEN
                  IF (.NOT. DEVICE(OB%DEVC_INDEX_O)%CURRENT_STATE) REMOVE_OBST = .TRUE.
               ELSEIF(OB%CTRL_INDEX_O > 0) THEN
                  IF (.NOT. CONTROL(OB%CTRL_INDEX_O)%CURRENT_STATE) REMOVE_OBST = .TRUE.
               ENDIF
               !If parent OBST is visible, check to see if hole needs to be made.
               IF (.NOT. REMOVE_OBST) THEN
                  IF (OB%DEVC_INDEX > 0) THEN
                     IF (DEVICE(OB%DEVC_INDEX)%CURRENT_STATE .EQV. DEVICE(OB%DEVC_INDEX)%PRIOR_STATE) THEN
                        IF (OB%DEVC_INDEX_O > 0 .AND. .NOT. DEVICE(OB%DEVC_INDEX)%CURRENT_STATE) THEN
                           IF (DEVICE(OB%DEVC_INDEX_O)%CURRENT_STATE .NEQV. DEVICE(OB%DEVC_INDEX_O)%PRIOR_STATE) &
                               CREATE_OBST=.TRUE.
                        ELSEIF(OB%CTRL_INDEX_O > 0 .AND. .NOT. DEVICE(OB%DEVC_INDEX)%CURRENT_STATE) THEN
                           IF (CONTROL(OB%CTRL_INDEX_O)%CURRENT_STATE .NEQV. CONTROL(OB%CTRL_INDEX_O)%PRIOR_STATE) &
                               CREATE_OBST=.TRUE.
                        ENDIF
                     ELSE
                        IF (DEVICE(OB%DEVC_INDEX)%CURRENT_STATE) THEN
                           REMOVE_OBST = .TRUE.
                        ELSE
                           CREATE_OBST = .TRUE.
                        ENDIF
                     ENDIF
                  ELSEIF (OB%CTRL_INDEX > 0) THEN
                     IF (CONTROL(OB%CTRL_INDEX)%CURRENT_STATE .EQV. CONTROL(OB%CTRL_INDEX)%PRIOR_STATE) THEN
                        IF (OB%DEVC_INDEX_O > 0 .AND. .NOT. CONTROL(OB%CTRL_INDEX)%CURRENT_STATE) THEN
                           IF (DEVICE(OB%DEVC_INDEX_O)%CURRENT_STATE .NEQV. DEVICE(OB%DEVC_INDEX_O)%PRIOR_STATE) &
                               CREATE_OBST=.TRUE.
                        ELSEIF(OB%CTRL_INDEX_O > 0 .AND. .NOT. CONTROL(OB%CTRL_INDEX)%CURRENT_STATE) THEN
                           IF (CONTROL(OB%CTRL_INDEX_O)%CURRENT_STATE .NEQV. CONTROL(OB%CTRL_INDEX_O)%PRIOR_STATE) &
                               CREATE_OBST=.TRUE.
                        ENDIF
                     ELSE
                        IF (CONTROL(OB%CTRL_INDEX)%CURRENT_STATE) THEN
                           REMOVE_OBST = .TRUE.
                        ELSE
                           CREATE_OBST = .TRUE.
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ELSE CHECK_PARENT_2
               !Parent OBST not controllable and is always present
               IF (OB%DEVC_INDEX > 0) THEN
                  IF (DEVICE(OB%DEVC_INDEX)%CURRENT_STATE .EQV. DEVICE(OB%DEVC_INDEX)%PRIOR_STATE) CYCLE OBST_LOOP
                  IF (DEVICE(OB%DEVC_INDEX)%CURRENT_STATE) THEN
                     REMOVE_OBST = .TRUE.
                  ELSE
                     CREATE_OBST = .TRUE.
                  ENDIF
               ELSEIF (OB%CTRL_INDEX > 0) THEN
                  IF (CONTROL(OB%CTRL_INDEX)%CURRENT_STATE .EQV. CONTROL(OB%CTRL_INDEX)%PRIOR_STATE) CYCLE OBST_LOOP
                  IF (CONTROL(OB%CTRL_INDEX)%CURRENT_STATE) THEN
                     REMOVE_OBST = .TRUE.
                  ELSE
                     CREATE_OBST = .TRUE.
                  ENDIF
               ENDIF
            ENDIF CHECK_PARENT_2

         ENDIF HOLE_FILL_IF_2

      ENDIF SET_T_BEGIN_IF
   ENDIF CREATE_REMOVE_IF

   SV_LABEL  = 'null'

   IF (CREATE_OBST .AND. OB%HIDDEN) THEN
      OB%HIDDEN = .FALSE.
      SV_LABEL  = 'SHOW_OBST'
      CALL CREATE_OR_REMOVE_OBST(NM,OB%I1,OB%I2,OB%J1,OB%J2,OB%K1,OB%K2,1,N,T)
   ENDIF

   IF (REMOVE_OBST .AND. (.NOT. OB%HIDDEN)) THEN
      OB%HIDDEN = .TRUE.
      SV_LABEL  = 'HIDE_OBST'
      CALL CREATE_OR_REMOVE_OBST(NM,OB%I1,OB%I2,OB%J1,OB%J2,OB%K1,OB%K2,0,N,T)
   ENDIF

   ! The evacuation flow field calculation is done before T_BEGIN

   IF (OB%DEVC_INDEX>0) THEN
      IF (EVACUATION_SKIP(NM) .AND. DEVICE(OB%DEVC_INDEX)%QUANTITY=='TIME' .AND. DEVICE(OB%DEVC_INDEX)%SETPOINT<=T_BEGIN) &
         T_TMP = T - EVAC_DT_FLOWFIELD*EVAC_TIME_ITERATIONS
   ENDIF

   ! Write a message to the Smokeview .smv file that the obstruction has been created or removed

   IF (SV_LABEL /= 'null') THEN
      IF (N_STRINGS+2>N_STRINGS_MAX) THEN
         CALL RE_ALLOCATE_STRINGS(NM)
         STRING => MESHES(NM)%STRING
      ENDIF
      N_STRINGS = N_STRINGS + 1
      WRITE(STRING(N_STRINGS),'(A,I3)') SV_LABEL,NM
      N_STRINGS = N_STRINGS + 1
      WRITE(STRING(N_STRINGS),'(I6,F10.2)') N,T_BEGIN+(T_TMP-T_BEGIN)*TIME_SHRINK_FACTOR
   ENDIF

ENDDO OBST_LOOP

! Check to see if a vent should be activated or deactivated

VENT_INDEX  = 0
CVENT_INDEX = 0

VENT_LOOP: DO N=1,N_VENT
   VT => VENTS(N)

   IF (VT%RADIUS>0._EB) THEN
      CVENT_INDEX = CVENT_INDEX + 1
   ELSE
      VENT_INDEX = VENT_INDEX + 1
   ENDIF

   ACTIVATE_VENT   = .FALSE.
   DEACTIVATE_VENT = .FALSE.

   ! Over-ride DEVICE/CONTROL logic

   IF (.NOT.VT%ACTIVATED .AND. T<=T_BEGIN) DEACTIVATE_VENT = .TRUE.

   ! Decide if a VENT is to activate or de-activate based on a DEVICE or CONTROLLER

   IF (.NOT.ACTIVATE_VENT .AND. .NOT.DEACTIVATE_VENT) THEN
      IF (VT%DEVC_INDEX > 0) THEN
         IF (DEVICE(VT%DEVC_INDEX)%CURRENT_STATE .EQV. DEVICE(VT%DEVC_INDEX)%PRIOR_STATE) CYCLE VENT_LOOP
         IF (DEVICE(VT%DEVC_INDEX)%CURRENT_STATE) THEN
            ACTIVATE_VENT   = .TRUE.
         ELSE
            DEACTIVATE_VENT = .TRUE.
         ENDIF
      ELSEIF (VT%CTRL_INDEX > 0) THEN
         IF (CONTROL(VT%CTRL_INDEX)%CURRENT_STATE .EQV. CONTROL(VT%CTRL_INDEX)%PRIOR_STATE) CYCLE VENT_LOOP
         IF (CONTROL(VT%CTRL_INDEX)%CURRENT_STATE) THEN
            ACTIVATE_VENT   = .TRUE.
         ELSE
            DEACTIVATE_VENT = .TRUE.
         ENDIF
      ENDIF
   ENDIF

   IF (.NOT.ACTIVATE_VENT .AND. .NOT.DEACTIVATE_VENT) CYCLE VENT_LOOP

   ! Find the wall indices (IW) for the vent and set the activation time (ONE_D%T_IGN) for each one

   DO KK=VT%K1+1,MAX(VT%K1+1,VT%K2)
      DO JJ=VT%J1+1,MAX(VT%J1+1,VT%J2)
         DO II=VT%I1+1,MAX(VT%I1+1,VT%I2)
            SELECT CASE(VT%IOR)
               CASE(1:)
                  IC = CELL_INDEX(II,JJ,KK)
               CASE(-1)
                  IC = CELL_INDEX(II-1,JJ,KK)
               CASE(-2)
                  IC = CELL_INDEX(II,JJ-1,KK)
               CASE(-3)
                  IC = CELL_INDEX(II,JJ,KK-1)
            END SELECT
            IW = WALL_INDEX(IC,-VT%IOR)
            IF (IW==0) CYCLE

            IF (ACTIVATE_VENT) THEN
               IF (VT%FIRE_SPREAD_RATE>0._EB) THEN
                  WALL(IW)%ONE_D%T_IGN = T + SQRT((WALL(IW)%XW-VT%X0)**2 +(WALL(IW)%YW-VT%Y0)**2 +&
                                              (WALL(IW)%ZW-VT%Z0)**2)/VT%FIRE_SPREAD_RATE
               ELSE
                  WALL(IW)%ONE_D%T_IGN = T
               ENDIF
            ELSE
               WALL(IW)%ONE_D%T_IGN = 1.E6_EB
            ENDIF
         ENDDO
      ENDDO
   ENDDO

   ! Write message to .smv file

   IF (VT%RADIUS<0._EB) THEN
      IF (ACTIVATE_VENT)   SV_LABEL = 'OPEN_VENT'
      IF (DEACTIVATE_VENT) SV_LABEL = 'CLOSE_VENT'
   ELSE
      IF (ACTIVATE_VENT)   SV_LABEL = 'OPEN_CVENT'
      IF (DEACTIVATE_VENT) SV_LABEL = 'CLOSE_CVENT'
   ENDIF

   IF (N_STRINGS+2>N_STRINGS_MAX) THEN
      CALL RE_ALLOCATE_STRINGS(NM)
      STRING => MESHES(NM)%STRING
   ENDIF
   N_STRINGS = N_STRINGS + 1
   WRITE(STRING(N_STRINGS),'(A,I3)') SV_LABEL,NM
   N_STRINGS = N_STRINGS + 1
   IF (VT%RADIUS>0._EB) WRITE(STRING(N_STRINGS),'(I6,F10.2)') CVENT_INDEX,T
   IF (VT%RADIUS<0._EB) WRITE(STRING(N_STRINGS),'(I6,F10.2)')  VENT_INDEX,T

ENDDO VENT_LOOP

T_USED(6) = T_USED(6) + SECOND() - TNOW
END SUBROUTINE OPEN_AND_CLOSE


SUBROUTINE CREATE_OR_REMOVE_OBST(NM,I1,I2,J1,J2,K1,K2,CR_INDEX,OBST_INDEX,T)

! Create or remove the obstruction whose NODES (not cells) are given by I1, I2, etc.

USE GEOMETRY_FUNCTIONS, ONLY : BLOCK_CELL
INTEGER :: I1,I2,J1,J2,K1,K2,I,J,K,IW,ICG,IC
INTEGER, INTENT(IN) :: NM,CR_INDEX,OBST_INDEX
REAL(EB) :: T
LOGICAL :: CREATE,REMOVE,THIN_OBSTRUCTION

CALL POINT_TO_MESH(NM)

! Indicate whether to create or remove the obstruction.

REMOVE = .FALSE.
CREATE = .FALSE.
IF (CR_INDEX==0) REMOVE = .TRUE.
IF (CR_INDEX==1) CREATE = .TRUE.

! Indicate if the obstruction is thin, i.e. zero cells thick. This matters in a few instances below.

THIN_OBSTRUCTION = .FALSE.
IF (I1==I2 .OR. J1==J2 .OR. K1==K2) THIN_OBSTRUCTION = .TRUE.

! Blank or unblank cells that make up the OBSTruction

IF (.NOT.THIN_OBSTRUCTION) CALL BLOCK_CELL(NM,I1+1,I2,J1+1,J2,K1+1,K2,CR_INDEX,OBST_INDEX)

! If the OBSTruction is to be removed, set density and mass fractions to ambient value

IF (REMOVE) THEN
   DO K=K1+1,K2
      DO J=J1+1,J2
         DO I=I1+1,I2
            RHOS(I,J,K) = RHOA
            RHO(I,J,K)  = RHOA
            ZZ(I,J,K,1:N_TRACKED_SPECIES)  = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
            ZZS(I,J,K,1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
         ENDDO
      ENDDO
   ENDDO
ENDIF

! Process the x boundaries of the OBSTruction

DO K=K1+1,K2
   DO J=J1+1,J2
      IC  = CELL_INDEX(I1+1,J,K)
      ICG = CELL_INDEX(I1  ,J,K)
      IW  = WALL_INDEX(ICG,1)
      IF (I1>0)    CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I1  ,J,K)
      ICG = CELL_INDEX(I1+1,J,K)
      IW  = WALL_INDEX(ICG,-1)
      IF (I1<IBAR) CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I2  ,J,K)
      ICG = CELL_INDEX(I2+1,J,K)
      IW  = WALL_INDEX(ICG,-1)
      IF (I2<IBAR) CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I2+1,J,K)
      ICG = CELL_INDEX(I2  ,J,K)
      IW  = WALL_INDEX(ICG, 1)
      IF (I2>0)    CALL GET_BOUNDARY_TYPE
   ENDDO
ENDDO

! Process the y boundaries of the OBSTruction

DO K=K1+1,K2
   DO I=I1+1,I2
      IC  = CELL_INDEX(I,J1+1,K)
      ICG = CELL_INDEX(I,J1  ,K)
      IW  = WALL_INDEX(ICG, 2)
      IF (J1>0)    CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I,J1  ,K)
      ICG = CELL_INDEX(I,J1+1,K)
      IW  = WALL_INDEX(ICG,-2)
      IF (J1<JBAR) CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I,J2  ,K)
      ICG = CELL_INDEX(I,J2+1,K)
      IW  = WALL_INDEX(ICG,-2)
      IF (J2<JBAR) CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I,J2+1,K)
      ICG = CELL_INDEX(I,J2  ,K)
      IW  = WALL_INDEX(ICG, 2)
      IF (J2>0)    CALL GET_BOUNDARY_TYPE
   ENDDO
ENDDO

! Process the z boundaries of the OBSTruction

DO J=J1+1,J2
   DO I=I1+1,I2
      IC  = CELL_INDEX(I,J,K1+1)
      ICG = CELL_INDEX(I,J,K1  )
      IW  = WALL_INDEX(ICG, 3)
      IF (K1>0)    CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I,J,K1  )
      ICG = CELL_INDEX(I,J,K1+1)
      IW  = WALL_INDEX(ICG,-3)
      IF (K1<KBAR) CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I,J,K2  )
      ICG = CELL_INDEX(I,J,K2+1)
      IW  = WALL_INDEX(ICG,-3)
      IF (K2<KBAR) CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I,J,K2+1)
      ICG = CELL_INDEX(I,J,K2  )
      IW  = WALL_INDEX(ICG, 3)
      IF (K2>0)    CALL GET_BOUNDARY_TYPE
   ENDDO
ENDDO

! Nullify block edges on blockage that is to be removed

DO K=K1,K2
   DO J=J1,J2
      IF (J>J1) CALL REDEFINE_EDGE(I1,J,K,2)
      IF (J>J1) CALL REDEFINE_EDGE(I2,J,K,2)
      IF (K>K1) CALL REDEFINE_EDGE(I1,J,K,3)
      IF (K>K1) CALL REDEFINE_EDGE(I2,J,K,3)
   ENDDO
ENDDO

DO K=K1,K2
   DO I=I1,I2
      IF (I>I1) CALL REDEFINE_EDGE(I,J1,K,1)
      IF (I>I1) CALL REDEFINE_EDGE(I,J2,K,1)
      IF (K>K1) CALL REDEFINE_EDGE(I,J1,K,3)
      IF (K>K1) CALL REDEFINE_EDGE(I,J2,K,3)
   ENDDO
ENDDO

DO J=J1,J2
   DO I=I1,I2
      IF (I>I1) CALL REDEFINE_EDGE(I,J,K1,1)
      IF (I>I1) CALL REDEFINE_EDGE(I,J,K2,1)
      IF (J>J1) CALL REDEFINE_EDGE(I,J,K1,2)
      IF (J>J1) CALL REDEFINE_EDGE(I,J,K2,2)
   ENDDO
ENDDO

CONTAINS

SUBROUTINE GET_BOUNDARY_TYPE

INTEGER :: IOR,IIG,JJG,KKG,IW_OLD,IERR,PRESSURE_BC_INDEX
TYPE(WALL_TYPE), POINTER :: WC

IF (IW==0) RETURN

WC => WALL(IW)

IF (IW<=N_EXTERNAL_WALL_CELLS .AND. REMOVE) THEN
   WC%BOUNDARY_TYPE = SOLID_BOUNDARY
   SOLID(IC)        = .TRUE.
   IF (WC%SURF_INDEX_ORIG==MIRROR_SURF_INDEX) THEN
      WC%BOUNDARY_TYPE = MIRROR_BOUNDARY
      WC%SURF_INDEX    = MIRROR_SURF_INDEX
      SOLID(IC)        = .TRUE.
      RETURN
   ENDIF
   IF (WC%SURF_INDEX_ORIG==OPEN_SURF_INDEX) THEN
      WC%BOUNDARY_TYPE = OPEN_BOUNDARY
      WC%SURF_INDEX    = OPEN_SURF_INDEX
      SOLID(IC)        = .FALSE.
      RETURN
   ENDIF
   IF (WC%SURF_INDEX_ORIG==INTERPOLATED_SURF_INDEX) THEN
      WC%BOUNDARY_TYPE = INTERPOLATED_BOUNDARY
      WC%SURF_INDEX    = INTERPOLATED_SURF_INDEX
      SOLID(IC)        = .FALSE.
      RETURN
   ENDIF
ENDIF

IF (IW>N_EXTERNAL_WALL_CELLS) THEN
   IF (WC%OBST_INDEX>0 .AND.      OBSTRUCTION(WC%OBST_INDEX)%HIDDEN .AND. .NOT.SOLID(IC) ) WC%BOUNDARY_TYPE = NULL_BOUNDARY
   IF (WC%OBST_INDEX>0 .AND. .NOT.OBSTRUCTION(WC%OBST_INDEX)%HIDDEN .AND. .NOT.SOLID(ICG)) WC%BOUNDARY_TYPE = SOLID_BOUNDARY
   IF (SOLID(ICG)) WC%BOUNDARY_TYPE = NULL_BOUNDARY
ENDIF

IF (CREATE) THEN
   IF (SOLID(ICG)) THEN
      WC%BOUNDARY_TYPE = NULL_BOUNDARY
   ELSE
      WC%BOUNDARY_TYPE = SOLID_BOUNDARY
      IF (WC%ONE_D%T_IGN<T) WC%ONE_D%T_IGN = T
   ENDIF
ENDIF

! Initialize solid properties included in the WALL derived type variable

IF (WC%BOUNDARY_TYPE/=NULL_BOUNDARY) THEN
   IF (IW<=N_EXTERNAL_WALL_CELLS .AND. THIN_OBSTRUCTION) WC%OBST_INDEX = 0  ! If a flat plate is removed from external wall.
   IF (OBST_INDEX_C(IC)>0) THEN
      WC%OBST_INDEX = OBST_INDEX_C(IC)
   ELSEIF (CREATE .AND. OBST_INDEX>0) THEN
      WC%OBST_INDEX = OBST_INDEX
   ENDIF
   IF (WC%OBST_INDEX>0) WC%SURF_INDEX = OBSTRUCTION(WC%OBST_INDEX)%SURF_INDEX(WC%ONE_D%IOR)
   PRESSURE_BC_INDEX = WC%PRESSURE_BC_INDEX  ! Save this parameter and restore it after the call to INIT_WALL_CELL
   CALL INIT_WALL_CELL(NM,WC%ONE_D%II,WC%ONE_D%JJ,WC%ONE_D%KK,WC%OBST_INDEX,IW,WC%ONE_D%IOR,WC%SURF_INDEX,IERR,T)
   WC => WALL(IW)
   WC%PRESSURE_BC_INDEX = PRESSURE_BC_INDEX
ENDIF

! Special case: A BURNed_AWAY obstruction exposes a surface that also burns, in which case the surface is to ignite immediately.

IF (REMOVE .AND. SURFACE(WC%SURF_INDEX)%PYROLYSIS_MODEL==PYROLYSIS_SPECIFIED) THEN
   IIG = WC%ONE_D%IIG
   JJG = WC%ONE_D%JJG
   KKG = WC%ONE_D%KKG
   IOR = WC%ONE_D%IOR
   IW_OLD = 0
   IC     = 0
   SELECT CASE(IOR)
      CASE(-1)
         IF (IIG>1)    IC = CELL_INDEX(IIG-1,JJG,KKG)
      CASE( 1)
         IF (IIG<IBAR) IC = CELL_INDEX(IIG+1,JJG,KKG)
      CASE(-2)
         IF (JJG>1)    IC = CELL_INDEX(IIG,JJG-1,KKG)
      CASE( 2)
         IF (JJG<JBAR) IC = CELL_INDEX(IIG,JJG+1,KKG)
      CASE(-3)
         IF (KKG>1)    IC = CELL_INDEX(IIG,JJG,KKG-1)
      CASE( 3)
         IF (KKG<KBAR) IC = CELL_INDEX(IIG,JJG,KKG+1)
   END SELECT
   IW_OLD = WALL_INDEX(IC,-IOR)
   IF (IW_OLD>0) THEN
      IF (WALL(IW_OLD)%SURF_INDEX==WC%SURF_INDEX) WC%ONE_D%T_IGN =  WALL(IW_OLD)%ONE_D%T_IGN
   ENDIF
ENDIF

END SUBROUTINE GET_BOUNDARY_TYPE


SUBROUTINE REDEFINE_EDGE(II,JJ,KK,IEC)

! Change a few properties of the EDGEs that have been exposed or covered up by a blockage

INTEGER :: IE,II,JJ,KK,IEC

SELECT CASE(IEC)
   CASE(1)
      IE = EDGE_INDEX( 4,CELL_INDEX(II,JJ,KK))
   CASE(2)
      IE = EDGE_INDEX( 8,CELL_INDEX(II,JJ,KK))
   CASE(3)
      IE = EDGE_INDEX(12,CELL_INDEX(II,JJ,KK))
END SELECT

END SUBROUTINE REDEFINE_EDGE


END SUBROUTINE CREATE_OR_REMOVE_OBST


SUBROUTINE DEFINE_EDGE(II,JJ,KK,IOR,IEC,NM,OBST_INDEX,IERR)

! Set up edge arrays for velocity boundary conditions

INTEGER, INTENT(IN) :: II,JJ,KK,IOR,IEC,NM
INTEGER :: NOM,ICMM,ICMP,ICPM,ICPP,OBST_INDEX,IE,IW,IIO,JJO,KKO,IW1,IW2,IERR
REAL(EB) :: XI,YJ,ZK
TYPE (MESH_TYPE), POINTER :: M,MM
TYPE (OBSTRUCTION_TYPE), POINTER :: OB

M => MESHES(NM)
IF (OBST_INDEX>0) OB=>OBSTRUCTION(OBST_INDEX)

! Find the wall cells on each side of the edge

IW1 = -1
IW2 = -1

EDGE_DIRECTION_1: SELECT CASE(IEC)
   CASE(1) EDGE_DIRECTION_1
      SELECT CASE(IOR)
         CASE(-2)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ,KK)  ,2)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ,KK+1),2)
         CASE( 2)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ+1,KK)  ,-2)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ+1,KK+1),-2)
         CASE(-3)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ  ,KK),3)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ+1,KK),3)
         CASE( 3)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ  ,KK+1),-3)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ+1,KK+1),-3)
      END SELECT
   CASE(2) EDGE_DIRECTION_1
      SELECT CASE(IOR)
         CASE(-1)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ,KK)  ,1)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ,KK+1),1)
         CASE( 1)
            IW1 = WALL_INDEX(CELL_INDEX(II+1,JJ,KK)  ,-1)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ,KK+1),-1)
         CASE(-3)
            IW1 = WALL_INDEX(CELL_INDEX(II  ,JJ,KK),3)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ,KK),3)
         CASE( 3)
            IW1 = WALL_INDEX(CELL_INDEX(II  ,JJ,KK+1),-3)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ,KK+1),-3)
      END SELECT
   CASE(3) EDGE_DIRECTION_1
      SELECT CASE(IOR)
         CASE(-1)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ  ,KK),1)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ+1,KK),1)
         CASE( 1)
            IW1 = WALL_INDEX(CELL_INDEX(II+1,JJ  ,KK),-1)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ+1,KK),-1)
         CASE(-2)
            IW1 = WALL_INDEX(CELL_INDEX(II  ,JJ,KK),2)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ,KK),2)
         CASE( 2)
            IW1 = WALL_INDEX(CELL_INDEX(II  ,JJ+1,KK),-2)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ+1,KK),-2)
      END SELECT
END SELECT EDGE_DIRECTION_1

! Decide what to do based on whether or not adjacent tiles exist

IF (IW1==-1 .OR. IW2==-1) THEN
   WRITE(LU_ERR,'(A,I2,A,3I3)') 'ERROR: Edge initialization failed; Mesh: ',NM,', Cell: ',II,JJ,KK
   STOP_STATUS = SETUP_STOP
   IERR = 1
   RETURN
ENDIF

IF (IW1==0 .AND. IW2==0) RETURN
IF (IW1> 0 .AND. IW2==0) IW = IW1
IF (IW1==0 .AND. IW2> 0) IW = IW2
IF (IW1> 0 .AND. IW2> 0) THEN
   IW = IW2
   IF (IW1<=N_EXTERNAL_WALL_CELLS) THEN
      IF (EXTERNAL_WALL(IW1)%NOM>0) IW = IW1
   ENDIF
   IF (IW2<=N_EXTERNAL_WALL_CELLS) THEN
      IF (EXTERNAL_WALL(IW2)%NOM>0) IW = IW2
   ENDIF
ENDIF

! Assign the Index of the Edge (IE) and add to the list

ICMM = CELL_INDEX(II,JJ,KK)
SELECT CASE(IEC)
   CASE(1)
      IE = EDGE_INDEX( 4,ICMM)
   CASE(2)
      IE = EDGE_INDEX( 8,ICMM)
   CASE(3)
      IE = EDGE_INDEX(12,ICMM)
END SELECT

IF (IE==0) THEN
   N_EDGES = N_EDGES + 1
   IE = N_EDGES
ENDIF

! Determine the wall index of the adjacent wall tile

NOM = 0
IIO = 0
JJO = 0
KKO = 0

IF (IW<=N_EXTERNAL_WALL_CELLS) THEN
   IF (EXTERNAL_WALL(IW)%NOM>0) THEN
      NOM = EXTERNAL_WALL(IW)%NOM
      IIO = EXTERNAL_WALL(IW)%IIO_MIN
      JJO = EXTERNAL_WALL(IW)%JJO_MIN
      KKO = EXTERNAL_WALL(IW)%KKO_MIN
   ENDIF
ENDIF

! Fill up array IJKE with edge parameters

IJKE(1,IE) = II
IJKE(2,IE) = JJ
IJKE(3,IE) = KK
IJKE(4,IE) = IEC

! Fill in EDGE_INDEX and the rest of IJKE

EDGE_DIRECTION_2: SELECT CASE(IEC)

   CASE (1) EDGE_DIRECTION_2

      ICPM = CELL_INDEX(II,JJ+1,KK)
      ICPP = CELL_INDEX(II,JJ+1,KK+1)
      ICMP = CELL_INDEX(II,JJ,KK+1)
      IJKE(5,IE) = ICMM
      IJKE(6,IE) = ICPM
      IJKE(7,IE) = ICMP
      IJKE(8,IE) = ICPP
      EDGE_INDEX(1,ICPP) = IE
      EDGE_INDEX(2,ICMP) = IE
      EDGE_INDEX(3,ICPM) = IE
      EDGE_INDEX(4,ICMM) = IE
      IF (NOM/=0) THEN
         SELECT CASE(ABS(IOR))
            CASE(2)
               IF (IOR>0) IJKE( 9,IE) = -NOM
               IF (IOR<0) IJKE( 9,IE) =  NOM
               IJKE(10,IE) = IIO
               IJKE(11,IE) = JJO
               MM => MESHES(NOM)
               ZK  = MIN( REAL(MM%KBAR,EB)+ALMOST_ONE , MM%CELLSK(NINT((Z(KK)-MM%ZS)*MM%RDZINT))+1._EB )
               KKO = MAX(1,FLOOR(ZK))
               M%EDGE_INTERPOLATION_FACTOR(IE,1) = ZK-KKO
               IJKE(12,IE) = KKO
            CASE(3)
               IF (IOR>0) IJKE(13,IE) = -NOM
               IF (IOR<0) IJKE(13,IE) =  NOM
               IJKE(14,IE) = IIO
               MM => MESHES(NOM)
               YJ  = MIN( REAL(MM%JBAR,EB)+ALMOST_ONE , MM%CELLSJ(NINT((Y(JJ)-MM%YS)*MM%RDYINT))+1._EB )
               JJO = MAX(1,FLOOR(YJ))
               M%EDGE_INTERPOLATION_FACTOR(IE,2) = YJ-JJO
               IJKE(15,IE) = JJO
               IJKE(16,IE) = KKO
         END SELECT
      ENDIF

   CASE (2) EDGE_DIRECTION_2

      ICMP = CELL_INDEX(II+1,JJ,KK)
      ICPP = CELL_INDEX(II+1,JJ,KK+1)
      ICPM = CELL_INDEX(II,JJ,KK+1)
      IJKE(5,IE) = ICMM
      IJKE(6,IE) = ICPM
      IJKE(7,IE) = ICMP
      IJKE(8,IE) = ICPP
      EDGE_INDEX(5,ICPP) = IE
      EDGE_INDEX(6,ICPM) = IE
      EDGE_INDEX(7,ICMP) = IE
      EDGE_INDEX(8,ICMM) = IE
      IF (NOM/=0) THEN
         SELECT CASE(ABS(IOR))
            CASE( 1)
               IF (IOR>0) IJKE(13,IE) = -NOM
               IF (IOR<0) IJKE(13,IE) =  NOM
               IJKE(14,IE) = IIO
               IJKE(15,IE) = JJO
               MM => MESHES(NOM)
               ZK  = MIN( REAL(MM%KBAR,EB)+ALMOST_ONE , MM%CELLSK(NINT((Z(KK)-MM%ZS)*MM%RDZINT))+1._EB )
               KKO = MAX(1,FLOOR(ZK))
               M%EDGE_INTERPOLATION_FACTOR(IE,2) = ZK-KKO
               IJKE(16,IE) = KKO
            CASE( 3)
               IF (IOR>0) IJKE( 9,IE) = -NOM
               IF (IOR<0) IJKE( 9,IE) =  NOM
               MM => MESHES(NOM)
               XI  = MIN( REAL(MM%IBAR,EB)+ALMOST_ONE , MM%CELLSI(NINT((X(II)-MM%XS)*MM%RDXINT))+1._EB )
               IIO = MAX(1,FLOOR(XI))
               M%EDGE_INTERPOLATION_FACTOR(IE,1) = XI-IIO
               IJKE(10,IE) = IIO
               IJKE(11,IE) = JJO
               IJKE(12,IE) = KKO
         END SELECT
      ENDIF

   CASE (3) EDGE_DIRECTION_2

      ICPM = CELL_INDEX(II+1,JJ,KK)
      ICPP = CELL_INDEX(II+1,JJ+1,KK)
      ICMP = CELL_INDEX(II,JJ+1,KK)
      IJKE(5,IE) = ICMM
      IJKE(6,IE) = ICPM
      IJKE(7,IE) = ICMP
      IJKE(8,IE) = ICPP
      EDGE_INDEX( 9,ICPP) = IE
      EDGE_INDEX(10,ICMP) = IE
      EDGE_INDEX(11,ICPM) = IE
      EDGE_INDEX(12,ICMM) = IE
      IF (NOM/=0) THEN
         SELECT CASE(ABS(IOR))
            CASE( 1)
               IF (IOR>0) IJKE( 9,IE) = -NOM
               IF (IOR<0) IJKE( 9,IE) =  NOM
               IJKE(10,IE) = IIO
               MM => MESHES(NOM)
               YJ  = MIN( REAL(MM%JBAR,EB)+ALMOST_ONE , MM%CELLSJ(NINT((Y(JJ)-MM%YS)*MM%RDYINT))+1._EB )
               JJO = MAX(1,FLOOR(YJ))
               M%EDGE_INTERPOLATION_FACTOR(IE,1) = YJ-JJO
               IJKE(11,IE) = JJO
               IJKE(12,IE) = KKO
            CASE( 2)
               IF (IOR>0) IJKE(13,IE) = -NOM
               IF (IOR<0) IJKE(13,IE) =  NOM
               MM => MESHES(NOM)
               XI  = MIN( REAL(MM%IBAR,EB)+ALMOST_ONE , MM%CELLSI(NINT((X(II)-MM%XS)*MM%RDXINT))+1._EB )
               IIO = MAX(1,FLOOR(XI))
               M%EDGE_INTERPOLATION_FACTOR(IE,2) = XI-IIO
               IJKE(14,IE) = IIO
               IJKE(15,IE) = JJO
               IJKE(16,IE) = KKO
         END SELECT
      ENDIF

END SELECT EDGE_DIRECTION_2

END SUBROUTINE DEFINE_EDGE


SUBROUTINE INITIAL_NOISE(NM)

! Generate random noise at the start of the simulation

REAL     :: RN2
REAL(EB) :: RN
INTEGER  :: I,J,K,SIZE_RND,IZERO
INTEGER, DIMENSION(:), ALLOCATABLE :: SEED_RND
INTEGER, INTENT(IN) :: NM

IF (EVACUATION_ONLY(NM)) RETURN

! Waste a few calls to RANDOM_NUMBER to avoid generating the exact same sequence on each mesh

CALL RANDOM_SEED(SIZE=SIZE_RND)
ALLOCATE(SEED_RND(SIZE_RND),STAT=IZERO)
CALL CHKMEMERR('INITIAL_NOISE','SEED_RND',IZERO)
SEED_RND = 2819 * 13*NM
CALL RANDOM_SEED(PUT=SEED_RND)
DEALLOCATE(SEED_RND)

DO I=1,NM
   CALL RANDOM_NUMBER(RN2)
ENDDO

! Point to local mesh variables

CALL POINT_TO_MESH(NM)

! Add random vorticity to cells that are not bounding solid surfaces

DO K=1,KBM1
   DO J=1,JBM1
      DO I=1,IBAR
      !  IF (WALL_INDEX(CELL_INDEX(I,J  ,K), 3)>0 .OR. WALL_INDEX(CELL_INDEX(I,J+1,K), 3)>0 .OR. &
      !      WALL_INDEX(CELL_INDEX(I,J  ,K), 2)>0 .OR. WALL_INDEX(CELL_INDEX(I,J,K+1), 2)>0)  CYCLE
         CALL RANDOM_NUMBER(RN2)
         RN=REAL(RN2,EB)
         RN = NOISE_VELOCITY*(-1._EB + 2._EB*RN)*CELL_SIZE
         W(I,J,K)   = W(I,J,K)   - RN*RDY(J)
         W(I,J+1,K) = W(I,J+1,K) + RN*RDY(J+1)
         V(I,J,K)   = V(I,J,K)   + RN*RDZ(K)
         V(I,J,K+1) = V(I,J,K+1) - RN*RDZ(K+1)
      ENDDO
   ENDDO
ENDDO
DO K=1,KBM1
   DO J=1,JBAR
      DO I=1,IBM1
      !  IF (WALL_INDEX(CELL_INDEX(I,J  ,K), 3)>0 .OR. WALL_INDEX(CELL_INDEX(I+1,J,K), 3)>0 .OR. &
      !      WALL_INDEX(CELL_INDEX(I,J  ,K), 1)>0 .OR. WALL_INDEX(CELL_INDEX(I,J,K+1), 1)>0)  CYCLE
         CALL RANDOM_NUMBER(RN2)
         RN=REAL(RN2,EB)
         RN = NOISE_VELOCITY*(-1._EB + 2._EB*RN)*CELL_SIZE
         W(I,J,K)   = W(I,J,K)   - RN*RDX(I)*R(I)*RRN(I)
         W(I+1,J,K) = W(I+1,J,K) + RN*RDX(I+1)*R(I)*RRN(I+1)
         U(I,J,K)   = U(I,J,K)   + RN*RDZ(K)
         U(I,J,K+1) = U(I,J,K+1) - RN*RDZ(K+1)
      ENDDO
   ENDDO
ENDDO
DO K=1,KBAR
   DO J=1,JBM1
      DO I=1,IBM1
      !  IF (WALL_INDEX(CELL_INDEX(I,J  ,K), 2)>0 .OR. WALL_INDEX(CELL_INDEX(I+1,J,K), 2)>0 .OR. &
      !      WALL_INDEX(CELL_INDEX(I,J  ,K), 1)>0 .OR. WALL_INDEX(CELL_INDEX(I,J+1,K), 1)>0)  CYCLE
         CALL RANDOM_NUMBER(RN2)
         RN=REAL(RN2,EB)
         RN = NOISE_VELOCITY*(-1._EB + 2._EB*RN)*CELL_SIZE
         V(I,J,K)   = V(I,J,K)   - RN*RDX(I)
         V(I+1,J,K) = V(I+1,J,K) + RN*RDX(I+1)
         U(I,J,K)   = U(I,J,K)   + RN*RDY(J)
         U(I,J+1,K) = U(I,J+1,K) - RN*RDY(J+1)
      ENDDO
   ENDDO
ENDDO

END SUBROUTINE INITIAL_NOISE


SUBROUTINE UVW_INIT(NM,FN_UVW)

! Read UVW file

USE COMP_FUNCTIONS, ONLY: GET_FILE_NUMBER,SHUTDOWN
INTEGER  :: I,J,K,II,JJ,KK,IW,IOR,LU_UVW,IERROR,IMIN,IMAX,JMIN,JMAX,KMIN,KMAX
INTEGER, INTENT(IN) :: NM
CHARACTER(80), INTENT(IN) :: FN_UVW
CHARACTER(MESSAGE_LENGTH) :: MESSAGE
CHARACTER(3) :: STR
TYPE(WALL_TYPE), POINTER :: WC=>NULL()

CALL POINT_TO_MESH(NM)

LU_UVW = GET_FILE_NUMBER()
OPEN(UNIT=LU_UVW,FILE=FN_UVW,FORM='FORMATTED',STATUS='OLD',IOSTAT=IERROR)

IF (IERROR/=0) THEN
   WRITE(STR,'(I3)') NM
   MESSAGE = 'ERROR: Problem with MESH '//TRIM(ADJUSTL(STR))//'; UVW_FILE '//TRIM(FN_UVW)//' does not exist.'
   CALL SHUTDOWN(MESSAGE)
   RETURN
ENDIF

IF (PERIODIC_TEST==2) THEN
   IMIN = 1
   IMAX = IBAR
   JMIN = 1
   JMAX = JBAR
   KMIN = 1
   KMAX = KBAR
ELSE
   READ(LU_UVW,*) IMIN,IMAX,JMIN,JMAX,KMIN,KMAX
   IMIN = MAX(0,IMIN)
   IMAX = MIN(IBAR,IMAX)
   JMIN = MAX(0,JMIN)
   JMAX = MIN(JBAR,JMAX)
   KMIN = MAX(0,KMIN)
   KMAX = MIN(KBAR,KMAX)
ENDIF
DO K=KMIN,KMAX
   DO J=JMIN,JMAX
      DO I=IMIN,IMAX
         READ(LU_UVW,*,IOSTAT=IERROR) U(I,J,K),V(I,J,K),W(I,J,K)
         IF (IERROR/=0) THEN
            U(I,J,K)=0._EB
            V(I,J,K)=0._EB
            W(I,J,K)=0._EB
         ENDIF
      ENDDO
   ENDDO
ENDDO

CLOSE(LU_UVW)

IF (PERIODIC_TEST==2) THEN
   U(0,:,:) = U(IBAR,:,:)
   V(:,0,:) = V(:,JBAR,:)
   W(:,:,0) = W(:,:,KBAR)
ENDIF

US=U
VS=V
WS=W

! Set normal velocity on external and internal boundaries (follows divg)

DO IW=1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS
   WC  => WALL(IW)
   IOR = WC%ONE_D%IOR
   II  = WC%ONE_D%II
   JJ  = WC%ONE_D%JJ
   KK  = WC%ONE_D%KK
   SELECT CASE(IOR)
      CASE( 1)
         WC%ONE_D%UWS = -U(II,JJ,KK)
      CASE(-1)
         WC%ONE_D%UWS =  U(II-1,JJ,KK)
      CASE( 2)
         WC%ONE_D%UWS = -V(II,JJ,KK)
      CASE(-2)
         WC%ONE_D%UWS =  V(II,JJ-1,KK)
      CASE( 3)
         WC%ONE_D%UWS = -W(II,JJ,KK)
      CASE(-3)
         WC%ONE_D%UWS =  W(II,JJ,KK-1)
   END SELECT
   WALL(IW)%ONE_D%UW = WALL(IW)%ONE_D%UWS
ENDDO

END SUBROUTINE UVW_INIT

END PROGRAM FDS
